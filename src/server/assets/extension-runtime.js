"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../api/src/api/ai.ts
var AI;
var init_ai = __esm({
  "../api/src/api/ai.ts"() {
    "use strict";
    ((AI2) => {
      function ask(prompt, options) {
        throw new Error("not implemented");
      }
      AI2.ask = ask;
      let Model;
      ((Model2) => {
        Model2["OpenAI_GPT4"] = "openai-gpt-4";
        Model2["OpenAI_GPT4-turbo"] = "openai-gpt-4-turbo";
        Model2["OpenAI_GPT4o"] = "openai-gpt-4o";
        Model2["OpenAI_GPT4o-mini"] = "openai-gpt-4o-mini";
        Model2["Anthropic_Claude_Haiku"] = "anthropic-claude-haiku";
        Model2["Anthropic_Claude_Opus"] = "anthropic-claude-opus";
        Model2["Anthropic_Claude_Sonnet"] = "anthropic-claude-sonnet";
        Model2["MixtraL_8x7B"] = "mixtral-8x7b";
        Model2["Mistral_Nemo"] = "mistral-nemo";
        Model2["Mistral_Large2"] = "mistral-large-2";
        Model2["Llama3_70B"] = "llama3-70b";
        Model2["Llama3.1_70B"] = "llama3.1-70b";
        Model2["Llama3.1_8B"] = "llama3.1-8b";
        Model2["Llama3.1_405B"] = "llama3.1-405b";
        Model2["Perplexity_Llama3.1_Sonar_Huge"] = "perplexity-llama-3.1-sonar-huge-128k-online";
        Model2["Perplexity_Llama3.1_Sonar_Large"] = "perplexity-llama-3.1-sonar-large-128k-online";
        Model2["Perplexity_Llama3.1_Sonar_Small"] = "perplexity-llama-3.1-sonar-small-128k-online";
        Model2["OpenAI_GPT3.5-turbo-instruct"] = "openai-gpt-3.5-turbo-instruct";
        Model2["Llama2_70B"] = "llama2-70b";
        Model2["Perplexity_Sonar_Medium_Online"] = "perplexity-sonar-medium-online";
        Model2["Perplexity_Sonar_Small_Online"] = "perplexity-sonar-small-online";
        Model2["Codellama_70B_instruct"] = "codellama-70b-instruct";
        Model2["Perplexity_Llama3_Sonar_Large"] = "perplexity-llama-3-sonar-large-online";
        Model2["Perplexity_Llama3_Sonar_Small"] = "perplexity-llama-3-sonar-small-online";
        Model2["OpenAI_GPT3.5-turbo"] = "openai-gpt-3.5-turbo";
      })(Model = AI2.Model || (AI2.Model = {}));
      AI2.getModels = async () => {
        throw new Error("not implemented");
      };
    })(AI || (AI = {}));
  }
});

// ../api/node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "../api/node_modules/react/cjs/react.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component2(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component2.prototype.isReactComponent = {};
    Component2.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component2.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component2.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component2.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = { H: null, A: null, T: null, S: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement2(type, key, self, source, owner, props) {
      self = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== self ? self : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement2(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function noop$1() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop() {
    }
    exports2.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports2.Component = Component2;
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.Profiler = REACT_PROFILER_TYPE;
    exports2.PureComponent = PureComponent;
    exports2.StrictMode = REACT_STRICT_MODE_TYPE;
    exports2.Suspense = REACT_SUSPENSE_TYPE;
    exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports2.act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports2.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports2.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement2(element.type, key, void 0, void 0, owner, props);
    };
    exports2.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports2.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement2(type, key, void 0, void 0, null, props);
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports2.isValidElement = isValidElement;
    exports2.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports2.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports2.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    exports2.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports2.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports2.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports2.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports2.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports2.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    exports2.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports2.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports2.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports2.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports2.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports2.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports2.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports2.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports2.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports2.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports2.version = "19.0.0";
  }
});

// ../api/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "../api/node_modules/react/cjs/react.development.js"(exports2, module2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component2.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component2(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function isValidElementType(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? true : false;
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
          var prototype = type.prototype;
          return describeNativeComponentFrame(
            type,
            !(!prototype || !prototype.isReactComponent)
          );
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return type = describeNativeComponentFrame(type.render, false), type;
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
              prototype = type._payload;
              type = type._init;
              try {
                return describeUnknownElementTypeFrameInDEV(type(prototype));
              } catch (x) {
              }
          }
        return "";
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement2(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement2(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props
        );
        newKey._store.validated = oldElement._store.validated;
        return newKey;
      }
      function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
          if (isArrayImpl(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement(node))
            node._store && (node._store.validated = 1);
          else if (i = getIteratorFn(node), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node))
            for (; !(node = i.next()).done; )
              isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
          ownerHasKeyUseWarning[parentType] = true;
          var childOwner = "";
          element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
          var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = function() {
            var stack = describeUnknownElementTypeFrameInDEV(element.type);
            prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
            return stack;
          };
          console.error(
            'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
            parentType,
            childOwner
          );
          ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
      }
      function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function noop() {
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module2 && module2[requireString]).call(
              module2,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component2.prototype.isReactComponent = {};
      Component2.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component2.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component2.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component2.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null
      }, hasOwnProperty = Object.prototype.hasOwnProperty, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var ownerHasKeyUseWarning = {}, didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      exports2.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports2.Component = Component2;
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.Profiler = REACT_PROFILER_TYPE;
      exports2.PureComponent = PureComponent;
      exports2.StrictMode = REACT_STRICT_MODE_TYPE;
      exports2.Suspense = REACT_SUSPENSE_TYPE;
      exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports2.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$2) {
                      ReactSharedInternals.thrownErrors.push(error$2);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports2.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports2.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement2(element.type, key, void 0, void 0, owner, props);
        for (key = 2; key < arguments.length; key++)
          validateChildKeys(arguments[key], props.type);
        return props;
      };
      exports2.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports2.createElement = function(type, config, children) {
        if (isValidElementType(type))
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i], type);
        else {
          i = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
            i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          if (null === type) var typeString = "null";
          else
            isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
          console.error(
            "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
            typeString,
            i
          );
        }
        var propName;
        i = {};
        typeString = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), typeString = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        typeString && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement2(type, typeString, void 0, void 0, getOwner(), i);
      };
      exports2.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports2.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports2.isValidElement = isValidElement;
      exports2.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports2.memo = function(type, compare) {
        isValidElementType(type) || console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports2.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports2.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports2.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports2.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports2.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports2.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports2.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports2.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports2.useEffect = function(create, deps) {
        return resolveDispatcher().useEffect(create, deps);
      };
      exports2.useId = function() {
        return resolveDispatcher().useId();
      };
      exports2.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports2.useInsertionEffect = function(create, deps) {
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports2.useLayoutEffect = function(create, deps) {
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports2.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports2.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports2.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports2.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports2.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports2.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports2.version = "19.0.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../api/node_modules/react/index.js
var require_react = __commonJS({
  "../api/node_modules/react/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
var TWO_PWR_32_DBL, decimalFrom1e7WithLeadingZeros;
var init_varint = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js"() {
    TWO_PWR_32_DBL = 4294967296;
    decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}
var protoInt64;
var init_proto_int64 = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js"() {
    init_varint();
    protoInt64 = /* @__PURE__ */ makeInt64Support();
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}
var symbol;
var init_text_encoding = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js"() {
    symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}
var WireType, FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN, BinaryWriter, BinaryReader;
var init_binary_encoding = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js"() {
    init_varint();
    init_proto_int64();
    init_text_encoding();
    (function(WireType3) {
      WireType3[WireType3["Varint"] = 0] = "Varint";
      WireType3[WireType3["Bit64"] = 1] = "Bit64";
      WireType3[WireType3["LengthDelimited"] = 2] = "LengthDelimited";
      WireType3[WireType3["StartGroup"] = 3] = "StartGroup";
      WireType3[WireType3["EndGroup"] = 4] = "EndGroup";
      WireType3[WireType3["Bit32"] = 5] = "Bit32";
    })(WireType || (WireType = {}));
    FLOAT32_MAX = 34028234663852886e22;
    FLOAT32_MIN = -34028234663852886e22;
    UINT32_MAX = 4294967295;
    INT32_MAX = 2147483647;
    INT32_MIN = -2147483648;
    BinaryWriter = class {
      constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
        this.encodeUtf8 = encodeUtf8;
        this.stack = [];
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
          len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
          bytes.set(this.chunks[i], offset);
          offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk = this.encodeUtf8(value);
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        varint32write(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let tc = protoInt64.enc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        const tc = protoInt64.uEnc(value);
        varint64write(tc.lo, tc.hi, this.buf);
        return this;
      }
    };
    BinaryReader = class {
      constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
        this.decodeUtf8 = decodeUtf8;
        this.varint64 = varint64read;
        this.uint32 = varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element and return the skipped data.
       *
       * When skipping StartGroup, provide the tags field number to check for
       * matching field number in the EndGroup tag.
       */
      skip(wireType, fieldNo) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
          case WireType.Bit64:
            this.pos += 4;
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            for (; ; ) {
              const [fn, wt] = this.tag();
              if (wt === WireType.EndGroup) {
                if (fieldNo !== void 0 && fn !== fieldNo) {
                  throw new Error("invalid end group tag");
                }
                break;
              }
              this.skip(wt, fn);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return protoInt64.dec(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return protoInt64.uDec(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return protoInt64.dec(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return protoInt64.uDec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return protoInt64.dec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.decodeUtf8(this.bytes());
      }
    };
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js
var init_base64_encoding = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js"() {
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/text-format.js
var init_text_format = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/text-format.js"() {
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/size-delimited.js
var init_size_delimited = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/size-delimited.js"() {
  }
});

// ../api/node_modules/@bufbuild/protobuf/dist/esm/wire/index.js
var init_wire = __esm({
  "../api/node_modules/@bufbuild/protobuf/dist/esm/wire/index.js"() {
    init_binary_encoding();
    init_base64_encoding();
    init_text_encoding();
    init_text_format();
    init_size_delimited();
  }
});

// ../api/src/api/proto/common.ts
function createBaseAckResponse() {
  return {};
}
function createBaseErrorResponse() {
  return { errorText: "" };
}
function isSet(value) {
  return value !== null && value !== void 0;
}
var AckResponse, ErrorResponse;
var init_common = __esm({
  "../api/src/api/proto/common.ts"() {
    "use strict";
    init_wire();
    AckResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return AckResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseAckResponse();
        return message;
      }
    };
    ErrorResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.errorText !== "") {
          writer.uint32(10).string(message.errorText);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseErrorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.errorText = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { errorText: isSet(object.errorText) ? globalThis.String(object.errorText) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.errorText !== "") {
          obj.errorText = message.errorText;
        }
        return obj;
      },
      create(base) {
        return ErrorResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseErrorResponse();
        message.errorText = object.errorText ?? "";
        return message;
      }
    };
  }
});

// ../api/src/api/proto/google/protobuf/struct.ts
function nullValueFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return 0 /* NULL_VALUE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function nullValueToJSON(object) {
  switch (object) {
    case 0 /* NULL_VALUE */:
      return "NULL_VALUE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseStruct() {
  return { fields: {} };
}
function createBaseStruct_FieldsEntry() {
  return { key: "", value: void 0 };
}
function createBaseValue() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
function createBaseListValue() {
  return { values: [] };
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet2(value) {
  return value !== null && value !== void 0;
}
var Struct, Struct_FieldsEntry, Value, ListValue;
var init_struct = __esm({
  "../api/src/api/proto/google/protobuf/struct.ts"() {
    "use strict";
    init_wire();
    Struct = {
      encode(message, writer = new BinaryWriter()) {
        Object.entries(message.fields).forEach(([key, value]) => {
          if (value !== void 0) {
            Struct_FieldsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
          }
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStruct();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
              if (entry1.value !== void 0) {
                message.fields[entry1.key] = entry1.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          fields: isObject(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {}) : {}
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.fields) {
          const entries = Object.entries(message.fields);
          if (entries.length > 0) {
            obj.fields = {};
            entries.forEach(([k, v]) => {
              obj.fields[k] = v;
            });
          }
        }
        return obj;
      },
      create(base) {
        return Struct.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseStruct();
        message.fields = Object.entries(object.fields ?? {}).reduce(
          (acc, [key, value]) => {
            if (value !== void 0) {
              acc[key] = value;
            }
            return acc;
          },
          {}
        );
        return message;
      },
      wrap(object) {
        const struct = createBaseStruct();
        if (object !== void 0) {
          for (const key of Object.keys(object)) {
            struct.fields[key] = object[key];
          }
        }
        return struct;
      },
      unwrap(message) {
        const object = {};
        if (message.fields) {
          for (const key of Object.keys(message.fields)) {
            object[key] = message.fields[key];
          }
        }
        return object;
      }
    };
    Struct_FieldsEntry = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStruct_FieldsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet2(object.key) ? globalThis.String(object.key) : "",
          value: isSet2(object?.value) ? object.value : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return Struct_FieldsEntry.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseStruct_FieldsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? void 0;
        return message;
      }
    };
    Value = {
      encode(message, writer = new BinaryWriter()) {
        if (message.nullValue !== void 0) {
          writer.uint32(8).int32(message.nullValue);
        }
        if (message.numberValue !== void 0) {
          writer.uint32(17).double(message.numberValue);
        }
        if (message.stringValue !== void 0) {
          writer.uint32(26).string(message.stringValue);
        }
        if (message.boolValue !== void 0) {
          writer.uint32(32).bool(message.boolValue);
        }
        if (message.structValue !== void 0) {
          Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();
        }
        if (message.listValue !== void 0) {
          ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValue();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.nullValue = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 17) {
                break;
              }
              message.numberValue = reader.double();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.stringValue = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.boolValue = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          nullValue: isSet2(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
          numberValue: isSet2(object.numberValue) ? globalThis.Number(object.numberValue) : void 0,
          stringValue: isSet2(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
          boolValue: isSet2(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0,
          structValue: isObject(object.structValue) ? object.structValue : void 0,
          listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.nullValue !== void 0) {
          obj.nullValue = nullValueToJSON(message.nullValue);
        }
        if (message.numberValue !== void 0) {
          obj.numberValue = message.numberValue;
        }
        if (message.stringValue !== void 0) {
          obj.stringValue = message.stringValue;
        }
        if (message.boolValue !== void 0) {
          obj.boolValue = message.boolValue;
        }
        if (message.structValue !== void 0) {
          obj.structValue = message.structValue;
        }
        if (message.listValue !== void 0) {
          obj.listValue = message.listValue;
        }
        return obj;
      },
      create(base) {
        return Value.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseValue();
        message.nullValue = object.nullValue ?? void 0;
        message.numberValue = object.numberValue ?? void 0;
        message.stringValue = object.stringValue ?? void 0;
        message.boolValue = object.boolValue ?? void 0;
        message.structValue = object.structValue ?? void 0;
        message.listValue = object.listValue ?? void 0;
        return message;
      },
      wrap(value) {
        const result = createBaseValue();
        if (value === null) {
          result.nullValue = 0 /* NULL_VALUE */;
        } else if (typeof value === "boolean") {
          result.boolValue = value;
        } else if (typeof value === "number") {
          result.numberValue = value;
        } else if (typeof value === "string") {
          result.stringValue = value;
        } else if (globalThis.Array.isArray(value)) {
          result.listValue = value;
        } else if (typeof value === "object") {
          result.structValue = value;
        } else if (typeof value !== "undefined") {
          throw new globalThis.Error("Unsupported any value type: " + typeof value);
        }
        return result;
      },
      unwrap(message) {
        if (message.stringValue !== void 0) {
          return message.stringValue;
        } else if (message?.numberValue !== void 0) {
          return message.numberValue;
        } else if (message?.boolValue !== void 0) {
          return message.boolValue;
        } else if (message?.structValue !== void 0) {
          return message.structValue;
        } else if (message?.listValue !== void 0) {
          return message.listValue;
        } else if (message?.nullValue !== void 0) {
          return null;
        }
        return void 0;
      }
    };
    ListValue = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.values) {
          Value.encode(Value.wrap(v), writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListValue();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.values?.length) {
          obj.values = message.values;
        }
        return obj;
      },
      create(base) {
        return ListValue.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseListValue();
        message.values = object.values?.map((e) => e) || [];
        return message;
      },
      wrap(array) {
        const result = createBaseListValue();
        result.values = array ?? [];
        return result;
      },
      unwrap(message) {
        if (message?.hasOwnProperty("values") && globalThis.Array.isArray(message.values)) {
          return message.values;
        } else {
          return message;
        }
      }
    };
  }
});

// ../api/src/api/proto/ui.ts
function toastStyleFromJSON(object) {
  switch (object) {
    case 0:
    case "Success":
      return 0 /* Success */;
    case 1:
    case "Info":
      return 1 /* Info */;
    case 2:
    case "Warning":
      return 2 /* Warning */;
    case 3:
    case "Error":
      return 3 /* Error */;
    case 4:
    case "Dynamic":
      return 4 /* Dynamic */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function toastStyleToJSON(object) {
  switch (object) {
    case 0 /* Success */:
      return "Success";
    case 1 /* Info */:
      return "Info";
    case 2 /* Warning */:
      return "Warning";
    case 3 /* Error */:
      return "Error";
    case 4 /* Dynamic */:
      return "Dynamic";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function popToRootTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "PopToRootDefault":
      return 0 /* PopToRootDefault */;
    case 1:
    case "PopToRootImmediate":
      return 1 /* PopToRootImmediate */;
    case 2:
    case "PopToRootSuspended":
      return 2 /* PopToRootSuspended */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function popToRootTypeToJSON(object) {
  switch (object) {
    case 0 /* PopToRootDefault */:
      return "PopToRootDefault";
    case 1 /* PopToRootImmediate */:
      return "PopToRootImmediate";
    case 2 /* PopToRootSuspended */:
      return "PopToRootSuspended";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function confirmAlertActionStyleFromJSON(object) {
  switch (object) {
    case 0:
    case "Default":
      return 0 /* Default */;
    case 1:
    case "Destructive":
      return 1 /* Destructive */;
    case 2:
    case "Cancel":
      return 2 /* Cancel */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function confirmAlertActionStyleToJSON(object) {
  switch (object) {
    case 0 /* Default */:
      return "Default";
    case 1 /* Destructive */:
      return "Destructive";
    case 2 /* Cancel */:
      return "Cancel";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function imageMaskFromJSON(object) {
  switch (object) {
    case 0:
    case "None":
      return 0 /* None */;
    case 1:
    case "Circle":
      return 1 /* Circle */;
    case 2:
    case "RoundedRectangle":
      return 2 /* RoundedRectangle */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function imageMaskToJSON(object) {
  switch (object) {
    case 0 /* None */:
      return "None";
    case 1 /* Circle */:
      return "Circle";
    case 2 /* RoundedRectangle */:
      return "RoundedRectangle";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseShowToastRequest() {
  return { id: "", title: "", style: 0 };
}
function createBaseHideToastRequest() {
  return { id: "" };
}
function createBaseUpdateToastRequest() {
  return { id: "", title: "" };
}
function createBasePushViewRequest() {
  return {};
}
function createBasePopViewRequest() {
  return {};
}
function createBaseCloseMainWindowRequest() {
  return { clearRootSearch: false, popToRoot: 0 };
}
function createBaseClearSearchBarRequest() {
  return {};
}
function createBaseSetSearchTextRequest() {
  return { text: "" };
}
function createBaseGetSelectedTextRequest() {
  return {};
}
function createBaseGetSelectedTextResponse() {
  return { text: "" };
}
function createBaseShowHudRequest() {
  return { text: "", clearRootSearch: false, popToRoot: 0 };
}
function createBaseRenderRequest() {
  return { json: "" };
}
function createBaseConfirmAlertRequest() {
  return {
    title: "",
    description: "",
    icon: void 0,
    dismissAction: void 0,
    primaryAction: void 0,
    rememberUserChoice: false
  };
}
function createBaseConfirmAlertResponse() {
  return { confirmed: false };
}
function createBaseConfirmAlertAction() {
  return { title: "", style: 0 };
}
function createBasePopToRootRequest() {
  return { clearSearchBar: false };
}
function createBaseRequest() {
  return {
    render: void 0,
    showToast: void 0,
    hideToast: void 0,
    updateToast: void 0,
    pushView: void 0,
    popView: void 0,
    clearSearch: void 0,
    closeMainWindow: void 0,
    showHud: void 0,
    setSearchText: void 0,
    confirmAlert: void 0,
    getSelectedText: void 0,
    popToRoot: void 0
  };
}
function createBaseResponse() {
  return {
    render: void 0,
    showToast: void 0,
    hideToast: void 0,
    updateToast: void 0,
    pushView: void 0,
    popView: void 0,
    clearSearch: void 0,
    closeMainWindow: void 0,
    showHud: void 0,
    setSearchText: void 0,
    confirmAlert: void 0,
    getSelectedText: void 0,
    popToRoot: void 0
  };
}
function createBaseThemedImageSource() {
  return { light: "", dark: "" };
}
function createBaseImageSource() {
  return { raw: void 0, themed: void 0 };
}
function createBaseDynamicColor() {
  return { light: "", dark: "", adjustContrast: void 0 };
}
function createBaseColorLike() {
  return { raw: void 0, dynamic: void 0 };
}
function createBaseImage() {
  return { source: void 0, fallback: void 0, mask: void 0, tintColor: void 0 };
}
function isSet3(value) {
  return value !== null && value !== void 0;
}
var ShowToastRequest, HideToastRequest, UpdateToastRequest, PushViewRequest, PopViewRequest, CloseMainWindowRequest, ClearSearchBarRequest, SetSearchTextRequest, GetSelectedTextRequest, GetSelectedTextResponse, ShowHudRequest, RenderRequest, ConfirmAlertRequest, ConfirmAlertResponse, ConfirmAlertAction, PopToRootRequest, Request, Response, ThemedImageSource, ImageSource, DynamicColor, ColorLike, Image;
var init_ui = __esm({
  "../api/src/api/proto/ui.ts"() {
    "use strict";
    init_wire();
    init_common();
    init_struct();
    ShowToastRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        if (message.style !== 0) {
          writer.uint32(24).int32(message.style);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseShowToastRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.style = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? globalThis.String(object.id) : "",
          title: isSet3(object.title) ? globalThis.String(object.title) : "",
          style: isSet3(object.style) ? toastStyleFromJSON(object.style) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.title !== "") {
          obj.title = message.title;
        }
        if (message.style !== 0) {
          obj.style = toastStyleToJSON(message.style);
        }
        return obj;
      },
      create(base) {
        return ShowToastRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseShowToastRequest();
        message.id = object.id ?? "";
        message.title = object.title ?? "";
        message.style = object.style ?? 0;
        return message;
      }
    };
    HideToastRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHideToastRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { id: isSet3(object.id) ? globalThis.String(object.id) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        return obj;
      },
      create(base) {
        return HideToastRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseHideToastRequest();
        message.id = object.id ?? "";
        return message;
      }
    };
    UpdateToastRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateToastRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet3(object.id) ? globalThis.String(object.id) : "",
          title: isSet3(object.title) ? globalThis.String(object.title) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.title !== "") {
          obj.title = message.title;
        }
        return obj;
      },
      create(base) {
        return UpdateToastRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseUpdateToastRequest();
        message.id = object.id ?? "";
        message.title = object.title ?? "";
        return message;
      }
    };
    PushViewRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePushViewRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return PushViewRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBasePushViewRequest();
        return message;
      }
    };
    PopViewRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePopViewRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return PopViewRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBasePopViewRequest();
        return message;
      }
    };
    CloseMainWindowRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.clearRootSearch !== false) {
          writer.uint32(8).bool(message.clearRootSearch);
        }
        if (message.popToRoot !== 0) {
          writer.uint32(16).int32(message.popToRoot);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCloseMainWindowRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.clearRootSearch = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.popToRoot = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          clearRootSearch: isSet3(object.clearRootSearch) ? globalThis.Boolean(object.clearRootSearch) : false,
          popToRoot: isSet3(object.popToRoot) ? popToRootTypeFromJSON(object.popToRoot) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.clearRootSearch !== false) {
          obj.clearRootSearch = message.clearRootSearch;
        }
        if (message.popToRoot !== 0) {
          obj.popToRoot = popToRootTypeToJSON(message.popToRoot);
        }
        return obj;
      },
      create(base) {
        return CloseMainWindowRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseCloseMainWindowRequest();
        message.clearRootSearch = object.clearRootSearch ?? false;
        message.popToRoot = object.popToRoot ?? 0;
        return message;
      }
    };
    ClearSearchBarRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClearSearchBarRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ClearSearchBarRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseClearSearchBarRequest();
        return message;
      }
    };
    SetSearchTextRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
          writer.uint32(10).string(message.text);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetSearchTextRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { text: isSet3(object.text) ? globalThis.String(object.text) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== "") {
          obj.text = message.text;
        }
        return obj;
      },
      create(base) {
        return SetSearchTextRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSetSearchTextRequest();
        message.text = object.text ?? "";
        return message;
      }
    };
    GetSelectedTextRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetSelectedTextRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return GetSelectedTextRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseGetSelectedTextRequest();
        return message;
      }
    };
    GetSelectedTextResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
          writer.uint32(10).string(message.text);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetSelectedTextResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { text: isSet3(object.text) ? globalThis.String(object.text) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== "") {
          obj.text = message.text;
        }
        return obj;
      },
      create(base) {
        return GetSelectedTextResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetSelectedTextResponse();
        message.text = object.text ?? "";
        return message;
      }
    };
    ShowHudRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
          writer.uint32(10).string(message.text);
        }
        if (message.clearRootSearch !== false) {
          writer.uint32(16).bool(message.clearRootSearch);
        }
        if (message.popToRoot !== 0) {
          writer.uint32(24).int32(message.popToRoot);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseShowHudRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.clearRootSearch = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.popToRoot = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          text: isSet3(object.text) ? globalThis.String(object.text) : "",
          clearRootSearch: isSet3(object.clearRootSearch) ? globalThis.Boolean(object.clearRootSearch) : false,
          popToRoot: isSet3(object.popToRoot) ? popToRootTypeFromJSON(object.popToRoot) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== "") {
          obj.text = message.text;
        }
        if (message.clearRootSearch !== false) {
          obj.clearRootSearch = message.clearRootSearch;
        }
        if (message.popToRoot !== 0) {
          obj.popToRoot = popToRootTypeToJSON(message.popToRoot);
        }
        return obj;
      },
      create(base) {
        return ShowHudRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseShowHudRequest();
        message.text = object.text ?? "";
        message.clearRootSearch = object.clearRootSearch ?? false;
        message.popToRoot = object.popToRoot ?? 0;
        return message;
      }
    };
    RenderRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.json !== "") {
          writer.uint32(10).string(message.json);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRenderRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.json = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { json: isSet3(object.json) ? globalThis.String(object.json) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.json !== "") {
          obj.json = message.json;
        }
        return obj;
      },
      create(base) {
        return RenderRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRenderRequest();
        message.json = object.json ?? "";
        return message;
      }
    };
    ConfirmAlertRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.icon !== void 0) {
          Image.encode(message.icon, writer.uint32(26).fork()).join();
        }
        if (message.dismissAction !== void 0) {
          ConfirmAlertAction.encode(message.dismissAction, writer.uint32(34).fork()).join();
        }
        if (message.primaryAction !== void 0) {
          ConfirmAlertAction.encode(message.primaryAction, writer.uint32(42).fork()).join();
        }
        if (message.rememberUserChoice !== false) {
          writer.uint32(48).bool(message.rememberUserChoice);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConfirmAlertRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.description = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.icon = Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.dismissAction = ConfirmAlertAction.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.primaryAction = ConfirmAlertAction.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.rememberUserChoice = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? globalThis.String(object.title) : "",
          description: isSet3(object.description) ? globalThis.String(object.description) : "",
          icon: isSet3(object.icon) ? Image.fromJSON(object.icon) : void 0,
          dismissAction: isSet3(object.dismissAction) ? ConfirmAlertAction.fromJSON(object.dismissAction) : void 0,
          primaryAction: isSet3(object.primaryAction) ? ConfirmAlertAction.fromJSON(object.primaryAction) : void 0,
          rememberUserChoice: isSet3(object.rememberUserChoice) ? globalThis.Boolean(object.rememberUserChoice) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.title !== "") {
          obj.title = message.title;
        }
        if (message.description !== "") {
          obj.description = message.description;
        }
        if (message.icon !== void 0) {
          obj.icon = Image.toJSON(message.icon);
        }
        if (message.dismissAction !== void 0) {
          obj.dismissAction = ConfirmAlertAction.toJSON(message.dismissAction);
        }
        if (message.primaryAction !== void 0) {
          obj.primaryAction = ConfirmAlertAction.toJSON(message.primaryAction);
        }
        if (message.rememberUserChoice !== false) {
          obj.rememberUserChoice = message.rememberUserChoice;
        }
        return obj;
      },
      create(base) {
        return ConfirmAlertRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseConfirmAlertRequest();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.icon = object.icon !== void 0 && object.icon !== null ? Image.fromPartial(object.icon) : void 0;
        message.dismissAction = object.dismissAction !== void 0 && object.dismissAction !== null ? ConfirmAlertAction.fromPartial(object.dismissAction) : void 0;
        message.primaryAction = object.primaryAction !== void 0 && object.primaryAction !== null ? ConfirmAlertAction.fromPartial(object.primaryAction) : void 0;
        message.rememberUserChoice = object.rememberUserChoice ?? false;
        return message;
      }
    };
    ConfirmAlertResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.confirmed !== false) {
          writer.uint32(8).bool(message.confirmed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConfirmAlertResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.confirmed = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { confirmed: isSet3(object.confirmed) ? globalThis.Boolean(object.confirmed) : false };
      },
      toJSON(message) {
        const obj = {};
        if (message.confirmed !== false) {
          obj.confirmed = message.confirmed;
        }
        return obj;
      },
      create(base) {
        return ConfirmAlertResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseConfirmAlertResponse();
        message.confirmed = object.confirmed ?? false;
        return message;
      }
    };
    ConfirmAlertAction = {
      encode(message, writer = new BinaryWriter()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.style !== 0) {
          writer.uint32(16).int32(message.style);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConfirmAlertAction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.style = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          title: isSet3(object.title) ? globalThis.String(object.title) : "",
          style: isSet3(object.style) ? confirmAlertActionStyleFromJSON(object.style) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.title !== "") {
          obj.title = message.title;
        }
        if (message.style !== 0) {
          obj.style = confirmAlertActionStyleToJSON(message.style);
        }
        return obj;
      },
      create(base) {
        return ConfirmAlertAction.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseConfirmAlertAction();
        message.title = object.title ?? "";
        message.style = object.style ?? 0;
        return message;
      }
    };
    PopToRootRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.clearSearchBar !== false) {
          writer.uint32(8).bool(message.clearSearchBar);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePopToRootRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.clearSearchBar = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { clearSearchBar: isSet3(object.clearSearchBar) ? globalThis.Boolean(object.clearSearchBar) : false };
      },
      toJSON(message) {
        const obj = {};
        if (message.clearSearchBar !== false) {
          obj.clearSearchBar = message.clearSearchBar;
        }
        return obj;
      },
      create(base) {
        return PopToRootRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBasePopToRootRequest();
        message.clearSearchBar = object.clearSearchBar ?? false;
        return message;
      }
    };
    Request = {
      encode(message, writer = new BinaryWriter()) {
        if (message.render !== void 0) {
          RenderRequest.encode(message.render, writer.uint32(10).fork()).join();
        }
        if (message.showToast !== void 0) {
          ShowToastRequest.encode(message.showToast, writer.uint32(18).fork()).join();
        }
        if (message.hideToast !== void 0) {
          HideToastRequest.encode(message.hideToast, writer.uint32(26).fork()).join();
        }
        if (message.updateToast !== void 0) {
          UpdateToastRequest.encode(message.updateToast, writer.uint32(34).fork()).join();
        }
        if (message.pushView !== void 0) {
          PushViewRequest.encode(message.pushView, writer.uint32(42).fork()).join();
        }
        if (message.popView !== void 0) {
          PopViewRequest.encode(message.popView, writer.uint32(50).fork()).join();
        }
        if (message.clearSearch !== void 0) {
          ClearSearchBarRequest.encode(message.clearSearch, writer.uint32(58).fork()).join();
        }
        if (message.closeMainWindow !== void 0) {
          CloseMainWindowRequest.encode(message.closeMainWindow, writer.uint32(66).fork()).join();
        }
        if (message.showHud !== void 0) {
          ShowHudRequest.encode(message.showHud, writer.uint32(74).fork()).join();
        }
        if (message.setSearchText !== void 0) {
          SetSearchTextRequest.encode(message.setSearchText, writer.uint32(82).fork()).join();
        }
        if (message.confirmAlert !== void 0) {
          ConfirmAlertRequest.encode(message.confirmAlert, writer.uint32(90).fork()).join();
        }
        if (message.getSelectedText !== void 0) {
          GetSelectedTextRequest.encode(message.getSelectedText, writer.uint32(98).fork()).join();
        }
        if (message.popToRoot !== void 0) {
          PopToRootRequest.encode(message.popToRoot, writer.uint32(106).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.render = RenderRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.showToast = ShowToastRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.hideToast = HideToastRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.updateToast = UpdateToastRequest.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.pushView = PushViewRequest.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.popView = PopViewRequest.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.clearSearch = ClearSearchBarRequest.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.closeMainWindow = CloseMainWindowRequest.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.showHud = ShowHudRequest.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.setSearchText = SetSearchTextRequest.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.confirmAlert = ConfirmAlertRequest.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.getSelectedText = GetSelectedTextRequest.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.popToRoot = PopToRootRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          render: isSet3(object.render) ? RenderRequest.fromJSON(object.render) : void 0,
          showToast: isSet3(object.showToast) ? ShowToastRequest.fromJSON(object.showToast) : void 0,
          hideToast: isSet3(object.hideToast) ? HideToastRequest.fromJSON(object.hideToast) : void 0,
          updateToast: isSet3(object.updateToast) ? UpdateToastRequest.fromJSON(object.updateToast) : void 0,
          pushView: isSet3(object.pushView) ? PushViewRequest.fromJSON(object.pushView) : void 0,
          popView: isSet3(object.popView) ? PopViewRequest.fromJSON(object.popView) : void 0,
          clearSearch: isSet3(object.clearSearch) ? ClearSearchBarRequest.fromJSON(object.clearSearch) : void 0,
          closeMainWindow: isSet3(object.closeMainWindow) ? CloseMainWindowRequest.fromJSON(object.closeMainWindow) : void 0,
          showHud: isSet3(object.showHud) ? ShowHudRequest.fromJSON(object.showHud) : void 0,
          setSearchText: isSet3(object.setSearchText) ? SetSearchTextRequest.fromJSON(object.setSearchText) : void 0,
          confirmAlert: isSet3(object.confirmAlert) ? ConfirmAlertRequest.fromJSON(object.confirmAlert) : void 0,
          getSelectedText: isSet3(object.getSelectedText) ? GetSelectedTextRequest.fromJSON(object.getSelectedText) : void 0,
          popToRoot: isSet3(object.popToRoot) ? PopToRootRequest.fromJSON(object.popToRoot) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.render !== void 0) {
          obj.render = RenderRequest.toJSON(message.render);
        }
        if (message.showToast !== void 0) {
          obj.showToast = ShowToastRequest.toJSON(message.showToast);
        }
        if (message.hideToast !== void 0) {
          obj.hideToast = HideToastRequest.toJSON(message.hideToast);
        }
        if (message.updateToast !== void 0) {
          obj.updateToast = UpdateToastRequest.toJSON(message.updateToast);
        }
        if (message.pushView !== void 0) {
          obj.pushView = PushViewRequest.toJSON(message.pushView);
        }
        if (message.popView !== void 0) {
          obj.popView = PopViewRequest.toJSON(message.popView);
        }
        if (message.clearSearch !== void 0) {
          obj.clearSearch = ClearSearchBarRequest.toJSON(message.clearSearch);
        }
        if (message.closeMainWindow !== void 0) {
          obj.closeMainWindow = CloseMainWindowRequest.toJSON(message.closeMainWindow);
        }
        if (message.showHud !== void 0) {
          obj.showHud = ShowHudRequest.toJSON(message.showHud);
        }
        if (message.setSearchText !== void 0) {
          obj.setSearchText = SetSearchTextRequest.toJSON(message.setSearchText);
        }
        if (message.confirmAlert !== void 0) {
          obj.confirmAlert = ConfirmAlertRequest.toJSON(message.confirmAlert);
        }
        if (message.getSelectedText !== void 0) {
          obj.getSelectedText = GetSelectedTextRequest.toJSON(message.getSelectedText);
        }
        if (message.popToRoot !== void 0) {
          obj.popToRoot = PopToRootRequest.toJSON(message.popToRoot);
        }
        return obj;
      },
      create(base) {
        return Request.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest();
        message.render = object.render !== void 0 && object.render !== null ? RenderRequest.fromPartial(object.render) : void 0;
        message.showToast = object.showToast !== void 0 && object.showToast !== null ? ShowToastRequest.fromPartial(object.showToast) : void 0;
        message.hideToast = object.hideToast !== void 0 && object.hideToast !== null ? HideToastRequest.fromPartial(object.hideToast) : void 0;
        message.updateToast = object.updateToast !== void 0 && object.updateToast !== null ? UpdateToastRequest.fromPartial(object.updateToast) : void 0;
        message.pushView = object.pushView !== void 0 && object.pushView !== null ? PushViewRequest.fromPartial(object.pushView) : void 0;
        message.popView = object.popView !== void 0 && object.popView !== null ? PopViewRequest.fromPartial(object.popView) : void 0;
        message.clearSearch = object.clearSearch !== void 0 && object.clearSearch !== null ? ClearSearchBarRequest.fromPartial(object.clearSearch) : void 0;
        message.closeMainWindow = object.closeMainWindow !== void 0 && object.closeMainWindow !== null ? CloseMainWindowRequest.fromPartial(object.closeMainWindow) : void 0;
        message.showHud = object.showHud !== void 0 && object.showHud !== null ? ShowHudRequest.fromPartial(object.showHud) : void 0;
        message.setSearchText = object.setSearchText !== void 0 && object.setSearchText !== null ? SetSearchTextRequest.fromPartial(object.setSearchText) : void 0;
        message.confirmAlert = object.confirmAlert !== void 0 && object.confirmAlert !== null ? ConfirmAlertRequest.fromPartial(object.confirmAlert) : void 0;
        message.getSelectedText = object.getSelectedText !== void 0 && object.getSelectedText !== null ? GetSelectedTextRequest.fromPartial(object.getSelectedText) : void 0;
        message.popToRoot = object.popToRoot !== void 0 && object.popToRoot !== null ? PopToRootRequest.fromPartial(object.popToRoot) : void 0;
        return message;
      }
    };
    Response = {
      encode(message, writer = new BinaryWriter()) {
        if (message.render !== void 0) {
          AckResponse.encode(message.render, writer.uint32(10).fork()).join();
        }
        if (message.showToast !== void 0) {
          AckResponse.encode(message.showToast, writer.uint32(18).fork()).join();
        }
        if (message.hideToast !== void 0) {
          AckResponse.encode(message.hideToast, writer.uint32(26).fork()).join();
        }
        if (message.updateToast !== void 0) {
          AckResponse.encode(message.updateToast, writer.uint32(34).fork()).join();
        }
        if (message.pushView !== void 0) {
          AckResponse.encode(message.pushView, writer.uint32(42).fork()).join();
        }
        if (message.popView !== void 0) {
          AckResponse.encode(message.popView, writer.uint32(50).fork()).join();
        }
        if (message.clearSearch !== void 0) {
          AckResponse.encode(message.clearSearch, writer.uint32(58).fork()).join();
        }
        if (message.closeMainWindow !== void 0) {
          AckResponse.encode(message.closeMainWindow, writer.uint32(66).fork()).join();
        }
        if (message.showHud !== void 0) {
          AckResponse.encode(message.showHud, writer.uint32(74).fork()).join();
        }
        if (message.setSearchText !== void 0) {
          AckResponse.encode(message.setSearchText, writer.uint32(82).fork()).join();
        }
        if (message.confirmAlert !== void 0) {
          ConfirmAlertResponse.encode(message.confirmAlert, writer.uint32(90).fork()).join();
        }
        if (message.getSelectedText !== void 0) {
          GetSelectedTextResponse.encode(message.getSelectedText, writer.uint32(98).fork()).join();
        }
        if (message.popToRoot !== void 0) {
          AckResponse.encode(message.popToRoot, writer.uint32(106).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.render = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.showToast = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.hideToast = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.updateToast = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.pushView = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.popView = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.clearSearch = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.closeMainWindow = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.showHud = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.setSearchText = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.confirmAlert = ConfirmAlertResponse.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.getSelectedText = GetSelectedTextResponse.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.popToRoot = AckResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          render: isSet3(object.render) ? AckResponse.fromJSON(object.render) : void 0,
          showToast: isSet3(object.showToast) ? AckResponse.fromJSON(object.showToast) : void 0,
          hideToast: isSet3(object.hideToast) ? AckResponse.fromJSON(object.hideToast) : void 0,
          updateToast: isSet3(object.updateToast) ? AckResponse.fromJSON(object.updateToast) : void 0,
          pushView: isSet3(object.pushView) ? AckResponse.fromJSON(object.pushView) : void 0,
          popView: isSet3(object.popView) ? AckResponse.fromJSON(object.popView) : void 0,
          clearSearch: isSet3(object.clearSearch) ? AckResponse.fromJSON(object.clearSearch) : void 0,
          closeMainWindow: isSet3(object.closeMainWindow) ? AckResponse.fromJSON(object.closeMainWindow) : void 0,
          showHud: isSet3(object.showHud) ? AckResponse.fromJSON(object.showHud) : void 0,
          setSearchText: isSet3(object.setSearchText) ? AckResponse.fromJSON(object.setSearchText) : void 0,
          confirmAlert: isSet3(object.confirmAlert) ? ConfirmAlertResponse.fromJSON(object.confirmAlert) : void 0,
          getSelectedText: isSet3(object.getSelectedText) ? GetSelectedTextResponse.fromJSON(object.getSelectedText) : void 0,
          popToRoot: isSet3(object.popToRoot) ? AckResponse.fromJSON(object.popToRoot) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.render !== void 0) {
          obj.render = AckResponse.toJSON(message.render);
        }
        if (message.showToast !== void 0) {
          obj.showToast = AckResponse.toJSON(message.showToast);
        }
        if (message.hideToast !== void 0) {
          obj.hideToast = AckResponse.toJSON(message.hideToast);
        }
        if (message.updateToast !== void 0) {
          obj.updateToast = AckResponse.toJSON(message.updateToast);
        }
        if (message.pushView !== void 0) {
          obj.pushView = AckResponse.toJSON(message.pushView);
        }
        if (message.popView !== void 0) {
          obj.popView = AckResponse.toJSON(message.popView);
        }
        if (message.clearSearch !== void 0) {
          obj.clearSearch = AckResponse.toJSON(message.clearSearch);
        }
        if (message.closeMainWindow !== void 0) {
          obj.closeMainWindow = AckResponse.toJSON(message.closeMainWindow);
        }
        if (message.showHud !== void 0) {
          obj.showHud = AckResponse.toJSON(message.showHud);
        }
        if (message.setSearchText !== void 0) {
          obj.setSearchText = AckResponse.toJSON(message.setSearchText);
        }
        if (message.confirmAlert !== void 0) {
          obj.confirmAlert = ConfirmAlertResponse.toJSON(message.confirmAlert);
        }
        if (message.getSelectedText !== void 0) {
          obj.getSelectedText = GetSelectedTextResponse.toJSON(message.getSelectedText);
        }
        if (message.popToRoot !== void 0) {
          obj.popToRoot = AckResponse.toJSON(message.popToRoot);
        }
        return obj;
      },
      create(base) {
        return Response.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse();
        message.render = object.render !== void 0 && object.render !== null ? AckResponse.fromPartial(object.render) : void 0;
        message.showToast = object.showToast !== void 0 && object.showToast !== null ? AckResponse.fromPartial(object.showToast) : void 0;
        message.hideToast = object.hideToast !== void 0 && object.hideToast !== null ? AckResponse.fromPartial(object.hideToast) : void 0;
        message.updateToast = object.updateToast !== void 0 && object.updateToast !== null ? AckResponse.fromPartial(object.updateToast) : void 0;
        message.pushView = object.pushView !== void 0 && object.pushView !== null ? AckResponse.fromPartial(object.pushView) : void 0;
        message.popView = object.popView !== void 0 && object.popView !== null ? AckResponse.fromPartial(object.popView) : void 0;
        message.clearSearch = object.clearSearch !== void 0 && object.clearSearch !== null ? AckResponse.fromPartial(object.clearSearch) : void 0;
        message.closeMainWindow = object.closeMainWindow !== void 0 && object.closeMainWindow !== null ? AckResponse.fromPartial(object.closeMainWindow) : void 0;
        message.showHud = object.showHud !== void 0 && object.showHud !== null ? AckResponse.fromPartial(object.showHud) : void 0;
        message.setSearchText = object.setSearchText !== void 0 && object.setSearchText !== null ? AckResponse.fromPartial(object.setSearchText) : void 0;
        message.confirmAlert = object.confirmAlert !== void 0 && object.confirmAlert !== null ? ConfirmAlertResponse.fromPartial(object.confirmAlert) : void 0;
        message.getSelectedText = object.getSelectedText !== void 0 && object.getSelectedText !== null ? GetSelectedTextResponse.fromPartial(object.getSelectedText) : void 0;
        message.popToRoot = object.popToRoot !== void 0 && object.popToRoot !== null ? AckResponse.fromPartial(object.popToRoot) : void 0;
        return message;
      }
    };
    ThemedImageSource = {
      encode(message, writer = new BinaryWriter()) {
        if (message.light !== "") {
          writer.uint32(10).string(message.light);
        }
        if (message.dark !== "") {
          writer.uint32(18).string(message.dark);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseThemedImageSource();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.light = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.dark = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          light: isSet3(object.light) ? globalThis.String(object.light) : "",
          dark: isSet3(object.dark) ? globalThis.String(object.dark) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.light !== "") {
          obj.light = message.light;
        }
        if (message.dark !== "") {
          obj.dark = message.dark;
        }
        return obj;
      },
      create(base) {
        return ThemedImageSource.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseThemedImageSource();
        message.light = object.light ?? "";
        message.dark = object.dark ?? "";
        return message;
      }
    };
    ImageSource = {
      encode(message, writer = new BinaryWriter()) {
        if (message.raw !== void 0) {
          writer.uint32(10).string(message.raw);
        }
        if (message.themed !== void 0) {
          ThemedImageSource.encode(message.themed, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImageSource();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.raw = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.themed = ThemedImageSource.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          raw: isSet3(object.raw) ? globalThis.String(object.raw) : void 0,
          themed: isSet3(object.themed) ? ThemedImageSource.fromJSON(object.themed) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.raw !== void 0) {
          obj.raw = message.raw;
        }
        if (message.themed !== void 0) {
          obj.themed = ThemedImageSource.toJSON(message.themed);
        }
        return obj;
      },
      create(base) {
        return ImageSource.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseImageSource();
        message.raw = object.raw ?? void 0;
        message.themed = object.themed !== void 0 && object.themed !== null ? ThemedImageSource.fromPartial(object.themed) : void 0;
        return message;
      }
    };
    DynamicColor = {
      encode(message, writer = new BinaryWriter()) {
        if (message.light !== "") {
          writer.uint32(10).string(message.light);
        }
        if (message.dark !== "") {
          writer.uint32(18).string(message.dark);
        }
        if (message.adjustContrast !== void 0) {
          writer.uint32(24).bool(message.adjustContrast);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDynamicColor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.light = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.dark = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.adjustContrast = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          light: isSet3(object.light) ? globalThis.String(object.light) : "",
          dark: isSet3(object.dark) ? globalThis.String(object.dark) : "",
          adjustContrast: isSet3(object.adjustContrast) ? globalThis.Boolean(object.adjustContrast) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.light !== "") {
          obj.light = message.light;
        }
        if (message.dark !== "") {
          obj.dark = message.dark;
        }
        if (message.adjustContrast !== void 0) {
          obj.adjustContrast = message.adjustContrast;
        }
        return obj;
      },
      create(base) {
        return DynamicColor.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseDynamicColor();
        message.light = object.light ?? "";
        message.dark = object.dark ?? "";
        message.adjustContrast = object.adjustContrast ?? void 0;
        return message;
      }
    };
    ColorLike = {
      encode(message, writer = new BinaryWriter()) {
        if (message.raw !== void 0) {
          writer.uint32(10).string(message.raw);
        }
        if (message.dynamic !== void 0) {
          DynamicColor.encode(message.dynamic, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseColorLike();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.raw = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.dynamic = DynamicColor.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          raw: isSet3(object.raw) ? globalThis.String(object.raw) : void 0,
          dynamic: isSet3(object.dynamic) ? DynamicColor.fromJSON(object.dynamic) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.raw !== void 0) {
          obj.raw = message.raw;
        }
        if (message.dynamic !== void 0) {
          obj.dynamic = DynamicColor.toJSON(message.dynamic);
        }
        return obj;
      },
      create(base) {
        return ColorLike.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseColorLike();
        message.raw = object.raw ?? void 0;
        message.dynamic = object.dynamic !== void 0 && object.dynamic !== null ? DynamicColor.fromPartial(object.dynamic) : void 0;
        return message;
      }
    };
    Image = {
      encode(message, writer = new BinaryWriter()) {
        if (message.source !== void 0) {
          ImageSource.encode(message.source, writer.uint32(10).fork()).join();
        }
        if (message.fallback !== void 0) {
          ImageSource.encode(message.fallback, writer.uint32(18).fork()).join();
        }
        if (message.mask !== void 0) {
          writer.uint32(24).int32(message.mask);
        }
        if (message.tintColor !== void 0) {
          ColorLike.encode(message.tintColor, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.source = ImageSource.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fallback = ImageSource.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.mask = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.tintColor = ColorLike.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          source: isSet3(object.source) ? ImageSource.fromJSON(object.source) : void 0,
          fallback: isSet3(object.fallback) ? ImageSource.fromJSON(object.fallback) : void 0,
          mask: isSet3(object.mask) ? imageMaskFromJSON(object.mask) : void 0,
          tintColor: isSet3(object.tintColor) ? ColorLike.fromJSON(object.tintColor) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.source !== void 0) {
          obj.source = ImageSource.toJSON(message.source);
        }
        if (message.fallback !== void 0) {
          obj.fallback = ImageSource.toJSON(message.fallback);
        }
        if (message.mask !== void 0) {
          obj.mask = imageMaskToJSON(message.mask);
        }
        if (message.tintColor !== void 0) {
          obj.tintColor = ColorLike.toJSON(message.tintColor);
        }
        return obj;
      },
      create(base) {
        return Image.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseImage();
        message.source = object.source !== void 0 && object.source !== null ? ImageSource.fromPartial(object.source) : void 0;
        message.fallback = object.fallback !== void 0 && object.fallback !== null ? ImageSource.fromPartial(object.fallback) : void 0;
        message.mask = object.mask ?? void 0;
        message.tintColor = object.tintColor !== void 0 && object.tintColor !== null ? ColorLike.fromPartial(object.tintColor) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/color.ts
var Color, serializeColorLike;
var init_color = __esm({
  "../api/src/api/color.ts"() {
    "use strict";
    init_ui();
    Color = /* @__PURE__ */ ((Color2) => {
      Color2["Blue"] = "blue";
      Color2["Green"] = "green";
      Color2["Magenta"] = "magenta";
      Color2["Orange"] = "orange";
      Color2["Purple"] = "purple";
      Color2["Red"] = "red";
      Color2["Yellow"] = "yellow";
      Color2["PrimaryText"] = "primary-text";
      Color2["SecondaryText"] = "secondary-text";
      return Color2;
    })(Color || {});
    serializeColorLike = (color) => {
      const colorLike = ColorLike.create();
      if (typeof color === "string") {
        colorLike.raw = color;
      } else {
        const dynamicColor = DynamicColor.create();
        dynamicColor.light = color.light;
        dynamicColor.dark = color.dark;
        if (color.adjustContrast !== void 0) {
          dynamicColor.adjustContrast = color.adjustContrast;
        }
        colorLike.dynamic = dynamicColor;
      }
      return colorLike;
    };
  }
});

// ../api/src/api/image.ts
var Image2, maskMap, serializeProtoImage;
var init_image = __esm({
  "../api/src/api/image.ts"() {
    "use strict";
    init_color();
    init_ui();
    ((Image6) => {
      let Mask;
      ((Mask2) => {
        Mask2["Circle"] = "circle";
        Mask2["RoundedRectangle"] = "roundedRectangle";
      })(Mask = Image6.Mask || (Image6.Mask = {}));
    })(Image2 || (Image2 = {}));
    maskMap = {
      ["circle" /* Circle */]: 1 /* Circle */,
      ["roundedRectangle" /* RoundedRectangle */]: 2 /* RoundedRectangle */
    };
    serializeProtoImage = (image) => {
      const serializeSource = (payload) => {
        if (typeof payload === "object") {
          const tmp = payload;
          return {
            themed: { light: tmp.light.toString(), dark: tmp.dark.toString() }
          };
        }
        return { raw: payload.toString() };
      };
      if (image instanceof URL || typeof image === "string") {
        return { source: { raw: image.toString() } };
      }
      const proto = Image.create();
      const img = image;
      if (img.source) {
        proto.source = serializeSource(img.source);
      }
      if (img.fallback) {
        proto.fallback = serializeSource(img.fallback);
      }
      if (img.mask) {
        proto.mask = maskMap[img.mask];
      }
      if (img.tintColor) {
        proto.tintColor = serializeColorLike(img.tintColor);
      }
      return proto;
    };
  }
});

// ../api/node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "../api/node_modules/react/cjs/react-jsx-runtime.production.js"(exports2) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    exports2.Fragment = REACT_FRAGMENT_TYPE;
    exports2.jsx = jsxProd;
    exports2.jsxs = jsxProd;
  }
});

// ../api/node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../api/node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
          var prototype = type.prototype;
          return describeNativeComponentFrame(
            type,
            !(!prototype || !prototype.isReactComponent)
          );
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return type = describeNativeComponentFrame(type.render, false), type;
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
              prototype = type._payload;
              type = type._init;
              try {
                return describeUnknownElementTypeFrameInDEV(type(prototype));
              } catch (x) {
              }
          }
        return "";
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement2(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children, type);
        } else {
          children = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
            children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
          console.error(
            "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
            isStaticChildren,
            children
          );
        }
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement2(type, children, self, source, getOwner(), maybeKey);
      }
      function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
          if (isArrayImpl(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement(node))
            node._store && (node._store.validated = 1);
          else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node))
            for (; !(node = i.next()).done; )
              isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
          ownerHasKeyUseWarning[parentType] = true;
          var childOwner = "";
          element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
          var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = function() {
            var stack = describeUnknownElementTypeFrameInDEV(element.type);
            prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
            return stack;
          };
          console.error(
            'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
            parentType,
            childOwner
          );
          ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
      }
      function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
      }
      var React6 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
      exports2.Fragment = REACT_FRAGMENT_TYPE;
      exports2.jsx = function(type, config, maybeKey, source, self) {
        return jsxDEVImpl(type, config, maybeKey, false, source, self);
      };
      exports2.jsxs = function(type, config, maybeKey, source, self) {
        return jsxDEVImpl(type, config, maybeKey, true, source, self);
      };
    })();
  }
});

// ../api/node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../api/node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_jsx_runtime_production();
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../api/src/api/components/tag.tsx
var import_jsx_runtime, TagListRoot, TagItem, TagList;
var init_tag = __esm({
  "../api/src/api/components/tag.tsx"() {
    "use strict";
    init_color();
    init_image();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    TagListRoot = ({ title, children }) => {
      const nativeProps = {
        title,
        children
      };
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tag-list", { ...nativeProps });
    };
    TagItem = ({ color, icon, ...props }) => {
      const nativeProps = {
        ...props,
        color: color ? serializeColorLike(color) : void 0,
        icon: icon ? serializeProtoImage(icon) : void 0
      };
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tag-item", { ...nativeProps });
    };
    TagList = Object.assign(TagListRoot, {
      Item: TagItem
    });
  }
});

// ../api/src/api/components/metadata.tsx
var import_jsx_runtime2, MetadataRoot, MetadataLabel, MetadataSeparator, MetadataLink, Metadata;
var init_metadata = __esm({
  "../api/src/api/components/metadata.tsx"() {
    "use strict";
    init_image();
    init_color();
    init_tag();
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    MetadataRoot = (props) => {
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("metadata", { ...props });
    };
    MetadataLabel = (props) => {
      const serializedIcon = props.icon ? serializeProtoImage(props.icon) : props.icon;
      let serializedText;
      if (props.text && typeof props.text === "object") {
        serializedText = {
          color: props.text.color ? serializeColorLike(props.text.color) : void 0,
          value: props.text.value
        };
      } else {
        serializedText = props.text;
      }
      const { text, ...restProps } = props;
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("metadata-label", { ...restProps, icon: serializedIcon, text: serializedText });
    };
    MetadataSeparator = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("metadata-separator", {});
    };
    MetadataLink = ({ title, target, text }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("metadata-link", { title, target, text });
    };
    Metadata = Object.assign(MetadataRoot, {
      Label: MetadataLabel,
      Separator: MetadataSeparator,
      TagList,
      Link: MetadataLink
    });
  }
});

// ../api/src/api/components/empty-view.tsx
var import_jsx_runtime3, EmptyView;
var init_empty_view = __esm({
  "../api/src/api/components/empty-view.tsx"() {
    "use strict";
    init_image();
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    EmptyView = ({
      actions,
      icon,
      ...props
    }) => {
      const serializedIcon = icon ? serializeProtoImage(icon) : icon;
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("empty-view", { ...props, icon: serializedIcon, children: actions });
    };
  }
});

// ../api/src/api/components/dropdown.tsx
var import_jsx_runtime4, DropdownRoot, Item, Section, Dropdown;
var init_dropdown = __esm({
  "../api/src/api/components/dropdown.tsx"() {
    "use strict";
    init_image();
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    DropdownRoot = ({ children, ...props }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("dropdown", { ...props, children });
    };
    Item = ({ title, value, icon }) => {
      const serializedIcon = icon ? serializeProtoImage(icon) : icon;
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("dropdown-item", { title, value, icon: serializedIcon });
    };
    Section = ({ title, children }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("dropdown-section", { title, children });
    };
    Dropdown = Object.assign(DropdownRoot, {
      Item,
      Section
    });
  }
});

// ../api/src/api/components/list.tsx
function serializeAccessory(accessory) {
  const icon = accessory.icon ? serializeProtoImage(accessory.icon) : void 0;
  const tag = typeof accessory === "object" && "tag" in accessory ? serializeTag(accessory.tag) : void 0;
  const text = typeof accessory === "object" && "text" in accessory ? serializeText(accessory.text) : void 0;
  return { icon, tooltip: accessory.tooltip, tag, text };
}
function serializeTag(tag) {
  if (tag == null) return tag;
  if (typeof tag !== "object") return tag;
  if ("color" in tag) {
    const color = serializeColorLike(tag.color);
    const value = "value" in tag ? tag.value : void 0;
    return { color, value };
  }
}
function serializeText(text) {
  if (text == null) return text;
  if (typeof text !== "object") return text;
  if ("color" in text) {
    const color = serializeColorLike(text.color);
    const value = "value" in text ? text.value : void 0;
    return { color, value };
  }
}
var import_react, import_node_crypto, import_jsx_runtime5, ListRoot, ListItem, ListItemDetail, ListSection, List;
var init_list = __esm({
  "../api/src/api/components/list.tsx"() {
    "use strict";
    import_react = __toESM(require_react());
    init_image();
    import_node_crypto = require("node:crypto");
    init_metadata();
    init_empty_view();
    init_color();
    init_dropdown();
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    ListRoot = ({
      searchBarAccessory,
      children,
      actions,
      ...props
    }) => {
      if (typeof props.enableFiltering === "boolean" && typeof props.filtering === "undefined") {
        props.filtering = props.enableFiltering;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("list", { ...props, children: [
        searchBarAccessory,
        children,
        actions
      ] });
    };
    ListItem = ({
      detail,
      actions,
      icon,
      accessories,
      ...props
    }) => {
      const id = (0, import_react.useRef)(props.id ?? (0, import_node_crypto.randomUUID)());
      let serializedIcon;
      if (icon && typeof icon === "object" && "value" in icon) {
        serializedIcon = {
          value: icon.value ? serializeProtoImage(icon.value) : void 0,
          tooltip: icon.tooltip
        };
      } else {
        serializedIcon = icon ? serializeProtoImage(icon) : void 0;
      }
      const serializedAccessories = accessories?.map(serializeAccessory) ?? void 0;
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
        "list-item",
        {
          ...props,
          icon: serializedIcon,
          accessories: serializedAccessories,
          id: id.current,
          children: [
            detail,
            actions
          ]
        }
      );
    };
    ListItemDetail = ({
      metadata,
      ...props
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("list-item-detail", { ...props, children: metadata });
    };
    ListSection = (props) => {
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("list-section", { ...props });
    };
    List = Object.assign(ListRoot, {
      Section: ListSection,
      EmptyView,
      Dropdown,
      Item: Object.assign(ListItem, {
        Detail: Object.assign(ListItemDetail, {
          Metadata
        })
      })
    });
  }
});

// ../api/src/api/components/grid.tsx
var import_react2, import_crypto, import_jsx_runtime6, GridInset, GridItemSize, aspectRatioMap, GridFit, GridRoot, GridItem, GridSection, Grid;
var init_grid = __esm({
  "../api/src/api/components/grid.tsx"() {
    "use strict";
    import_react2 = __toESM(require_react());
    init_image();
    import_crypto = require("crypto");
    init_empty_view();
    init_color();
    init_dropdown();
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    GridInset = /* @__PURE__ */ ((GridInset2) => {
      GridInset2["Zero"] = "zero";
      GridInset2["Small"] = "small";
      GridInset2["Medium"] = "medium";
      GridInset2["Large"] = "large";
      return GridInset2;
    })(GridInset || {});
    GridItemSize = /* @__PURE__ */ ((GridItemSize2) => {
      GridItemSize2["Small"] = "small";
      GridItemSize2["Medium"] = "medium";
      GridItemSize2["Large"] = "large";
      return GridItemSize2;
    })(GridItemSize || {});
    aspectRatioMap = {
      "1": 1,
      "3/2": 3 / 2,
      "2/3": 2 / 3,
      "4/3": 4 / 3,
      "3/4": 3 / 4,
      "16/9": 16 / 9,
      "9/16": 9 / 16,
      "21/9": 21 / 9,
      "9/21": 9 / 21,
      "32/9": 32 / 9,
      "9/32": 9 / 32
    };
    GridFit = /* @__PURE__ */ ((GridFit2) => {
      GridFit2["Contain"] = "contain";
      GridFit2["Fill"] = "fill";
      return GridFit2;
    })(GridFit || {});
    GridRoot = ({
      searchBarAccessory,
      children,
      actions,
      inset,
      itemSize,
      fit = "contain" /* Contain */,
      aspectRatio = "1",
      ...props
    }) => {
      if (typeof props.enableFiltering === "boolean" && typeof props.filtering === "undefined") {
        props.filtering = props.enableFiltering;
      }
      if (props.columns === void 0 && itemSize) {
        props.columns = {
          ["small" /* Small */]: 8,
          ["medium" /* Medium */]: 5,
          ["large" /* Large */]: 3
        }[itemSize];
      }
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
        "grid",
        {
          fit,
          inset,
          aspectRatio: aspectRatioMap[aspectRatio],
          ...props,
          children: [
            searchBarAccessory,
            children,
            actions
          ]
        }
      );
    };
    GridItem = ({
      detail,
      actions,
      content,
      accessory,
      ...props
    }) => {
      const id = (0, import_react2.useRef)(props.id ?? (0, import_crypto.randomUUID)());
      const innerContent = typeof content === "object" && "value" in content ? content.value : content;
      const tooltip = typeof content === "object" && "tooltip" in content ? content.tooltip : void 0;
      let serializedContent;
      if (innerContent && typeof innerContent === "object" && "color" in innerContent) {
        serializedContent = {
          color: serializeColorLike(innerContent.color)
        };
      } else {
        serializedContent = innerContent ? serializeProtoImage(innerContent) : void 0;
      }
      const serializedAccessory = accessory ? {
        icon: accessory.icon ? serializeProtoImage(accessory.icon) : accessory.icon,
        tooltip: accessory.tooltip
      } : void 0;
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
        "grid-item",
        {
          ...props,
          content: serializedContent,
          tooltip,
          accessory: serializedAccessory,
          id: id.current,
          children: [
            detail,
            actions
          ]
        }
      );
    };
    GridSection = ({
      fit,
      aspectRatio,
      inset,
      ...props
    }) => {
      const nativeProps = {
        fit,
        aspectRatio: aspectRatio ? aspectRatioMap[aspectRatio] : aspectRatio,
        inset,
        ...props
      };
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("grid-section", { ...nativeProps });
    };
    Grid = Object.assign(GridRoot, {
      Section: GridSection,
      EmptyView,
      Dropdown,
      Fit: GridFit,
      Inset: GridInset,
      ItemSize: GridItemSize,
      Item: Object.assign(GridItem, {})
    });
  }
});

// ../api/src/api/components/detail.tsx
var import_jsx_runtime7, DetailRoot, Detail;
var init_detail = __esm({
  "../api/src/api/components/detail.tsx"() {
    "use strict";
    init_metadata();
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    DetailRoot = ({
      metadata,
      actions,
      ...props
    }) => {
      const nativeProps = props;
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("detail", { ...nativeProps, children: [
        actions,
        metadata
      ] });
    };
    Detail = Object.assign(DetailRoot, {
      Metadata
    });
  }
});

// ../api/src/api/components/action-pannel.tsx
var import_node_crypto2, import_react3, import_jsx_runtime8, ActionPanelRoot, ActionPanelSection, ActionPannelSubmenu, ActionPanel;
var init_action_pannel = __esm({
  "../api/src/api/components/action-pannel.tsx"() {
    "use strict";
    import_node_crypto2 = require("node:crypto");
    import_react3 = __toESM(require_react());
    init_image();
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    ActionPanelRoot = (props) => {
      const stableIdRef = (0, import_react3.useRef)(void 0);
      if (!stableIdRef.current) {
        stableIdRef.current = (0, import_node_crypto2.randomUUID)();
      }
      const nativeProps = {
        ...props,
        stableId: stableIdRef.current
      };
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("action-panel", { ...nativeProps });
    };
    ActionPanelSection = (props) => {
      const nativeProps = {
        title: props.title
      };
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("action-panel-section", { ...nativeProps, children: props.children });
    };
    ActionPannelSubmenu = ({
      children,
      icon,
      ...props
    }) => {
      const stableIdRef = (0, import_react3.useRef)(void 0);
      if (!stableIdRef.current) {
        stableIdRef.current = (0, import_node_crypto2.randomUUID)();
      }
      const serializedIcon = icon ? serializeProtoImage(icon) : icon;
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        "action-panel-submenu",
        {
          ...props,
          icon: serializedIcon,
          stableId: stableIdRef.current,
          children
        }
      );
    };
    ActionPanel = Object.assign(ActionPanelRoot, {
      Section: ActionPanelSection,
      Submenu: ActionPannelSubmenu
    });
  }
});

// ../api/src/api/context/navigation-context.ts
var import_react4, ctx, navigation_context_default;
var init_navigation_context = __esm({
  "../api/src/api/context/navigation-context.ts"() {
    "use strict";
    import_react4 = __toESM(require_react());
    ctx = (0, import_react4.createContext)({
      pop: () => {
        throw new Error("not implemented");
      },
      push: () => {
        throw new Error("not implemented");
      }
    });
    navigation_context_default = ctx;
  }
});

// ../api/src/api/hooks/use-navigation.ts
var import_react5, useNavigation;
var init_use_navigation = __esm({
  "../api/src/api/hooks/use-navigation.ts"() {
    "use strict";
    import_react5 = __toESM(require_react());
    init_navigation_context();
    useNavigation = () => {
      const { push, pop } = (0, import_react5.useContext)(navigation_context_default);
      return { push, pop };
    };
  }
});

// ../api/src/api/hooks/index.ts
var init_hooks = __esm({
  "../api/src/api/hooks/index.ts"() {
    "use strict";
    init_use_navigation();
  }
});

// ../api/src/api/proto/application.ts
function createBaseOpenApplicationRequest() {
  return { target: "", appId: void 0 };
}
function createBaseRunInTerminalRequest() {
  return { cmdline: [], appId: void 0, workingDirectory: void 0, title: void 0, hold: false };
}
function createBaseListApplicationRequest() {
  return { target: void 0 };
}
function createBaseListApplicationResponse() {
  return { apps: [] };
}
function createBaseGetDefaultApplicationRequest() {
  return { target: "" };
}
function createBaseGetDefaultApplicationResponse() {
  return { app: void 0 };
}
function createBaseRequest2() {
  return { list: void 0, open: void 0, getDefault: void 0, runInTerminal: void 0 };
}
function createBaseResponse2() {
  return { list: void 0, open: void 0, getDefault: void 0, runInTerminal: void 0 };
}
function createBaseApplication() {
  return { id: "", name: "", icon: "", path: "" };
}
function isSet4(value) {
  return value !== null && value !== void 0;
}
var OpenApplicationRequest, RunInTerminalRequest, ListApplicationRequest, ListApplicationResponse, GetDefaultApplicationRequest, GetDefaultApplicationResponse, Request2, Response2, Application;
var init_application = __esm({
  "../api/src/api/proto/application.ts"() {
    "use strict";
    init_wire();
    init_common();
    OpenApplicationRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.target !== "") {
          writer.uint32(10).string(message.target);
        }
        if (message.appId !== void 0) {
          writer.uint32(18).string(message.appId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOpenApplicationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.target = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.appId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          target: isSet4(object.target) ? globalThis.String(object.target) : "",
          appId: isSet4(object.appId) ? globalThis.String(object.appId) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.target !== "") {
          obj.target = message.target;
        }
        if (message.appId !== void 0) {
          obj.appId = message.appId;
        }
        return obj;
      },
      create(base) {
        return OpenApplicationRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseOpenApplicationRequest();
        message.target = object.target ?? "";
        message.appId = object.appId ?? void 0;
        return message;
      }
    };
    RunInTerminalRequest = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.cmdline) {
          writer.uint32(10).string(v);
        }
        if (message.appId !== void 0) {
          writer.uint32(18).string(message.appId);
        }
        if (message.workingDirectory !== void 0) {
          writer.uint32(26).string(message.workingDirectory);
        }
        if (message.title !== void 0) {
          writer.uint32(34).string(message.title);
        }
        if (message.hold !== false) {
          writer.uint32(40).bool(message.hold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRunInTerminalRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.cmdline.push(reader.string());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.appId = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.workingDirectory = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.hold = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          cmdline: globalThis.Array.isArray(object?.cmdline) ? object.cmdline.map((e) => globalThis.String(e)) : [],
          appId: isSet4(object.appId) ? globalThis.String(object.appId) : void 0,
          workingDirectory: isSet4(object.workingDirectory) ? globalThis.String(object.workingDirectory) : void 0,
          title: isSet4(object.title) ? globalThis.String(object.title) : void 0,
          hold: isSet4(object.hold) ? globalThis.Boolean(object.hold) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.cmdline?.length) {
          obj.cmdline = message.cmdline;
        }
        if (message.appId !== void 0) {
          obj.appId = message.appId;
        }
        if (message.workingDirectory !== void 0) {
          obj.workingDirectory = message.workingDirectory;
        }
        if (message.title !== void 0) {
          obj.title = message.title;
        }
        if (message.hold !== false) {
          obj.hold = message.hold;
        }
        return obj;
      },
      create(base) {
        return RunInTerminalRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRunInTerminalRequest();
        message.cmdline = object.cmdline?.map((e) => e) || [];
        message.appId = object.appId ?? void 0;
        message.workingDirectory = object.workingDirectory ?? void 0;
        message.title = object.title ?? void 0;
        message.hold = object.hold ?? false;
        return message;
      }
    };
    ListApplicationRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.target !== void 0) {
          writer.uint32(10).string(message.target);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListApplicationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.target = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { target: isSet4(object.target) ? globalThis.String(object.target) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.target !== void 0) {
          obj.target = message.target;
        }
        return obj;
      },
      create(base) {
        return ListApplicationRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseListApplicationRequest();
        message.target = object.target ?? void 0;
        return message;
      }
    };
    ListApplicationResponse = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.apps) {
          Application.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListApplicationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.apps.push(Application.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => Application.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.apps?.length) {
          obj.apps = message.apps.map((e) => Application.toJSON(e));
        }
        return obj;
      },
      create(base) {
        return ListApplicationResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseListApplicationResponse();
        message.apps = object.apps?.map((e) => Application.fromPartial(e)) || [];
        return message;
      }
    };
    GetDefaultApplicationRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.target !== "") {
          writer.uint32(10).string(message.target);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetDefaultApplicationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.target = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { target: isSet4(object.target) ? globalThis.String(object.target) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.target !== "") {
          obj.target = message.target;
        }
        return obj;
      },
      create(base) {
        return GetDefaultApplicationRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetDefaultApplicationRequest();
        message.target = object.target ?? "";
        return message;
      }
    };
    GetDefaultApplicationResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.app !== void 0) {
          Application.encode(message.app, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetDefaultApplicationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.app = Application.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { app: isSet4(object.app) ? Application.fromJSON(object.app) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.app !== void 0) {
          obj.app = Application.toJSON(message.app);
        }
        return obj;
      },
      create(base) {
        return GetDefaultApplicationResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetDefaultApplicationResponse();
        message.app = object.app !== void 0 && object.app !== null ? Application.fromPartial(object.app) : void 0;
        return message;
      }
    };
    Request2 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.list !== void 0) {
          ListApplicationRequest.encode(message.list, writer.uint32(10).fork()).join();
        }
        if (message.open !== void 0) {
          OpenApplicationRequest.encode(message.open, writer.uint32(18).fork()).join();
        }
        if (message.getDefault !== void 0) {
          GetDefaultApplicationRequest.encode(message.getDefault, writer.uint32(26).fork()).join();
        }
        if (message.runInTerminal !== void 0) {
          RunInTerminalRequest.encode(message.runInTerminal, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.list = ListApplicationRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.open = OpenApplicationRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.getDefault = GetDefaultApplicationRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.runInTerminal = RunInTerminalRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          list: isSet4(object.list) ? ListApplicationRequest.fromJSON(object.list) : void 0,
          open: isSet4(object.open) ? OpenApplicationRequest.fromJSON(object.open) : void 0,
          getDefault: isSet4(object.getDefault) ? GetDefaultApplicationRequest.fromJSON(object.getDefault) : void 0,
          runInTerminal: isSet4(object.runInTerminal) ? RunInTerminalRequest.fromJSON(object.runInTerminal) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.list !== void 0) {
          obj.list = ListApplicationRequest.toJSON(message.list);
        }
        if (message.open !== void 0) {
          obj.open = OpenApplicationRequest.toJSON(message.open);
        }
        if (message.getDefault !== void 0) {
          obj.getDefault = GetDefaultApplicationRequest.toJSON(message.getDefault);
        }
        if (message.runInTerminal !== void 0) {
          obj.runInTerminal = RunInTerminalRequest.toJSON(message.runInTerminal);
        }
        return obj;
      },
      create(base) {
        return Request2.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest2();
        message.list = object.list !== void 0 && object.list !== null ? ListApplicationRequest.fromPartial(object.list) : void 0;
        message.open = object.open !== void 0 && object.open !== null ? OpenApplicationRequest.fromPartial(object.open) : void 0;
        message.getDefault = object.getDefault !== void 0 && object.getDefault !== null ? GetDefaultApplicationRequest.fromPartial(object.getDefault) : void 0;
        message.runInTerminal = object.runInTerminal !== void 0 && object.runInTerminal !== null ? RunInTerminalRequest.fromPartial(object.runInTerminal) : void 0;
        return message;
      }
    };
    Response2 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.list !== void 0) {
          ListApplicationResponse.encode(message.list, writer.uint32(10).fork()).join();
        }
        if (message.open !== void 0) {
          AckResponse.encode(message.open, writer.uint32(18).fork()).join();
        }
        if (message.getDefault !== void 0) {
          GetDefaultApplicationResponse.encode(message.getDefault, writer.uint32(26).fork()).join();
        }
        if (message.runInTerminal !== void 0) {
          AckResponse.encode(message.runInTerminal, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.list = ListApplicationResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.open = AckResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.getDefault = GetDefaultApplicationResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.runInTerminal = AckResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          list: isSet4(object.list) ? ListApplicationResponse.fromJSON(object.list) : void 0,
          open: isSet4(object.open) ? AckResponse.fromJSON(object.open) : void 0,
          getDefault: isSet4(object.getDefault) ? GetDefaultApplicationResponse.fromJSON(object.getDefault) : void 0,
          runInTerminal: isSet4(object.runInTerminal) ? AckResponse.fromJSON(object.runInTerminal) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.list !== void 0) {
          obj.list = ListApplicationResponse.toJSON(message.list);
        }
        if (message.open !== void 0) {
          obj.open = AckResponse.toJSON(message.open);
        }
        if (message.getDefault !== void 0) {
          obj.getDefault = GetDefaultApplicationResponse.toJSON(message.getDefault);
        }
        if (message.runInTerminal !== void 0) {
          obj.runInTerminal = AckResponse.toJSON(message.runInTerminal);
        }
        return obj;
      },
      create(base) {
        return Response2.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse2();
        message.list = object.list !== void 0 && object.list !== null ? ListApplicationResponse.fromPartial(object.list) : void 0;
        message.open = object.open !== void 0 && object.open !== null ? AckResponse.fromPartial(object.open) : void 0;
        message.getDefault = object.getDefault !== void 0 && object.getDefault !== null ? GetDefaultApplicationResponse.fromPartial(object.getDefault) : void 0;
        message.runInTerminal = object.runInTerminal !== void 0 && object.runInTerminal !== null ? AckResponse.fromPartial(object.runInTerminal) : void 0;
        return message;
      }
    };
    Application = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.icon !== "") {
          writer.uint32(26).string(message.icon);
        }
        if (message.path !== "") {
          writer.uint32(34).string(message.path);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApplication();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.icon = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.path = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet4(object.id) ? globalThis.String(object.id) : "",
          name: isSet4(object.name) ? globalThis.String(object.name) : "",
          icon: isSet4(object.icon) ? globalThis.String(object.icon) : "",
          path: isSet4(object.path) ? globalThis.String(object.path) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.name !== "") {
          obj.name = message.name;
        }
        if (message.icon !== "") {
          obj.icon = message.icon;
        }
        if (message.path !== "") {
          obj.path = message.path;
        }
        return obj;
      },
      create(base) {
        return Application.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseApplication();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.icon = object.icon ?? "";
        message.path = object.path ?? "";
        return message;
      }
    };
  }
});

// ../api/src/api/proto/clipboard.ts
function createBaseClipboardHtmlContent() {
  return { html: "", text: "" };
}
function createBaseClipboardPathContent() {
  return { path: "" };
}
function createBaseClipboardOptions() {
  return { concealed: false };
}
function createBaseClearRequest() {
  return {};
}
function createBaseClearResponse() {
  return {};
}
function createBaseReadContentRequest() {
  return {};
}
function createBaseReadContentResponse() {
  return { content: void 0 };
}
function createBaseCopyToClipboardRequest() {
  return { content: void 0, options: void 0 };
}
function createBasePasteToClipboardRequest() {
  return { content: void 0 };
}
function createBaseClipboardContent() {
  return { text: void 0, html: void 0, path: void 0 };
}
function createBaseClipboardReadContent() {
  return { text: "", file: void 0, html: void 0 };
}
function createBaseCopyToClipboardResponse() {
  return {};
}
function createBasePasteToClipboardResponse() {
  return {};
}
function createBaseRequest3() {
  return { copy: void 0, paste: void 0, readContent: void 0, clear: void 0 };
}
function createBaseResponse3() {
  return { copy: void 0, paste: void 0, readContent: void 0, clear: void 0 };
}
function isSet5(value) {
  return value !== null && value !== void 0;
}
var ClipboardHtmlContent, ClipboardPathContent, ClipboardOptions, ClearRequest, ClearResponse, ReadContentRequest, ReadContentResponse, CopyToClipboardRequest, PasteToClipboardRequest, ClipboardContent, ClipboardReadContent, CopyToClipboardResponse, PasteToClipboardResponse, Request3, Response3;
var init_clipboard = __esm({
  "../api/src/api/proto/clipboard.ts"() {
    "use strict";
    init_wire();
    ClipboardHtmlContent = {
      encode(message, writer = new BinaryWriter()) {
        if (message.html !== "") {
          writer.uint32(10).string(message.html);
        }
        if (message.text !== "") {
          writer.uint32(18).string(message.text);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClipboardHtmlContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.html = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.text = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          html: isSet5(object.html) ? globalThis.String(object.html) : "",
          text: isSet5(object.text) ? globalThis.String(object.text) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.html !== "") {
          obj.html = message.html;
        }
        if (message.text !== "") {
          obj.text = message.text;
        }
        return obj;
      },
      create(base) {
        return ClipboardHtmlContent.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseClipboardHtmlContent();
        message.html = object.html ?? "";
        message.text = object.text ?? "";
        return message;
      }
    };
    ClipboardPathContent = {
      encode(message, writer = new BinaryWriter()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClipboardPathContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.path = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { path: isSet5(object.path) ? globalThis.String(object.path) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.path !== "") {
          obj.path = message.path;
        }
        return obj;
      },
      create(base) {
        return ClipboardPathContent.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseClipboardPathContent();
        message.path = object.path ?? "";
        return message;
      }
    };
    ClipboardOptions = {
      encode(message, writer = new BinaryWriter()) {
        if (message.concealed !== false) {
          writer.uint32(8).bool(message.concealed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClipboardOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.concealed = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { concealed: isSet5(object.concealed) ? globalThis.Boolean(object.concealed) : false };
      },
      toJSON(message) {
        const obj = {};
        if (message.concealed !== false) {
          obj.concealed = message.concealed;
        }
        return obj;
      },
      create(base) {
        return ClipboardOptions.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseClipboardOptions();
        message.concealed = object.concealed ?? false;
        return message;
      }
    };
    ClearRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClearRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ClearRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseClearRequest();
        return message;
      }
    };
    ClearResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClearResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ClearResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseClearResponse();
        return message;
      }
    };
    ReadContentRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseReadContentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ReadContentRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseReadContentRequest();
        return message;
      }
    };
    ReadContentResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.content !== void 0) {
          ClipboardReadContent.encode(message.content, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseReadContentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.content = ClipboardReadContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { content: isSet5(object.content) ? ClipboardReadContent.fromJSON(object.content) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.content !== void 0) {
          obj.content = ClipboardReadContent.toJSON(message.content);
        }
        return obj;
      },
      create(base) {
        return ReadContentResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseReadContentResponse();
        message.content = object.content !== void 0 && object.content !== null ? ClipboardReadContent.fromPartial(object.content) : void 0;
        return message;
      }
    };
    CopyToClipboardRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.content !== void 0) {
          ClipboardContent.encode(message.content, writer.uint32(10).fork()).join();
        }
        if (message.options !== void 0) {
          ClipboardOptions.encode(message.options, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCopyToClipboardRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.content = ClipboardContent.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.options = ClipboardOptions.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          content: isSet5(object.content) ? ClipboardContent.fromJSON(object.content) : void 0,
          options: isSet5(object.options) ? ClipboardOptions.fromJSON(object.options) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.content !== void 0) {
          obj.content = ClipboardContent.toJSON(message.content);
        }
        if (message.options !== void 0) {
          obj.options = ClipboardOptions.toJSON(message.options);
        }
        return obj;
      },
      create(base) {
        return CopyToClipboardRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseCopyToClipboardRequest();
        message.content = object.content !== void 0 && object.content !== null ? ClipboardContent.fromPartial(object.content) : void 0;
        message.options = object.options !== void 0 && object.options !== null ? ClipboardOptions.fromPartial(object.options) : void 0;
        return message;
      }
    };
    PasteToClipboardRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.content !== void 0) {
          ClipboardContent.encode(message.content, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePasteToClipboardRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.content = ClipboardContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { content: isSet5(object.content) ? ClipboardContent.fromJSON(object.content) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.content !== void 0) {
          obj.content = ClipboardContent.toJSON(message.content);
        }
        return obj;
      },
      create(base) {
        return PasteToClipboardRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBasePasteToClipboardRequest();
        message.content = object.content !== void 0 && object.content !== null ? ClipboardContent.fromPartial(object.content) : void 0;
        return message;
      }
    };
    ClipboardContent = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== void 0) {
          writer.uint32(10).string(message.text);
        }
        if (message.html !== void 0) {
          ClipboardHtmlContent.encode(message.html, writer.uint32(18).fork()).join();
        }
        if (message.path !== void 0) {
          ClipboardPathContent.encode(message.path, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClipboardContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.html = ClipboardHtmlContent.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.path = ClipboardPathContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          text: isSet5(object.text) ? globalThis.String(object.text) : void 0,
          html: isSet5(object.html) ? ClipboardHtmlContent.fromJSON(object.html) : void 0,
          path: isSet5(object.path) ? ClipboardPathContent.fromJSON(object.path) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== void 0) {
          obj.text = message.text;
        }
        if (message.html !== void 0) {
          obj.html = ClipboardHtmlContent.toJSON(message.html);
        }
        if (message.path !== void 0) {
          obj.path = ClipboardPathContent.toJSON(message.path);
        }
        return obj;
      },
      create(base) {
        return ClipboardContent.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseClipboardContent();
        message.text = object.text ?? void 0;
        message.html = object.html !== void 0 && object.html !== null ? ClipboardHtmlContent.fromPartial(object.html) : void 0;
        message.path = object.path !== void 0 && object.path !== null ? ClipboardPathContent.fromPartial(object.path) : void 0;
        return message;
      }
    };
    ClipboardReadContent = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
          writer.uint32(10).string(message.text);
        }
        if (message.file !== void 0) {
          writer.uint32(18).string(message.file);
        }
        if (message.html !== void 0) {
          writer.uint32(26).string(message.html);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClipboardReadContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.file = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.html = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          text: isSet5(object.text) ? globalThis.String(object.text) : "",
          file: isSet5(object.file) ? globalThis.String(object.file) : void 0,
          html: isSet5(object.html) ? globalThis.String(object.html) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== "") {
          obj.text = message.text;
        }
        if (message.file !== void 0) {
          obj.file = message.file;
        }
        if (message.html !== void 0) {
          obj.html = message.html;
        }
        return obj;
      },
      create(base) {
        return ClipboardReadContent.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseClipboardReadContent();
        message.text = object.text ?? "";
        message.file = object.file ?? void 0;
        message.html = object.html ?? void 0;
        return message;
      }
    };
    CopyToClipboardResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCopyToClipboardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return CopyToClipboardResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseCopyToClipboardResponse();
        return message;
      }
    };
    PasteToClipboardResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePasteToClipboardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return PasteToClipboardResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBasePasteToClipboardResponse();
        return message;
      }
    };
    Request3 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.copy !== void 0) {
          CopyToClipboardRequest.encode(message.copy, writer.uint32(10).fork()).join();
        }
        if (message.paste !== void 0) {
          PasteToClipboardRequest.encode(message.paste, writer.uint32(18).fork()).join();
        }
        if (message.readContent !== void 0) {
          ReadContentRequest.encode(message.readContent, writer.uint32(26).fork()).join();
        }
        if (message.clear !== void 0) {
          ClearRequest.encode(message.clear, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.copy = CopyToClipboardRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.paste = PasteToClipboardRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.readContent = ReadContentRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.clear = ClearRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          copy: isSet5(object.copy) ? CopyToClipboardRequest.fromJSON(object.copy) : void 0,
          paste: isSet5(object.paste) ? PasteToClipboardRequest.fromJSON(object.paste) : void 0,
          readContent: isSet5(object.readContent) ? ReadContentRequest.fromJSON(object.readContent) : void 0,
          clear: isSet5(object.clear) ? ClearRequest.fromJSON(object.clear) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.copy !== void 0) {
          obj.copy = CopyToClipboardRequest.toJSON(message.copy);
        }
        if (message.paste !== void 0) {
          obj.paste = PasteToClipboardRequest.toJSON(message.paste);
        }
        if (message.readContent !== void 0) {
          obj.readContent = ReadContentRequest.toJSON(message.readContent);
        }
        if (message.clear !== void 0) {
          obj.clear = ClearRequest.toJSON(message.clear);
        }
        return obj;
      },
      create(base) {
        return Request3.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest3();
        message.copy = object.copy !== void 0 && object.copy !== null ? CopyToClipboardRequest.fromPartial(object.copy) : void 0;
        message.paste = object.paste !== void 0 && object.paste !== null ? PasteToClipboardRequest.fromPartial(object.paste) : void 0;
        message.readContent = object.readContent !== void 0 && object.readContent !== null ? ReadContentRequest.fromPartial(object.readContent) : void 0;
        message.clear = object.clear !== void 0 && object.clear !== null ? ClearRequest.fromPartial(object.clear) : void 0;
        return message;
      }
    };
    Response3 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.copy !== void 0) {
          CopyToClipboardResponse.encode(message.copy, writer.uint32(10).fork()).join();
        }
        if (message.paste !== void 0) {
          PasteToClipboardResponse.encode(message.paste, writer.uint32(18).fork()).join();
        }
        if (message.readContent !== void 0) {
          ReadContentResponse.encode(message.readContent, writer.uint32(26).fork()).join();
        }
        if (message.clear !== void 0) {
          ClearResponse.encode(message.clear, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse3();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.copy = CopyToClipboardResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.paste = PasteToClipboardResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.readContent = ReadContentResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.clear = ClearResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          copy: isSet5(object.copy) ? CopyToClipboardResponse.fromJSON(object.copy) : void 0,
          paste: isSet5(object.paste) ? PasteToClipboardResponse.fromJSON(object.paste) : void 0,
          readContent: isSet5(object.readContent) ? ReadContentResponse.fromJSON(object.readContent) : void 0,
          clear: isSet5(object.clear) ? ClearResponse.fromJSON(object.clear) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.copy !== void 0) {
          obj.copy = CopyToClipboardResponse.toJSON(message.copy);
        }
        if (message.paste !== void 0) {
          obj.paste = PasteToClipboardResponse.toJSON(message.paste);
        }
        if (message.readContent !== void 0) {
          obj.readContent = ReadContentResponse.toJSON(message.readContent);
        }
        if (message.clear !== void 0) {
          obj.clear = ClearResponse.toJSON(message.clear);
        }
        return obj;
      },
      create(base) {
        return Response3.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse3();
        message.copy = object.copy !== void 0 && object.copy !== null ? CopyToClipboardResponse.fromPartial(object.copy) : void 0;
        message.paste = object.paste !== void 0 && object.paste !== null ? PasteToClipboardResponse.fromPartial(object.paste) : void 0;
        message.readContent = object.readContent !== void 0 && object.readContent !== null ? ReadContentResponse.fromPartial(object.readContent) : void 0;
        message.clear = object.clear !== void 0 && object.clear !== null ? ClearResponse.fromPartial(object.clear) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/command.ts
function createBaseUpdateCommandMetadataRequest() {
  return { subtitle: void 0 };
}
function createBaseRequest4() {
  return { updateCommandMetadata: void 0 };
}
function createBaseResponse4() {
  return { updateCommandMetadata: void 0 };
}
function isSet6(value) {
  return value !== null && value !== void 0;
}
var UpdateCommandMetadataRequest, Request4, Response4;
var init_command = __esm({
  "../api/src/api/proto/command.ts"() {
    "use strict";
    init_wire();
    init_common();
    UpdateCommandMetadataRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.subtitle !== void 0) {
          writer.uint32(10).string(message.subtitle);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpdateCommandMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.subtitle = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { subtitle: isSet6(object.subtitle) ? globalThis.String(object.subtitle) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.subtitle !== void 0) {
          obj.subtitle = message.subtitle;
        }
        return obj;
      },
      create(base) {
        return UpdateCommandMetadataRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseUpdateCommandMetadataRequest();
        message.subtitle = object.subtitle ?? void 0;
        return message;
      }
    };
    Request4 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.updateCommandMetadata !== void 0) {
          UpdateCommandMetadataRequest.encode(message.updateCommandMetadata, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.updateCommandMetadata = UpdateCommandMetadataRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          updateCommandMetadata: isSet6(object.updateCommandMetadata) ? UpdateCommandMetadataRequest.fromJSON(object.updateCommandMetadata) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.updateCommandMetadata !== void 0) {
          obj.updateCommandMetadata = UpdateCommandMetadataRequest.toJSON(message.updateCommandMetadata);
        }
        return obj;
      },
      create(base) {
        return Request4.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest4();
        message.updateCommandMetadata = object.updateCommandMetadata !== void 0 && object.updateCommandMetadata !== null ? UpdateCommandMetadataRequest.fromPartial(object.updateCommandMetadata) : void 0;
        return message;
      }
    };
    Response4 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.updateCommandMetadata !== void 0) {
          AckResponse.encode(message.updateCommandMetadata, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse4();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.updateCommandMetadata = AckResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          updateCommandMetadata: isSet6(object.updateCommandMetadata) ? AckResponse.fromJSON(object.updateCommandMetadata) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.updateCommandMetadata !== void 0) {
          obj.updateCommandMetadata = AckResponse.toJSON(message.updateCommandMetadata);
        }
        return obj;
      },
      create(base) {
        return Response4.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse4();
        message.updateCommandMetadata = object.updateCommandMetadata !== void 0 && object.updateCommandMetadata !== null ? AckResponse.fromPartial(object.updateCommandMetadata) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/file-search.ts
function createBaseSearchRequest() {
  return { query: "" };
}
function createBaseFileInfo() {
  return { path: "", mimeType: "" };
}
function createBaseSearchResponse() {
  return { files: [] };
}
function createBaseRequest5() {
  return { search: void 0 };
}
function createBaseResponse5() {
  return { search: void 0 };
}
function isSet7(value) {
  return value !== null && value !== void 0;
}
var SearchRequest, FileInfo, SearchResponse, Request5, Response5;
var init_file_search = __esm({
  "../api/src/api/proto/file-search.ts"() {
    "use strict";
    init_wire();
    SearchRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.query !== "") {
          writer.uint32(10).string(message.query);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.query = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { query: isSet7(object.query) ? globalThis.String(object.query) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.query !== "") {
          obj.query = message.query;
        }
        return obj;
      },
      create(base) {
        return SearchRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSearchRequest();
        message.query = object.query ?? "";
        return message;
      }
    };
    FileInfo = {
      encode(message, writer = new BinaryWriter()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.mimeType !== "") {
          writer.uint32(18).string(message.mimeType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFileInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.path = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.mimeType = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          path: isSet7(object.path) ? globalThis.String(object.path) : "",
          mimeType: isSet7(object.mimeType) ? globalThis.String(object.mimeType) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.path !== "") {
          obj.path = message.path;
        }
        if (message.mimeType !== "") {
          obj.mimeType = message.mimeType;
        }
        return obj;
      },
      create(base) {
        return FileInfo.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseFileInfo();
        message.path = object.path ?? "";
        message.mimeType = object.mimeType ?? "";
        return message;
      }
    };
    SearchResponse = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.files) {
          FileInfo.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.files.push(FileInfo.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => FileInfo.fromJSON(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.files?.length) {
          obj.files = message.files.map((e) => FileInfo.toJSON(e));
        }
        return obj;
      },
      create(base) {
        return SearchResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSearchResponse();
        message.files = object.files?.map((e) => FileInfo.fromPartial(e)) || [];
        return message;
      }
    };
    Request5 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.search !== void 0) {
          SearchRequest.encode(message.search, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.search = SearchRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { search: isSet7(object.search) ? SearchRequest.fromJSON(object.search) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.search !== void 0) {
          obj.search = SearchRequest.toJSON(message.search);
        }
        return obj;
      },
      create(base) {
        return Request5.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest5();
        message.search = object.search !== void 0 && object.search !== null ? SearchRequest.fromPartial(object.search) : void 0;
        return message;
      }
    };
    Response5 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.search !== void 0) {
          SearchResponse.encode(message.search, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse5();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.search = SearchResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { search: isSet7(object.search) ? SearchResponse.fromJSON(object.search) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.search !== void 0) {
          obj.search = SearchResponse.toJSON(message.search);
        }
        return obj;
      },
      create(base) {
        return Response5.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse5();
        message.search = object.search !== void 0 && object.search !== null ? SearchResponse.fromPartial(object.search) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/manager.ts
function commandModeFromJSON(object) {
  switch (object) {
    case 0:
    case "View":
      return 0 /* View */;
    case 1:
    case "NoView":
      return 1 /* NoView */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function commandModeToJSON(object) {
  switch (object) {
    case 0 /* View */:
      return "View";
    case 1 /* NoView */:
      return "NoView";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
var init_manager = __esm({
  "../api/src/api/proto/manager.ts"() {
    "use strict";
    init_common();
    init_struct();
  }
});

// ../api/src/api/proto/oauth.ts
function createBasePKCEClientOptions() {
  return { id: void 0, name: "", description: "", icon: void 0 };
}
function createBaseAuthorizeRequest() {
  return { client: void 0, url: "" };
}
function createBaseTokenSet() {
  return {
    accessToken: "",
    refreshToken: void 0,
    idToken: void 0,
    expiresIn: void 0,
    scope: void 0,
    updatedAt: 0
  };
}
function createBaseGetTokensRequest() {
  return { providerId: void 0 };
}
function createBaseGetTokensResponse() {
  return { tokenSet: void 0 };
}
function createBaseSetTokensRequest() {
  return {
    providerId: void 0,
    accessToken: "",
    refreshToken: void 0,
    idToken: void 0,
    expiresIn: void 0,
    scope: void 0
  };
}
function createBaseSetTokensResponse() {
  return {};
}
function createBaseRemoveTokensRequest() {
  return { providerId: void 0 };
}
function createBaseRemoveTokensResponse() {
  return {};
}
function createBaseAuthorizeResponse() {
  return { code: "" };
}
function createBaseRequest6() {
  return { authorize: void 0, getTokens: void 0, setTokens: void 0, removeTokens: void 0 };
}
function createBaseResponse6() {
  return { authorize: void 0, getTokens: void 0, setTokens: void 0, removeTokens: void 0 };
}
function longToNumber(int64) {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}
function isSet8(value) {
  return value !== null && value !== void 0;
}
var PKCEClientOptions, AuthorizeRequest, TokenSet, GetTokensRequest, GetTokensResponse, SetTokensRequest, SetTokensResponse, RemoveTokensRequest, RemoveTokensResponse, AuthorizeResponse, Request6, Response6;
var init_oauth = __esm({
  "../api/src/api/proto/oauth.ts"() {
    "use strict";
    init_wire();
    init_ui();
    PKCEClientOptions = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== void 0) {
          writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
          writer.uint32(26).string(message.description);
        }
        if (message.icon !== void 0) {
          Image.encode(message.icon, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePKCEClientOptions();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.description = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.icon = Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet8(object.id) ? globalThis.String(object.id) : void 0,
          name: isSet8(object.name) ? globalThis.String(object.name) : "",
          description: isSet8(object.description) ? globalThis.String(object.description) : "",
          icon: isSet8(object.icon) ? Image.fromJSON(object.icon) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== void 0) {
          obj.id = message.id;
        }
        if (message.name !== "") {
          obj.name = message.name;
        }
        if (message.description !== "") {
          obj.description = message.description;
        }
        if (message.icon !== void 0) {
          obj.icon = Image.toJSON(message.icon);
        }
        return obj;
      },
      create(base) {
        return PKCEClientOptions.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBasePKCEClientOptions();
        message.id = object.id ?? void 0;
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.icon = object.icon !== void 0 && object.icon !== null ? Image.fromPartial(object.icon) : void 0;
        return message;
      }
    };
    AuthorizeRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.client !== void 0) {
          PKCEClientOptions.encode(message.client, writer.uint32(10).fork()).join();
        }
        if (message.url !== "") {
          writer.uint32(18).string(message.url);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthorizeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.client = PKCEClientOptions.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.url = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          client: isSet8(object.client) ? PKCEClientOptions.fromJSON(object.client) : void 0,
          url: isSet8(object.url) ? globalThis.String(object.url) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.client !== void 0) {
          obj.client = PKCEClientOptions.toJSON(message.client);
        }
        if (message.url !== "") {
          obj.url = message.url;
        }
        return obj;
      },
      create(base) {
        return AuthorizeRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseAuthorizeRequest();
        message.client = object.client !== void 0 && object.client !== null ? PKCEClientOptions.fromPartial(object.client) : void 0;
        message.url = object.url ?? "";
        return message;
      }
    };
    TokenSet = {
      encode(message, writer = new BinaryWriter()) {
        if (message.accessToken !== "") {
          writer.uint32(10).string(message.accessToken);
        }
        if (message.refreshToken !== void 0) {
          writer.uint32(18).string(message.refreshToken);
        }
        if (message.idToken !== void 0) {
          writer.uint32(26).string(message.idToken);
        }
        if (message.expiresIn !== void 0) {
          writer.uint32(32).uint32(message.expiresIn);
        }
        if (message.scope !== void 0) {
          writer.uint32(42).string(message.scope);
        }
        if (message.updatedAt !== 0) {
          writer.uint32(48).uint64(message.updatedAt);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTokenSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.accessToken = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.refreshToken = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.idToken = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.expiresIn = reader.uint32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.scope = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.updatedAt = longToNumber(reader.uint64());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          accessToken: isSet8(object.accessToken) ? globalThis.String(object.accessToken) : "",
          refreshToken: isSet8(object.refreshToken) ? globalThis.String(object.refreshToken) : void 0,
          idToken: isSet8(object.idToken) ? globalThis.String(object.idToken) : void 0,
          expiresIn: isSet8(object.expiresIn) ? globalThis.Number(object.expiresIn) : void 0,
          scope: isSet8(object.scope) ? globalThis.String(object.scope) : void 0,
          updatedAt: isSet8(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.accessToken !== "") {
          obj.accessToken = message.accessToken;
        }
        if (message.refreshToken !== void 0) {
          obj.refreshToken = message.refreshToken;
        }
        if (message.idToken !== void 0) {
          obj.idToken = message.idToken;
        }
        if (message.expiresIn !== void 0) {
          obj.expiresIn = Math.round(message.expiresIn);
        }
        if (message.scope !== void 0) {
          obj.scope = message.scope;
        }
        if (message.updatedAt !== 0) {
          obj.updatedAt = Math.round(message.updatedAt);
        }
        return obj;
      },
      create(base) {
        return TokenSet.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseTokenSet();
        message.accessToken = object.accessToken ?? "";
        message.refreshToken = object.refreshToken ?? void 0;
        message.idToken = object.idToken ?? void 0;
        message.expiresIn = object.expiresIn ?? void 0;
        message.scope = object.scope ?? void 0;
        message.updatedAt = object.updatedAt ?? 0;
        return message;
      }
    };
    GetTokensRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.providerId !== void 0) {
          writer.uint32(10).string(message.providerId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTokensRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.providerId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { providerId: isSet8(object.providerId) ? globalThis.String(object.providerId) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.providerId !== void 0) {
          obj.providerId = message.providerId;
        }
        return obj;
      },
      create(base) {
        return GetTokensRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetTokensRequest();
        message.providerId = object.providerId ?? void 0;
        return message;
      }
    };
    GetTokensResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.tokenSet !== void 0) {
          TokenSet.encode(message.tokenSet, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTokensResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.tokenSet = TokenSet.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { tokenSet: isSet8(object.tokenSet) ? TokenSet.fromJSON(object.tokenSet) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.tokenSet !== void 0) {
          obj.tokenSet = TokenSet.toJSON(message.tokenSet);
        }
        return obj;
      },
      create(base) {
        return GetTokensResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetTokensResponse();
        message.tokenSet = object.tokenSet !== void 0 && object.tokenSet !== null ? TokenSet.fromPartial(object.tokenSet) : void 0;
        return message;
      }
    };
    SetTokensRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.providerId !== void 0) {
          writer.uint32(10).string(message.providerId);
        }
        if (message.accessToken !== "") {
          writer.uint32(18).string(message.accessToken);
        }
        if (message.refreshToken !== void 0) {
          writer.uint32(26).string(message.refreshToken);
        }
        if (message.idToken !== void 0) {
          writer.uint32(34).string(message.idToken);
        }
        if (message.expiresIn !== void 0) {
          writer.uint32(40).uint32(message.expiresIn);
        }
        if (message.scope !== void 0) {
          writer.uint32(50).string(message.scope);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetTokensRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.providerId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.accessToken = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.refreshToken = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.idToken = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.expiresIn = reader.uint32();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.scope = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          providerId: isSet8(object.providerId) ? globalThis.String(object.providerId) : void 0,
          accessToken: isSet8(object.accessToken) ? globalThis.String(object.accessToken) : "",
          refreshToken: isSet8(object.refreshToken) ? globalThis.String(object.refreshToken) : void 0,
          idToken: isSet8(object.idToken) ? globalThis.String(object.idToken) : void 0,
          expiresIn: isSet8(object.expiresIn) ? globalThis.Number(object.expiresIn) : void 0,
          scope: isSet8(object.scope) ? globalThis.String(object.scope) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.providerId !== void 0) {
          obj.providerId = message.providerId;
        }
        if (message.accessToken !== "") {
          obj.accessToken = message.accessToken;
        }
        if (message.refreshToken !== void 0) {
          obj.refreshToken = message.refreshToken;
        }
        if (message.idToken !== void 0) {
          obj.idToken = message.idToken;
        }
        if (message.expiresIn !== void 0) {
          obj.expiresIn = Math.round(message.expiresIn);
        }
        if (message.scope !== void 0) {
          obj.scope = message.scope;
        }
        return obj;
      },
      create(base) {
        return SetTokensRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSetTokensRequest();
        message.providerId = object.providerId ?? void 0;
        message.accessToken = object.accessToken ?? "";
        message.refreshToken = object.refreshToken ?? void 0;
        message.idToken = object.idToken ?? void 0;
        message.expiresIn = object.expiresIn ?? void 0;
        message.scope = object.scope ?? void 0;
        return message;
      }
    };
    SetTokensResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetTokensResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return SetTokensResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseSetTokensResponse();
        return message;
      }
    };
    RemoveTokensRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.providerId !== void 0) {
          writer.uint32(10).string(message.providerId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRemoveTokensRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.providerId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { providerId: isSet8(object.providerId) ? globalThis.String(object.providerId) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.providerId !== void 0) {
          obj.providerId = message.providerId;
        }
        return obj;
      },
      create(base) {
        return RemoveTokensRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRemoveTokensRequest();
        message.providerId = object.providerId ?? void 0;
        return message;
      }
    };
    RemoveTokensResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRemoveTokensResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return RemoveTokensResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseRemoveTokensResponse();
        return message;
      }
    };
    AuthorizeResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.code !== "") {
          writer.uint32(10).string(message.code);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthorizeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.code = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { code: isSet8(object.code) ? globalThis.String(object.code) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.code !== "") {
          obj.code = message.code;
        }
        return obj;
      },
      create(base) {
        return AuthorizeResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseAuthorizeResponse();
        message.code = object.code ?? "";
        return message;
      }
    };
    Request6 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.authorize !== void 0) {
          AuthorizeRequest.encode(message.authorize, writer.uint32(10).fork()).join();
        }
        if (message.getTokens !== void 0) {
          GetTokensRequest.encode(message.getTokens, writer.uint32(18).fork()).join();
        }
        if (message.setTokens !== void 0) {
          SetTokensRequest.encode(message.setTokens, writer.uint32(26).fork()).join();
        }
        if (message.removeTokens !== void 0) {
          RemoveTokensRequest.encode(message.removeTokens, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest6();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.authorize = AuthorizeRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.getTokens = GetTokensRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.setTokens = SetTokensRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.removeTokens = RemoveTokensRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          authorize: isSet8(object.authorize) ? AuthorizeRequest.fromJSON(object.authorize) : void 0,
          getTokens: isSet8(object.getTokens) ? GetTokensRequest.fromJSON(object.getTokens) : void 0,
          setTokens: isSet8(object.setTokens) ? SetTokensRequest.fromJSON(object.setTokens) : void 0,
          removeTokens: isSet8(object.removeTokens) ? RemoveTokensRequest.fromJSON(object.removeTokens) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.authorize !== void 0) {
          obj.authorize = AuthorizeRequest.toJSON(message.authorize);
        }
        if (message.getTokens !== void 0) {
          obj.getTokens = GetTokensRequest.toJSON(message.getTokens);
        }
        if (message.setTokens !== void 0) {
          obj.setTokens = SetTokensRequest.toJSON(message.setTokens);
        }
        if (message.removeTokens !== void 0) {
          obj.removeTokens = RemoveTokensRequest.toJSON(message.removeTokens);
        }
        return obj;
      },
      create(base) {
        return Request6.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest6();
        message.authorize = object.authorize !== void 0 && object.authorize !== null ? AuthorizeRequest.fromPartial(object.authorize) : void 0;
        message.getTokens = object.getTokens !== void 0 && object.getTokens !== null ? GetTokensRequest.fromPartial(object.getTokens) : void 0;
        message.setTokens = object.setTokens !== void 0 && object.setTokens !== null ? SetTokensRequest.fromPartial(object.setTokens) : void 0;
        message.removeTokens = object.removeTokens !== void 0 && object.removeTokens !== null ? RemoveTokensRequest.fromPartial(object.removeTokens) : void 0;
        return message;
      }
    };
    Response6 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.authorize !== void 0) {
          AuthorizeResponse.encode(message.authorize, writer.uint32(10).fork()).join();
        }
        if (message.getTokens !== void 0) {
          GetTokensResponse.encode(message.getTokens, writer.uint32(18).fork()).join();
        }
        if (message.setTokens !== void 0) {
          SetTokensResponse.encode(message.setTokens, writer.uint32(26).fork()).join();
        }
        if (message.removeTokens !== void 0) {
          RemoveTokensResponse.encode(message.removeTokens, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse6();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.authorize = AuthorizeResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.getTokens = GetTokensResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.setTokens = SetTokensResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.removeTokens = RemoveTokensResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          authorize: isSet8(object.authorize) ? AuthorizeResponse.fromJSON(object.authorize) : void 0,
          getTokens: isSet8(object.getTokens) ? GetTokensResponse.fromJSON(object.getTokens) : void 0,
          setTokens: isSet8(object.setTokens) ? SetTokensResponse.fromJSON(object.setTokens) : void 0,
          removeTokens: isSet8(object.removeTokens) ? RemoveTokensResponse.fromJSON(object.removeTokens) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.authorize !== void 0) {
          obj.authorize = AuthorizeResponse.toJSON(message.authorize);
        }
        if (message.getTokens !== void 0) {
          obj.getTokens = GetTokensResponse.toJSON(message.getTokens);
        }
        if (message.setTokens !== void 0) {
          obj.setTokens = SetTokensResponse.toJSON(message.setTokens);
        }
        if (message.removeTokens !== void 0) {
          obj.removeTokens = RemoveTokensResponse.toJSON(message.removeTokens);
        }
        return obj;
      },
      create(base) {
        return Response6.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse6();
        message.authorize = object.authorize !== void 0 && object.authorize !== null ? AuthorizeResponse.fromPartial(object.authorize) : void 0;
        message.getTokens = object.getTokens !== void 0 && object.getTokens !== null ? GetTokensResponse.fromPartial(object.getTokens) : void 0;
        message.setTokens = object.setTokens !== void 0 && object.setTokens !== null ? SetTokensResponse.fromPartial(object.setTokens) : void 0;
        message.removeTokens = object.removeTokens !== void 0 && object.removeTokens !== null ? RemoveTokensResponse.fromPartial(object.removeTokens) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/storage.ts
function createBaseClearRequest2() {
  return {};
}
function createBaseGetRequest() {
  return { key: "" };
}
function createBaseGetResponse() {
  return { value: void 0 };
}
function createBaseSetResponse() {
  return {};
}
function createBaseSetRequest() {
  return { key: "", value: void 0 };
}
function createBaseRemoveRequest() {
  return { key: "" };
}
function createBaseRemoveResponse() {
  return {};
}
function createBaseClearResponse2() {
  return {};
}
function createBaseListRequest() {
  return {};
}
function createBaseListResponse() {
  return { values: {} };
}
function createBaseListResponse_ValuesEntry() {
  return { key: "", value: void 0 };
}
function createBaseRequest7() {
  return { get: void 0, set: void 0, remove: void 0, clear: void 0, list: void 0 };
}
function createBaseResponse7() {
  return { get: void 0, set: void 0, remove: void 0, clear: void 0, list: void 0 };
}
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet9(value) {
  return value !== null && value !== void 0;
}
var ClearRequest2, GetRequest, GetResponse, SetResponse, SetRequest, RemoveRequest, RemoveResponse, ClearResponse2, ListRequest, ListResponse, ListResponse_ValuesEntry, Request7, Response7;
var init_storage = __esm({
  "../api/src/api/proto/storage.ts"() {
    "use strict";
    init_wire();
    init_struct();
    ClearRequest2 = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClearRequest2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ClearRequest2.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseClearRequest2();
        return message;
      }
    };
    GetRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet9(object.key) ? globalThis.String(object.key) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        return obj;
      },
      create(base) {
        return GetRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetRequest();
        message.key = object.key ?? "";
        return message;
      }
    };
    GetResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { value: isSet9(object?.value) ? object.value : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return GetResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetResponse();
        message.value = object.value ?? void 0;
        return message;
      }
    };
    SetResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return SetResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseSetResponse();
        return message;
      }
    };
    SetRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet9(object.key) ? globalThis.String(object.key) : "",
          value: isSet9(object?.value) ? object.value : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return SetRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSetRequest();
        message.key = object.key ?? "";
        message.value = object.value ?? void 0;
        return message;
      }
    };
    RemoveRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRemoveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { key: isSet9(object.key) ? globalThis.String(object.key) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        return obj;
      },
      create(base) {
        return RemoveRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRemoveRequest();
        message.key = object.key ?? "";
        return message;
      }
    };
    RemoveResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRemoveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return RemoveResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseRemoveResponse();
        return message;
      }
    };
    ClearResponse2 = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClearResponse2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ClearResponse2.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseClearResponse2();
        return message;
      }
    };
    ListRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return ListRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseListRequest();
        return message;
      }
    };
    ListResponse = {
      encode(message, writer = new BinaryWriter()) {
        Object.entries(message.values).forEach(([key, value]) => {
          if (value !== void 0) {
            ListResponse_ValuesEntry.encode({ key, value }, writer.uint32(10).fork()).join();
          }
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              const entry1 = ListResponse_ValuesEntry.decode(reader, reader.uint32());
              if (entry1.value !== void 0) {
                message.values[entry1.key] = entry1.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          values: isObject2(object.values) ? Object.entries(object.values).reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {}) : {}
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.values) {
          const entries = Object.entries(message.values);
          if (entries.length > 0) {
            obj.values = {};
            entries.forEach(([k, v]) => {
              obj.values[k] = v;
            });
          }
        }
        return obj;
      },
      create(base) {
        return ListResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseListResponse();
        message.values = Object.entries(object.values ?? {}).reduce(
          (acc, [key, value]) => {
            if (value !== void 0) {
              acc[key] = value;
            }
            return acc;
          },
          {}
        );
        return message;
      }
    };
    ListResponse_ValuesEntry = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListResponse_ValuesEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet9(object.key) ? globalThis.String(object.key) : "",
          value: isSet9(object?.value) ? object.value : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return ListResponse_ValuesEntry.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseListResponse_ValuesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? void 0;
        return message;
      }
    };
    Request7 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.get !== void 0) {
          GetRequest.encode(message.get, writer.uint32(10).fork()).join();
        }
        if (message.set !== void 0) {
          SetRequest.encode(message.set, writer.uint32(18).fork()).join();
        }
        if (message.remove !== void 0) {
          RemoveRequest.encode(message.remove, writer.uint32(26).fork()).join();
        }
        if (message.clear !== void 0) {
          ClearRequest2.encode(message.clear, writer.uint32(34).fork()).join();
        }
        if (message.list !== void 0) {
          ListRequest.encode(message.list, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest7();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.get = GetRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.set = SetRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.remove = RemoveRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.clear = ClearRequest2.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.list = ListRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          get: isSet9(object.get) ? GetRequest.fromJSON(object.get) : void 0,
          set: isSet9(object.set) ? SetRequest.fromJSON(object.set) : void 0,
          remove: isSet9(object.remove) ? RemoveRequest.fromJSON(object.remove) : void 0,
          clear: isSet9(object.clear) ? ClearRequest2.fromJSON(object.clear) : void 0,
          list: isSet9(object.list) ? ListRequest.fromJSON(object.list) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.get !== void 0) {
          obj.get = GetRequest.toJSON(message.get);
        }
        if (message.set !== void 0) {
          obj.set = SetRequest.toJSON(message.set);
        }
        if (message.remove !== void 0) {
          obj.remove = RemoveRequest.toJSON(message.remove);
        }
        if (message.clear !== void 0) {
          obj.clear = ClearRequest2.toJSON(message.clear);
        }
        if (message.list !== void 0) {
          obj.list = ListRequest.toJSON(message.list);
        }
        return obj;
      },
      create(base) {
        return Request7.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest7();
        message.get = object.get !== void 0 && object.get !== null ? GetRequest.fromPartial(object.get) : void 0;
        message.set = object.set !== void 0 && object.set !== null ? SetRequest.fromPartial(object.set) : void 0;
        message.remove = object.remove !== void 0 && object.remove !== null ? RemoveRequest.fromPartial(object.remove) : void 0;
        message.clear = object.clear !== void 0 && object.clear !== null ? ClearRequest2.fromPartial(object.clear) : void 0;
        message.list = object.list !== void 0 && object.list !== null ? ListRequest.fromPartial(object.list) : void 0;
        return message;
      }
    };
    Response7 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.get !== void 0) {
          GetResponse.encode(message.get, writer.uint32(10).fork()).join();
        }
        if (message.set !== void 0) {
          SetResponse.encode(message.set, writer.uint32(18).fork()).join();
        }
        if (message.remove !== void 0) {
          RemoveResponse.encode(message.remove, writer.uint32(26).fork()).join();
        }
        if (message.clear !== void 0) {
          ClearResponse2.encode(message.clear, writer.uint32(34).fork()).join();
        }
        if (message.list !== void 0) {
          ListResponse.encode(message.list, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse7();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.get = GetResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.set = SetResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.remove = RemoveResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.clear = ClearResponse2.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.list = ListResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          get: isSet9(object.get) ? GetResponse.fromJSON(object.get) : void 0,
          set: isSet9(object.set) ? SetResponse.fromJSON(object.set) : void 0,
          remove: isSet9(object.remove) ? RemoveResponse.fromJSON(object.remove) : void 0,
          clear: isSet9(object.clear) ? ClearResponse2.fromJSON(object.clear) : void 0,
          list: isSet9(object.list) ? ListResponse.fromJSON(object.list) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.get !== void 0) {
          obj.get = GetResponse.toJSON(message.get);
        }
        if (message.set !== void 0) {
          obj.set = SetResponse.toJSON(message.set);
        }
        if (message.remove !== void 0) {
          obj.remove = RemoveResponse.toJSON(message.remove);
        }
        if (message.clear !== void 0) {
          obj.clear = ClearResponse2.toJSON(message.clear);
        }
        if (message.list !== void 0) {
          obj.list = ListResponse.toJSON(message.list);
        }
        return obj;
      },
      create(base) {
        return Response7.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse7();
        message.get = object.get !== void 0 && object.get !== null ? GetResponse.fromPartial(object.get) : void 0;
        message.set = object.set !== void 0 && object.set !== null ? SetResponse.fromPartial(object.set) : void 0;
        message.remove = object.remove !== void 0 && object.remove !== null ? RemoveResponse.fromPartial(object.remove) : void 0;
        message.clear = object.clear !== void 0 && object.clear !== null ? ClearResponse2.fromPartial(object.clear) : void 0;
        message.list = object.list !== void 0 && object.list !== null ? ListResponse.fromPartial(object.list) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/wm.ts
function createBaseWindow() {
  return {
    id: "",
    title: "",
    workspaceId: "",
    active: false,
    fullscreen: false,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    app: void 0
  };
}
function createBaseScreen() {
  return { name: "", model: "", make: "", serial: void 0, x: 0, y: 0, width: 0, height: 0 };
}
function createBaseWorkspace() {
  return { id: "", name: "", active: false, fullscreen: false, monitor: "" };
}
function createBasePingRequest() {
  return {};
}
function createBasePingResponse() {
  return { ok: false };
}
function createBaseFocusWindowRequest() {
  return { id: "" };
}
function createBaseFocusWindowResponse() {
  return { ok: false };
}
function createBaseGetActiveWindowRequest() {
  return {};
}
function createBaseGetActiveWindowResponse() {
  return { window: void 0 };
}
function createBaseGetWorkspacesRequest() {
  return {};
}
function createBaseGetWorkspacesResponse() {
  return { workspaces: [] };
}
function createBaseGetActiveWorkspaceRequest() {
  return {};
}
function createBaseGetActiveWorkspaceResponse() {
  return { workspace: void 0 };
}
function createBaseGetScreensRequest() {
  return {};
}
function createBaseGetScreensResponse() {
  return { screens: [] };
}
function createBaseGetWindowsRequest() {
  return { workspaceId: void 0 };
}
function createBaseGetWindowsResponse() {
  return { windows: [] };
}
function createBaseSetWindowBoundsRequest() {
  return { id: "", workspaceId: void 0 };
}
function createBaseSetWindowBoundsResponse() {
  return {};
}
function createBaseRequest8() {
  return {
    ping: void 0,
    getActiveWindow: void 0,
    getActiveWorkspace: void 0,
    getWindows: void 0,
    getScreens: void 0,
    getWorkspaces: void 0,
    setWindowBounds: void 0,
    focusWindow: void 0
  };
}
function createBaseResponse8() {
  return {
    ping: void 0,
    getActiveWindow: void 0,
    getActiveWorkspace: void 0,
    getWindows: void 0,
    getScreens: void 0,
    getWorkspaces: void 0,
    setWindowBounds: void 0,
    focusWindow: void 0
  };
}
function isSet10(value) {
  return value !== null && value !== void 0;
}
var Window, Screen, Workspace, PingRequest, PingResponse, FocusWindowRequest, FocusWindowResponse, GetActiveWindowRequest, GetActiveWindowResponse, GetWorkspacesRequest, GetWorkspacesResponse, GetActiveWorkspaceRequest, GetActiveWorkspaceResponse, GetScreensRequest, GetScreensResponse, GetWindowsRequest, GetWindowsResponse, SetWindowBoundsRequest, SetWindowBoundsResponse, Request8, Response8;
var init_wm = __esm({
  "../api/src/api/proto/wm.ts"() {
    "use strict";
    init_wire();
    init_application();
    Window = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        if (message.workspaceId !== "") {
          writer.uint32(26).string(message.workspaceId);
        }
        if (message.active !== false) {
          writer.uint32(32).bool(message.active);
        }
        if (message.fullscreen !== false) {
          writer.uint32(40).bool(message.fullscreen);
        }
        if (message.x !== 0) {
          writer.uint32(48).int32(message.x);
        }
        if (message.y !== 0) {
          writer.uint32(56).int32(message.y);
        }
        if (message.width !== 0) {
          writer.uint32(64).int32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(72).int32(message.height);
        }
        if (message.app !== void 0) {
          Application.encode(message.app, writer.uint32(82).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWindow();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.workspaceId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.active = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.fullscreen = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.x = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.y = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.app = Application.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet10(object.id) ? globalThis.String(object.id) : "",
          title: isSet10(object.title) ? globalThis.String(object.title) : "",
          workspaceId: isSet10(object.workspaceId) ? globalThis.String(object.workspaceId) : "",
          active: isSet10(object.active) ? globalThis.Boolean(object.active) : false,
          fullscreen: isSet10(object.fullscreen) ? globalThis.Boolean(object.fullscreen) : false,
          x: isSet10(object.x) ? globalThis.Number(object.x) : 0,
          y: isSet10(object.y) ? globalThis.Number(object.y) : 0,
          width: isSet10(object.width) ? globalThis.Number(object.width) : 0,
          height: isSet10(object.height) ? globalThis.Number(object.height) : 0,
          app: isSet10(object.app) ? Application.fromJSON(object.app) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.title !== "") {
          obj.title = message.title;
        }
        if (message.workspaceId !== "") {
          obj.workspaceId = message.workspaceId;
        }
        if (message.active !== false) {
          obj.active = message.active;
        }
        if (message.fullscreen !== false) {
          obj.fullscreen = message.fullscreen;
        }
        if (message.x !== 0) {
          obj.x = Math.round(message.x);
        }
        if (message.y !== 0) {
          obj.y = Math.round(message.y);
        }
        if (message.width !== 0) {
          obj.width = Math.round(message.width);
        }
        if (message.height !== 0) {
          obj.height = Math.round(message.height);
        }
        if (message.app !== void 0) {
          obj.app = Application.toJSON(message.app);
        }
        return obj;
      },
      create(base) {
        return Window.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseWindow();
        message.id = object.id ?? "";
        message.title = object.title ?? "";
        message.workspaceId = object.workspaceId ?? "";
        message.active = object.active ?? false;
        message.fullscreen = object.fullscreen ?? false;
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        message.app = object.app !== void 0 && object.app !== null ? Application.fromPartial(object.app) : void 0;
        return message;
      }
    };
    Screen = {
      encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.model !== "") {
          writer.uint32(18).string(message.model);
        }
        if (message.make !== "") {
          writer.uint32(26).string(message.make);
        }
        if (message.serial !== void 0) {
          writer.uint32(34).string(message.serial);
        }
        if (message.x !== 0) {
          writer.uint32(40).int32(message.x);
        }
        if (message.y !== 0) {
          writer.uint32(48).int32(message.y);
        }
        if (message.width !== 0) {
          writer.uint32(56).int32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(64).int32(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseScreen();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.model = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.make = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.serial = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.x = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.y = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          name: isSet10(object.name) ? globalThis.String(object.name) : "",
          model: isSet10(object.model) ? globalThis.String(object.model) : "",
          make: isSet10(object.make) ? globalThis.String(object.make) : "",
          serial: isSet10(object.serial) ? globalThis.String(object.serial) : void 0,
          x: isSet10(object.x) ? globalThis.Number(object.x) : 0,
          y: isSet10(object.y) ? globalThis.Number(object.y) : 0,
          width: isSet10(object.width) ? globalThis.Number(object.width) : 0,
          height: isSet10(object.height) ? globalThis.Number(object.height) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.name !== "") {
          obj.name = message.name;
        }
        if (message.model !== "") {
          obj.model = message.model;
        }
        if (message.make !== "") {
          obj.make = message.make;
        }
        if (message.serial !== void 0) {
          obj.serial = message.serial;
        }
        if (message.x !== 0) {
          obj.x = Math.round(message.x);
        }
        if (message.y !== 0) {
          obj.y = Math.round(message.y);
        }
        if (message.width !== 0) {
          obj.width = Math.round(message.width);
        }
        if (message.height !== 0) {
          obj.height = Math.round(message.height);
        }
        return obj;
      },
      create(base) {
        return Screen.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseScreen();
        message.name = object.name ?? "";
        message.model = object.model ?? "";
        message.make = object.make ?? "";
        message.serial = object.serial ?? void 0;
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        return message;
      }
    };
    Workspace = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        if (message.active !== false) {
          writer.uint32(24).bool(message.active);
        }
        if (message.fullscreen !== false) {
          writer.uint32(32).bool(message.fullscreen);
        }
        if (message.monitor !== "") {
          writer.uint32(42).string(message.monitor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWorkspace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.active = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.fullscreen = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.monitor = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet10(object.id) ? globalThis.String(object.id) : "",
          name: isSet10(object.name) ? globalThis.String(object.name) : "",
          active: isSet10(object.active) ? globalThis.Boolean(object.active) : false,
          fullscreen: isSet10(object.fullscreen) ? globalThis.Boolean(object.fullscreen) : false,
          monitor: isSet10(object.monitor) ? globalThis.String(object.monitor) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.name !== "") {
          obj.name = message.name;
        }
        if (message.active !== false) {
          obj.active = message.active;
        }
        if (message.fullscreen !== false) {
          obj.fullscreen = message.fullscreen;
        }
        if (message.monitor !== "") {
          obj.monitor = message.monitor;
        }
        return obj;
      },
      create(base) {
        return Workspace.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseWorkspace();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.active = object.active ?? false;
        message.fullscreen = object.fullscreen ?? false;
        message.monitor = object.monitor ?? "";
        return message;
      }
    };
    PingRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePingRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return PingRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBasePingRequest();
        return message;
      }
    };
    PingResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ok !== false) {
          writer.uint32(8).bool(message.ok);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePingResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.ok = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { ok: isSet10(object.ok) ? globalThis.Boolean(object.ok) : false };
      },
      toJSON(message) {
        const obj = {};
        if (message.ok !== false) {
          obj.ok = message.ok;
        }
        return obj;
      },
      create(base) {
        return PingResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBasePingResponse();
        message.ok = object.ok ?? false;
        return message;
      }
    };
    FocusWindowRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFocusWindowRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { id: isSet10(object.id) ? globalThis.String(object.id) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        return obj;
      },
      create(base) {
        return FocusWindowRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseFocusWindowRequest();
        message.id = object.id ?? "";
        return message;
      }
    };
    FocusWindowResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ok !== false) {
          writer.uint32(8).bool(message.ok);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFocusWindowResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.ok = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { ok: isSet10(object.ok) ? globalThis.Boolean(object.ok) : false };
      },
      toJSON(message) {
        const obj = {};
        if (message.ok !== false) {
          obj.ok = message.ok;
        }
        return obj;
      },
      create(base) {
        return FocusWindowResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseFocusWindowResponse();
        message.ok = object.ok ?? false;
        return message;
      }
    };
    GetActiveWindowRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetActiveWindowRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return GetActiveWindowRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseGetActiveWindowRequest();
        return message;
      }
    };
    GetActiveWindowResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.window !== void 0) {
          Window.encode(message.window, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetActiveWindowResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.window = Window.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { window: isSet10(object.window) ? Window.fromJSON(object.window) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.window !== void 0) {
          obj.window = Window.toJSON(message.window);
        }
        return obj;
      },
      create(base) {
        return GetActiveWindowResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetActiveWindowResponse();
        message.window = object.window !== void 0 && object.window !== null ? Window.fromPartial(object.window) : void 0;
        return message;
      }
    };
    GetWorkspacesRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetWorkspacesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return GetWorkspacesRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseGetWorkspacesRequest();
        return message;
      }
    };
    GetWorkspacesResponse = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.workspaces) {
          Workspace.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetWorkspacesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.workspaces.push(Workspace.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          workspaces: globalThis.Array.isArray(object?.workspaces) ? object.workspaces.map((e) => Workspace.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.workspaces?.length) {
          obj.workspaces = message.workspaces.map((e) => Workspace.toJSON(e));
        }
        return obj;
      },
      create(base) {
        return GetWorkspacesResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetWorkspacesResponse();
        message.workspaces = object.workspaces?.map((e) => Workspace.fromPartial(e)) || [];
        return message;
      }
    };
    GetActiveWorkspaceRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetActiveWorkspaceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return GetActiveWorkspaceRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseGetActiveWorkspaceRequest();
        return message;
      }
    };
    GetActiveWorkspaceResponse = {
      encode(message, writer = new BinaryWriter()) {
        if (message.workspace !== void 0) {
          Workspace.encode(message.workspace, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetActiveWorkspaceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.workspace = Workspace.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { workspace: isSet10(object.workspace) ? Workspace.fromJSON(object.workspace) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.workspace !== void 0) {
          obj.workspace = Workspace.toJSON(message.workspace);
        }
        return obj;
      },
      create(base) {
        return GetActiveWorkspaceResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetActiveWorkspaceResponse();
        message.workspace = object.workspace !== void 0 && object.workspace !== null ? Workspace.fromPartial(object.workspace) : void 0;
        return message;
      }
    };
    GetScreensRequest = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetScreensRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return GetScreensRequest.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseGetScreensRequest();
        return message;
      }
    };
    GetScreensResponse = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.screens) {
          Screen.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetScreensResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.screens.push(Screen.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          screens: globalThis.Array.isArray(object?.screens) ? object.screens.map((e) => Screen.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.screens?.length) {
          obj.screens = message.screens.map((e) => Screen.toJSON(e));
        }
        return obj;
      },
      create(base) {
        return GetScreensResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetScreensResponse();
        message.screens = object.screens?.map((e) => Screen.fromPartial(e)) || [];
        return message;
      }
    };
    GetWindowsRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.workspaceId !== void 0) {
          writer.uint32(10).string(message.workspaceId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetWindowsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.workspaceId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { workspaceId: isSet10(object.workspaceId) ? globalThis.String(object.workspaceId) : void 0 };
      },
      toJSON(message) {
        const obj = {};
        if (message.workspaceId !== void 0) {
          obj.workspaceId = message.workspaceId;
        }
        return obj;
      },
      create(base) {
        return GetWindowsRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetWindowsRequest();
        message.workspaceId = object.workspaceId ?? void 0;
        return message;
      }
    };
    GetWindowsResponse = {
      encode(message, writer = new BinaryWriter()) {
        for (const v of message.windows) {
          Window.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetWindowsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.windows.push(Window.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          windows: globalThis.Array.isArray(object?.windows) ? object.windows.map((e) => Window.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.windows?.length) {
          obj.windows = message.windows.map((e) => Window.toJSON(e));
        }
        return obj;
      },
      create(base) {
        return GetWindowsResponse.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGetWindowsResponse();
        message.windows = object.windows?.map((e) => Window.fromPartial(e)) || [];
        return message;
      }
    };
    SetWindowBoundsRequest = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.workspaceId !== void 0) {
          writer.uint32(26).string(message.workspaceId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetWindowBoundsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.workspaceId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet10(object.id) ? globalThis.String(object.id) : "",
          workspaceId: isSet10(object.workspaceId) ? globalThis.String(object.workspaceId) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.workspaceId !== void 0) {
          obj.workspaceId = message.workspaceId;
        }
        return obj;
      },
      create(base) {
        return SetWindowBoundsRequest.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseSetWindowBoundsRequest();
        message.id = object.id ?? "";
        message.workspaceId = object.workspaceId ?? void 0;
        return message;
      }
    };
    SetWindowBoundsResponse = {
      encode(_, writer = new BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSetWindowBoundsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(_) {
        return {};
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      create(base) {
        return SetWindowBoundsResponse.fromPartial(base ?? {});
      },
      fromPartial(_) {
        const message = createBaseSetWindowBoundsResponse();
        return message;
      }
    };
    Request8 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ping !== void 0) {
          PingRequest.encode(message.ping, writer.uint32(10).fork()).join();
        }
        if (message.getActiveWindow !== void 0) {
          GetActiveWindowRequest.encode(message.getActiveWindow, writer.uint32(18).fork()).join();
        }
        if (message.getActiveWorkspace !== void 0) {
          GetActiveWorkspaceRequest.encode(message.getActiveWorkspace, writer.uint32(26).fork()).join();
        }
        if (message.getWindows !== void 0) {
          GetWindowsRequest.encode(message.getWindows, writer.uint32(34).fork()).join();
        }
        if (message.getScreens !== void 0) {
          GetScreensRequest.encode(message.getScreens, writer.uint32(42).fork()).join();
        }
        if (message.getWorkspaces !== void 0) {
          GetWorkspacesRequest.encode(message.getWorkspaces, writer.uint32(50).fork()).join();
        }
        if (message.setWindowBounds !== void 0) {
          SetWindowBoundsRequest.encode(message.setWindowBounds, writer.uint32(58).fork()).join();
        }
        if (message.focusWindow !== void 0) {
          FocusWindowRequest.encode(message.focusWindow, writer.uint32(66).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest8();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.ping = PingRequest.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.getActiveWindow = GetActiveWindowRequest.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.getActiveWorkspace = GetActiveWorkspaceRequest.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.getWindows = GetWindowsRequest.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.getScreens = GetScreensRequest.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.getWorkspaces = GetWorkspacesRequest.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.setWindowBounds = SetWindowBoundsRequest.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.focusWindow = FocusWindowRequest.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          ping: isSet10(object.ping) ? PingRequest.fromJSON(object.ping) : void 0,
          getActiveWindow: isSet10(object.getActiveWindow) ? GetActiveWindowRequest.fromJSON(object.getActiveWindow) : void 0,
          getActiveWorkspace: isSet10(object.getActiveWorkspace) ? GetActiveWorkspaceRequest.fromJSON(object.getActiveWorkspace) : void 0,
          getWindows: isSet10(object.getWindows) ? GetWindowsRequest.fromJSON(object.getWindows) : void 0,
          getScreens: isSet10(object.getScreens) ? GetScreensRequest.fromJSON(object.getScreens) : void 0,
          getWorkspaces: isSet10(object.getWorkspaces) ? GetWorkspacesRequest.fromJSON(object.getWorkspaces) : void 0,
          setWindowBounds: isSet10(object.setWindowBounds) ? SetWindowBoundsRequest.fromJSON(object.setWindowBounds) : void 0,
          focusWindow: isSet10(object.focusWindow) ? FocusWindowRequest.fromJSON(object.focusWindow) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ping !== void 0) {
          obj.ping = PingRequest.toJSON(message.ping);
        }
        if (message.getActiveWindow !== void 0) {
          obj.getActiveWindow = GetActiveWindowRequest.toJSON(message.getActiveWindow);
        }
        if (message.getActiveWorkspace !== void 0) {
          obj.getActiveWorkspace = GetActiveWorkspaceRequest.toJSON(message.getActiveWorkspace);
        }
        if (message.getWindows !== void 0) {
          obj.getWindows = GetWindowsRequest.toJSON(message.getWindows);
        }
        if (message.getScreens !== void 0) {
          obj.getScreens = GetScreensRequest.toJSON(message.getScreens);
        }
        if (message.getWorkspaces !== void 0) {
          obj.getWorkspaces = GetWorkspacesRequest.toJSON(message.getWorkspaces);
        }
        if (message.setWindowBounds !== void 0) {
          obj.setWindowBounds = SetWindowBoundsRequest.toJSON(message.setWindowBounds);
        }
        if (message.focusWindow !== void 0) {
          obj.focusWindow = FocusWindowRequest.toJSON(message.focusWindow);
        }
        return obj;
      },
      create(base) {
        return Request8.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest8();
        message.ping = object.ping !== void 0 && object.ping !== null ? PingRequest.fromPartial(object.ping) : void 0;
        message.getActiveWindow = object.getActiveWindow !== void 0 && object.getActiveWindow !== null ? GetActiveWindowRequest.fromPartial(object.getActiveWindow) : void 0;
        message.getActiveWorkspace = object.getActiveWorkspace !== void 0 && object.getActiveWorkspace !== null ? GetActiveWorkspaceRequest.fromPartial(object.getActiveWorkspace) : void 0;
        message.getWindows = object.getWindows !== void 0 && object.getWindows !== null ? GetWindowsRequest.fromPartial(object.getWindows) : void 0;
        message.getScreens = object.getScreens !== void 0 && object.getScreens !== null ? GetScreensRequest.fromPartial(object.getScreens) : void 0;
        message.getWorkspaces = object.getWorkspaces !== void 0 && object.getWorkspaces !== null ? GetWorkspacesRequest.fromPartial(object.getWorkspaces) : void 0;
        message.setWindowBounds = object.setWindowBounds !== void 0 && object.setWindowBounds !== null ? SetWindowBoundsRequest.fromPartial(object.setWindowBounds) : void 0;
        message.focusWindow = object.focusWindow !== void 0 && object.focusWindow !== null ? FocusWindowRequest.fromPartial(object.focusWindow) : void 0;
        return message;
      }
    };
    Response8 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ping !== void 0) {
          PingResponse.encode(message.ping, writer.uint32(10).fork()).join();
        }
        if (message.getActiveWindow !== void 0) {
          GetActiveWindowResponse.encode(message.getActiveWindow, writer.uint32(18).fork()).join();
        }
        if (message.getActiveWorkspace !== void 0) {
          GetActiveWorkspaceResponse.encode(message.getActiveWorkspace, writer.uint32(26).fork()).join();
        }
        if (message.getWindows !== void 0) {
          GetWindowsResponse.encode(message.getWindows, writer.uint32(34).fork()).join();
        }
        if (message.getScreens !== void 0) {
          GetScreensResponse.encode(message.getScreens, writer.uint32(42).fork()).join();
        }
        if (message.getWorkspaces !== void 0) {
          GetWorkspacesResponse.encode(message.getWorkspaces, writer.uint32(50).fork()).join();
        }
        if (message.setWindowBounds !== void 0) {
          SetWindowBoundsResponse.encode(message.setWindowBounds, writer.uint32(58).fork()).join();
        }
        if (message.focusWindow !== void 0) {
          FocusWindowResponse.encode(message.focusWindow, writer.uint32(66).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse8();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.ping = PingResponse.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.getActiveWindow = GetActiveWindowResponse.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.getActiveWorkspace = GetActiveWorkspaceResponse.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.getWindows = GetWindowsResponse.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.getScreens = GetScreensResponse.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.getWorkspaces = GetWorkspacesResponse.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.setWindowBounds = SetWindowBoundsResponse.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.focusWindow = FocusWindowResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          ping: isSet10(object.ping) ? PingResponse.fromJSON(object.ping) : void 0,
          getActiveWindow: isSet10(object.getActiveWindow) ? GetActiveWindowResponse.fromJSON(object.getActiveWindow) : void 0,
          getActiveWorkspace: isSet10(object.getActiveWorkspace) ? GetActiveWorkspaceResponse.fromJSON(object.getActiveWorkspace) : void 0,
          getWindows: isSet10(object.getWindows) ? GetWindowsResponse.fromJSON(object.getWindows) : void 0,
          getScreens: isSet10(object.getScreens) ? GetScreensResponse.fromJSON(object.getScreens) : void 0,
          getWorkspaces: isSet10(object.getWorkspaces) ? GetWorkspacesResponse.fromJSON(object.getWorkspaces) : void 0,
          setWindowBounds: isSet10(object.setWindowBounds) ? SetWindowBoundsResponse.fromJSON(object.setWindowBounds) : void 0,
          focusWindow: isSet10(object.focusWindow) ? FocusWindowResponse.fromJSON(object.focusWindow) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ping !== void 0) {
          obj.ping = PingResponse.toJSON(message.ping);
        }
        if (message.getActiveWindow !== void 0) {
          obj.getActiveWindow = GetActiveWindowResponse.toJSON(message.getActiveWindow);
        }
        if (message.getActiveWorkspace !== void 0) {
          obj.getActiveWorkspace = GetActiveWorkspaceResponse.toJSON(message.getActiveWorkspace);
        }
        if (message.getWindows !== void 0) {
          obj.getWindows = GetWindowsResponse.toJSON(message.getWindows);
        }
        if (message.getScreens !== void 0) {
          obj.getScreens = GetScreensResponse.toJSON(message.getScreens);
        }
        if (message.getWorkspaces !== void 0) {
          obj.getWorkspaces = GetWorkspacesResponse.toJSON(message.getWorkspaces);
        }
        if (message.setWindowBounds !== void 0) {
          obj.setWindowBounds = SetWindowBoundsResponse.toJSON(message.setWindowBounds);
        }
        if (message.focusWindow !== void 0) {
          obj.focusWindow = FocusWindowResponse.toJSON(message.focusWindow);
        }
        return obj;
      },
      create(base) {
        return Response8.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse8();
        message.ping = object.ping !== void 0 && object.ping !== null ? PingResponse.fromPartial(object.ping) : void 0;
        message.getActiveWindow = object.getActiveWindow !== void 0 && object.getActiveWindow !== null ? GetActiveWindowResponse.fromPartial(object.getActiveWindow) : void 0;
        message.getActiveWorkspace = object.getActiveWorkspace !== void 0 && object.getActiveWorkspace !== null ? GetActiveWorkspaceResponse.fromPartial(object.getActiveWorkspace) : void 0;
        message.getWindows = object.getWindows !== void 0 && object.getWindows !== null ? GetWindowsResponse.fromPartial(object.getWindows) : void 0;
        message.getScreens = object.getScreens !== void 0 && object.getScreens !== null ? GetScreensResponse.fromPartial(object.getScreens) : void 0;
        message.getWorkspaces = object.getWorkspaces !== void 0 && object.getWorkspaces !== null ? GetWorkspacesResponse.fromPartial(object.getWorkspaces) : void 0;
        message.setWindowBounds = object.setWindowBounds !== void 0 && object.setWindowBounds !== null ? SetWindowBoundsResponse.fromPartial(object.setWindowBounds) : void 0;
        message.focusWindow = object.focusWindow !== void 0 && object.focusWindow !== null ? FocusWindowResponse.fromPartial(object.focusWindow) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/extension.ts
function createBaseRequest9() {
  return { requestId: "", data: void 0 };
}
function createBaseRequestData() {
  return {
    ui: void 0,
    app: void 0,
    clipboard: void 0,
    storage: void 0,
    oauth: void 0,
    fileSearch: void 0,
    wm: void 0,
    command: void 0
  };
}
function createBaseResponse9() {
  return { requestId: "", data: void 0, error: void 0 };
}
function createBaseResponseData() {
  return {
    ui: void 0,
    app: void 0,
    clipboard: void 0,
    storage: void 0,
    oauth: void 0,
    fileSearch: void 0,
    wm: void 0,
    command: void 0
  };
}
function createBaseEvent() {
  return { id: "", generic: void 0, crash: void 0, launch: void 0 };
}
function createBaseCrashEventData() {
  return { text: "" };
}
function createBaseGenericEventData() {
  return { json: "" };
}
function createBaseLaunchEventData() {
  return {
    extensionName: "",
    commandName: "",
    mode: 0,
    entrypoint: "",
    assetPath: "",
    supportPath: "",
    preferenceValues: {},
    argumentValues: {},
    isRaycast: false,
    ownerOrAuthorName: ""
  };
}
function createBaseLaunchEventData_PreferenceValuesEntry() {
  return { key: "", value: void 0 };
}
function createBaseLaunchEventData_ArgumentValuesEntry() {
  return { key: "", value: void 0 };
}
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
function isSet11(value) {
  return value !== null && value !== void 0;
}
var Request9, RequestData, Response9, ResponseData, Event, CrashEventData, GenericEventData, LaunchEventData, LaunchEventData_PreferenceValuesEntry, LaunchEventData_ArgumentValuesEntry;
var init_extension = __esm({
  "../api/src/api/proto/extension.ts"() {
    "use strict";
    init_wire();
    init_application();
    init_clipboard();
    init_command();
    init_common();
    init_file_search();
    init_struct();
    init_manager();
    init_oauth();
    init_storage();
    init_ui();
    init_wm();
    Request9 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.requestId !== "") {
          writer.uint32(10).string(message.requestId);
        }
        if (message.data !== void 0) {
          RequestData.encode(message.data, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest9();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.requestId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.data = RequestData.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          requestId: isSet11(object.requestId) ? globalThis.String(object.requestId) : "",
          data: isSet11(object.data) ? RequestData.fromJSON(object.data) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.requestId !== "") {
          obj.requestId = message.requestId;
        }
        if (message.data !== void 0) {
          obj.data = RequestData.toJSON(message.data);
        }
        return obj;
      },
      create(base) {
        return Request9.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequest9();
        message.requestId = object.requestId ?? "";
        message.data = object.data !== void 0 && object.data !== null ? RequestData.fromPartial(object.data) : void 0;
        return message;
      }
    };
    RequestData = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ui !== void 0) {
          Request.encode(message.ui, writer.uint32(10).fork()).join();
        }
        if (message.app !== void 0) {
          Request2.encode(message.app, writer.uint32(18).fork()).join();
        }
        if (message.clipboard !== void 0) {
          Request3.encode(message.clipboard, writer.uint32(26).fork()).join();
        }
        if (message.storage !== void 0) {
          Request7.encode(message.storage, writer.uint32(34).fork()).join();
        }
        if (message.oauth !== void 0) {
          Request6.encode(message.oauth, writer.uint32(42).fork()).join();
        }
        if (message.fileSearch !== void 0) {
          Request5.encode(message.fileSearch, writer.uint32(50).fork()).join();
        }
        if (message.wm !== void 0) {
          Request8.encode(message.wm, writer.uint32(58).fork()).join();
        }
        if (message.command !== void 0) {
          Request4.encode(message.command, writer.uint32(66).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.ui = Request.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.app = Request2.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.clipboard = Request3.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.storage = Request7.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.oauth = Request6.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fileSearch = Request5.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.wm = Request8.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.command = Request4.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          ui: isSet11(object.ui) ? Request.fromJSON(object.ui) : void 0,
          app: isSet11(object.app) ? Request2.fromJSON(object.app) : void 0,
          clipboard: isSet11(object.clipboard) ? Request3.fromJSON(object.clipboard) : void 0,
          storage: isSet11(object.storage) ? Request7.fromJSON(object.storage) : void 0,
          oauth: isSet11(object.oauth) ? Request6.fromJSON(object.oauth) : void 0,
          fileSearch: isSet11(object.fileSearch) ? Request5.fromJSON(object.fileSearch) : void 0,
          wm: isSet11(object.wm) ? Request8.fromJSON(object.wm) : void 0,
          command: isSet11(object.command) ? Request4.fromJSON(object.command) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ui !== void 0) {
          obj.ui = Request.toJSON(message.ui);
        }
        if (message.app !== void 0) {
          obj.app = Request2.toJSON(message.app);
        }
        if (message.clipboard !== void 0) {
          obj.clipboard = Request3.toJSON(message.clipboard);
        }
        if (message.storage !== void 0) {
          obj.storage = Request7.toJSON(message.storage);
        }
        if (message.oauth !== void 0) {
          obj.oauth = Request6.toJSON(message.oauth);
        }
        if (message.fileSearch !== void 0) {
          obj.fileSearch = Request5.toJSON(message.fileSearch);
        }
        if (message.wm !== void 0) {
          obj.wm = Request8.toJSON(message.wm);
        }
        if (message.command !== void 0) {
          obj.command = Request4.toJSON(message.command);
        }
        return obj;
      },
      create(base) {
        return RequestData.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseRequestData();
        message.ui = object.ui !== void 0 && object.ui !== null ? Request.fromPartial(object.ui) : void 0;
        message.app = object.app !== void 0 && object.app !== null ? Request2.fromPartial(object.app) : void 0;
        message.clipboard = object.clipboard !== void 0 && object.clipboard !== null ? Request3.fromPartial(object.clipboard) : void 0;
        message.storage = object.storage !== void 0 && object.storage !== null ? Request7.fromPartial(object.storage) : void 0;
        message.oauth = object.oauth !== void 0 && object.oauth !== null ? Request6.fromPartial(object.oauth) : void 0;
        message.fileSearch = object.fileSearch !== void 0 && object.fileSearch !== null ? Request5.fromPartial(object.fileSearch) : void 0;
        message.wm = object.wm !== void 0 && object.wm !== null ? Request8.fromPartial(object.wm) : void 0;
        message.command = object.command !== void 0 && object.command !== null ? Request4.fromPartial(object.command) : void 0;
        return message;
      }
    };
    Response9 = {
      encode(message, writer = new BinaryWriter()) {
        if (message.requestId !== "") {
          writer.uint32(10).string(message.requestId);
        }
        if (message.data !== void 0) {
          ResponseData.encode(message.data, writer.uint32(18).fork()).join();
        }
        if (message.error !== void 0) {
          ErrorResponse.encode(message.error, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse9();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.requestId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.data = ResponseData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.error = ErrorResponse.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          requestId: isSet11(object.requestId) ? globalThis.String(object.requestId) : "",
          data: isSet11(object.data) ? ResponseData.fromJSON(object.data) : void 0,
          error: isSet11(object.error) ? ErrorResponse.fromJSON(object.error) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.requestId !== "") {
          obj.requestId = message.requestId;
        }
        if (message.data !== void 0) {
          obj.data = ResponseData.toJSON(message.data);
        }
        if (message.error !== void 0) {
          obj.error = ErrorResponse.toJSON(message.error);
        }
        return obj;
      },
      create(base) {
        return Response9.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponse9();
        message.requestId = object.requestId ?? "";
        message.data = object.data !== void 0 && object.data !== null ? ResponseData.fromPartial(object.data) : void 0;
        message.error = object.error !== void 0 && object.error !== null ? ErrorResponse.fromPartial(object.error) : void 0;
        return message;
      }
    };
    ResponseData = {
      encode(message, writer = new BinaryWriter()) {
        if (message.ui !== void 0) {
          Response.encode(message.ui, writer.uint32(10).fork()).join();
        }
        if (message.app !== void 0) {
          Response2.encode(message.app, writer.uint32(18).fork()).join();
        }
        if (message.clipboard !== void 0) {
          Response3.encode(message.clipboard, writer.uint32(26).fork()).join();
        }
        if (message.storage !== void 0) {
          Response7.encode(message.storage, writer.uint32(34).fork()).join();
        }
        if (message.oauth !== void 0) {
          Response6.encode(message.oauth, writer.uint32(42).fork()).join();
        }
        if (message.fileSearch !== void 0) {
          Response5.encode(message.fileSearch, writer.uint32(50).fork()).join();
        }
        if (message.wm !== void 0) {
          Response8.encode(message.wm, writer.uint32(58).fork()).join();
        }
        if (message.command !== void 0) {
          Response4.encode(message.command, writer.uint32(66).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.ui = Response.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.app = Response2.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.clipboard = Response3.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.storage = Response7.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.oauth = Response6.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fileSearch = Response5.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.wm = Response8.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.command = Response4.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          ui: isSet11(object.ui) ? Response.fromJSON(object.ui) : void 0,
          app: isSet11(object.app) ? Response2.fromJSON(object.app) : void 0,
          clipboard: isSet11(object.clipboard) ? Response3.fromJSON(object.clipboard) : void 0,
          storage: isSet11(object.storage) ? Response7.fromJSON(object.storage) : void 0,
          oauth: isSet11(object.oauth) ? Response6.fromJSON(object.oauth) : void 0,
          fileSearch: isSet11(object.fileSearch) ? Response5.fromJSON(object.fileSearch) : void 0,
          wm: isSet11(object.wm) ? Response8.fromJSON(object.wm) : void 0,
          command: isSet11(object.command) ? Response4.fromJSON(object.command) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.ui !== void 0) {
          obj.ui = Response.toJSON(message.ui);
        }
        if (message.app !== void 0) {
          obj.app = Response2.toJSON(message.app);
        }
        if (message.clipboard !== void 0) {
          obj.clipboard = Response3.toJSON(message.clipboard);
        }
        if (message.storage !== void 0) {
          obj.storage = Response7.toJSON(message.storage);
        }
        if (message.oauth !== void 0) {
          obj.oauth = Response6.toJSON(message.oauth);
        }
        if (message.fileSearch !== void 0) {
          obj.fileSearch = Response5.toJSON(message.fileSearch);
        }
        if (message.wm !== void 0) {
          obj.wm = Response8.toJSON(message.wm);
        }
        if (message.command !== void 0) {
          obj.command = Response4.toJSON(message.command);
        }
        return obj;
      },
      create(base) {
        return ResponseData.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseResponseData();
        message.ui = object.ui !== void 0 && object.ui !== null ? Response.fromPartial(object.ui) : void 0;
        message.app = object.app !== void 0 && object.app !== null ? Response2.fromPartial(object.app) : void 0;
        message.clipboard = object.clipboard !== void 0 && object.clipboard !== null ? Response3.fromPartial(object.clipboard) : void 0;
        message.storage = object.storage !== void 0 && object.storage !== null ? Response7.fromPartial(object.storage) : void 0;
        message.oauth = object.oauth !== void 0 && object.oauth !== null ? Response6.fromPartial(object.oauth) : void 0;
        message.fileSearch = object.fileSearch !== void 0 && object.fileSearch !== null ? Response5.fromPartial(object.fileSearch) : void 0;
        message.wm = object.wm !== void 0 && object.wm !== null ? Response8.fromPartial(object.wm) : void 0;
        message.command = object.command !== void 0 && object.command !== null ? Response4.fromPartial(object.command) : void 0;
        return message;
      }
    };
    Event = {
      encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.generic !== void 0) {
          GenericEventData.encode(message.generic, writer.uint32(18).fork()).join();
        }
        if (message.crash !== void 0) {
          CrashEventData.encode(message.crash, writer.uint32(26).fork()).join();
        }
        if (message.launch !== void 0) {
          LaunchEventData.encode(message.launch, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.generic = GenericEventData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.crash = CrashEventData.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.launch = LaunchEventData.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          id: isSet11(object.id) ? globalThis.String(object.id) : "",
          generic: isSet11(object.generic) ? GenericEventData.fromJSON(object.generic) : void 0,
          crash: isSet11(object.crash) ? CrashEventData.fromJSON(object.crash) : void 0,
          launch: isSet11(object.launch) ? LaunchEventData.fromJSON(object.launch) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.id !== "") {
          obj.id = message.id;
        }
        if (message.generic !== void 0) {
          obj.generic = GenericEventData.toJSON(message.generic);
        }
        if (message.crash !== void 0) {
          obj.crash = CrashEventData.toJSON(message.crash);
        }
        if (message.launch !== void 0) {
          obj.launch = LaunchEventData.toJSON(message.launch);
        }
        return obj;
      },
      create(base) {
        return Event.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseEvent();
        message.id = object.id ?? "";
        message.generic = object.generic !== void 0 && object.generic !== null ? GenericEventData.fromPartial(object.generic) : void 0;
        message.crash = object.crash !== void 0 && object.crash !== null ? CrashEventData.fromPartial(object.crash) : void 0;
        message.launch = object.launch !== void 0 && object.launch !== null ? LaunchEventData.fromPartial(object.launch) : void 0;
        return message;
      }
    };
    CrashEventData = {
      encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
          writer.uint32(10).string(message.text);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCrashEventData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { text: isSet11(object.text) ? globalThis.String(object.text) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.text !== "") {
          obj.text = message.text;
        }
        return obj;
      },
      create(base) {
        return CrashEventData.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseCrashEventData();
        message.text = object.text ?? "";
        return message;
      }
    };
    GenericEventData = {
      encode(message, writer = new BinaryWriter()) {
        if (message.json !== "") {
          writer.uint32(10).string(message.json);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericEventData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.json = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return { json: isSet11(object.json) ? globalThis.String(object.json) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.json !== "") {
          obj.json = message.json;
        }
        return obj;
      },
      create(base) {
        return GenericEventData.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseGenericEventData();
        message.json = object.json ?? "";
        return message;
      }
    };
    LaunchEventData = {
      encode(message, writer = new BinaryWriter()) {
        if (message.extensionName !== "") {
          writer.uint32(10).string(message.extensionName);
        }
        if (message.commandName !== "") {
          writer.uint32(18).string(message.commandName);
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.entrypoint !== "") {
          writer.uint32(34).string(message.entrypoint);
        }
        if (message.assetPath !== "") {
          writer.uint32(42).string(message.assetPath);
        }
        if (message.supportPath !== "") {
          writer.uint32(50).string(message.supportPath);
        }
        Object.entries(message.preferenceValues).forEach(([key, value]) => {
          if (value !== void 0) {
            LaunchEventData_PreferenceValuesEntry.encode({ key, value }, writer.uint32(58).fork()).join();
          }
        });
        Object.entries(message.argumentValues).forEach(([key, value]) => {
          if (value !== void 0) {
            LaunchEventData_ArgumentValuesEntry.encode({ key, value }, writer.uint32(66).fork()).join();
          }
        });
        if (message.isRaycast !== false) {
          writer.uint32(72).bool(message.isRaycast);
        }
        if (message.ownerOrAuthorName !== "") {
          writer.uint32(82).string(message.ownerOrAuthorName);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLaunchEventData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.extensionName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.commandName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.mode = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.entrypoint = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.assetPath = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.supportPath = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              const entry7 = LaunchEventData_PreferenceValuesEntry.decode(reader, reader.uint32());
              if (entry7.value !== void 0) {
                message.preferenceValues[entry7.key] = entry7.value;
              }
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              const entry8 = LaunchEventData_ArgumentValuesEntry.decode(reader, reader.uint32());
              if (entry8.value !== void 0) {
                message.argumentValues[entry8.key] = entry8.value;
              }
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.isRaycast = reader.bool();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.ownerOrAuthorName = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          extensionName: isSet11(object.extensionName) ? globalThis.String(object.extensionName) : "",
          commandName: isSet11(object.commandName) ? globalThis.String(object.commandName) : "",
          mode: isSet11(object.mode) ? commandModeFromJSON(object.mode) : 0,
          entrypoint: isSet11(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
          assetPath: isSet11(object.assetPath) ? globalThis.String(object.assetPath) : "",
          supportPath: isSet11(object.supportPath) ? globalThis.String(object.supportPath) : "",
          preferenceValues: isObject3(object.preferenceValues) ? Object.entries(object.preferenceValues).reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {}) : {},
          argumentValues: isObject3(object.argumentValues) ? Object.entries(object.argumentValues).reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {}) : {},
          isRaycast: isSet11(object.isRaycast) ? globalThis.Boolean(object.isRaycast) : false,
          ownerOrAuthorName: isSet11(object.ownerOrAuthorName) ? globalThis.String(object.ownerOrAuthorName) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.extensionName !== "") {
          obj.extensionName = message.extensionName;
        }
        if (message.commandName !== "") {
          obj.commandName = message.commandName;
        }
        if (message.mode !== 0) {
          obj.mode = commandModeToJSON(message.mode);
        }
        if (message.entrypoint !== "") {
          obj.entrypoint = message.entrypoint;
        }
        if (message.assetPath !== "") {
          obj.assetPath = message.assetPath;
        }
        if (message.supportPath !== "") {
          obj.supportPath = message.supportPath;
        }
        if (message.preferenceValues) {
          const entries = Object.entries(message.preferenceValues);
          if (entries.length > 0) {
            obj.preferenceValues = {};
            entries.forEach(([k, v]) => {
              obj.preferenceValues[k] = v;
            });
          }
        }
        if (message.argumentValues) {
          const entries = Object.entries(message.argumentValues);
          if (entries.length > 0) {
            obj.argumentValues = {};
            entries.forEach(([k, v]) => {
              obj.argumentValues[k] = v;
            });
          }
        }
        if (message.isRaycast !== false) {
          obj.isRaycast = message.isRaycast;
        }
        if (message.ownerOrAuthorName !== "") {
          obj.ownerOrAuthorName = message.ownerOrAuthorName;
        }
        return obj;
      },
      create(base) {
        return LaunchEventData.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseLaunchEventData();
        message.extensionName = object.extensionName ?? "";
        message.commandName = object.commandName ?? "";
        message.mode = object.mode ?? 0;
        message.entrypoint = object.entrypoint ?? "";
        message.assetPath = object.assetPath ?? "";
        message.supportPath = object.supportPath ?? "";
        message.preferenceValues = Object.entries(object.preferenceValues ?? {}).reduce(
          (acc, [key, value]) => {
            if (value !== void 0) {
              acc[key] = value;
            }
            return acc;
          },
          {}
        );
        message.argumentValues = Object.entries(object.argumentValues ?? {}).reduce(
          (acc, [key, value]) => {
            if (value !== void 0) {
              acc[key] = value;
            }
            return acc;
          },
          {}
        );
        message.isRaycast = object.isRaycast ?? false;
        message.ownerOrAuthorName = object.ownerOrAuthorName ?? "";
        return message;
      }
    };
    LaunchEventData_PreferenceValuesEntry = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLaunchEventData_PreferenceValuesEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet11(object.key) ? globalThis.String(object.key) : "",
          value: isSet11(object?.value) ? object.value : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return LaunchEventData_PreferenceValuesEntry.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseLaunchEventData_PreferenceValuesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? void 0;
        return message;
      }
    };
    LaunchEventData_ArgumentValuesEntry = {
      encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== void 0) {
          Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLaunchEventData_ArgumentValuesEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          key: isSet11(object.key) ? globalThis.String(object.key) : "",
          value: isSet11(object?.value) ? object.value : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.key !== "") {
          obj.key = message.key;
        }
        if (message.value !== void 0) {
          obj.value = message.value;
        }
        return obj;
      },
      create(base) {
        return LaunchEventData_ArgumentValuesEntry.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseLaunchEventData_ArgumentValuesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/proto/ipc.ts
function createBaseExtensionMessage() {
  return { request: void 0, response: void 0, event: void 0 };
}
function isSet12(value) {
  return value !== null && value !== void 0;
}
var ExtensionMessage;
var init_ipc = __esm({
  "../api/src/api/proto/ipc.ts"() {
    "use strict";
    init_wire();
    init_common();
    init_extension();
    init_manager();
    ExtensionMessage = {
      encode(message, writer = new BinaryWriter()) {
        if (message.request !== void 0) {
          Request9.encode(message.request, writer.uint32(10).fork()).join();
        }
        if (message.response !== void 0) {
          Response9.encode(message.response, writer.uint32(18).fork()).join();
        }
        if (message.event !== void 0) {
          Event.encode(message.event, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtensionMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.request = Request9.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.response = Response9.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.event = Event.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      },
      fromJSON(object) {
        return {
          request: isSet12(object.request) ? Request9.fromJSON(object.request) : void 0,
          response: isSet12(object.response) ? Response9.fromJSON(object.response) : void 0,
          event: isSet12(object.event) ? Event.fromJSON(object.event) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.request !== void 0) {
          obj.request = Request9.toJSON(message.request);
        }
        if (message.response !== void 0) {
          obj.response = Response9.toJSON(message.response);
        }
        if (message.event !== void 0) {
          obj.event = Event.toJSON(message.event);
        }
        return obj;
      },
      create(base) {
        return ExtensionMessage.fromPartial(base ?? {});
      },
      fromPartial(object) {
        const message = createBaseExtensionMessage();
        message.request = object.request !== void 0 && object.request !== null ? Request9.fromPartial(object.request) : void 0;
        message.response = object.response !== void 0 && object.response !== null ? Response9.fromPartial(object.response) : void 0;
        message.event = object.event !== void 0 && object.event !== null ? Event.fromPartial(object.event) : void 0;
        return message;
      }
    };
  }
});

// ../api/src/api/lib/result.ts
var Ok, Err;
var init_result = __esm({
  "../api/src/api/lib/result.ts"() {
    "use strict";
    Ok = (data) => {
      return { ok: true, value: data, unwrap: () => data };
    };
    Err = (error) => {
      return {
        ok: false,
        error,
        unwrap: () => {
          throw error;
        }
      };
    };
  }
});

// ../api/src/api/bus.ts
var import_node_crypto3, import_node_worker_threads, Bus, bus;
var init_bus = __esm({
  "../api/src/api/bus.ts"() {
    "use strict";
    import_node_crypto3 = require("node:crypto");
    import_node_worker_threads = require("node:worker_threads");
    init_ipc();
    init_extension();
    init_result();
    Bus = class {
      constructor(port) {
        this.port = port;
        if (!port) return;
        port.on("message", (buf) => {
          this.handleSafeMessage(ExtensionMessage.decode(buf));
        });
        port.on("messageerror", (error) => {
          console.error(`Message error from manager`, error);
        });
        port.on("close", () => {
          console.error(`Parent port closed prematurely`);
        });
      }
      requestMap = /* @__PURE__ */ new Map();
      safeRequestMap = /* @__PURE__ */ new Map();
      eventListeners = /* @__PURE__ */ new Map();
      onLaunchHandlers = [];
      async request(endpoint, data) {
        const [category, requestId] = endpoint.split(".");
        const request = RequestData.create({
          [category]: { [requestId]: data }
        });
        const res = await this.requestImpl(request);
        if (!res.ok) {
          return Err(res.error);
        }
        const resData = res.value[category]?.[requestId];
        if (!resData) {
          return Err(
            Error(
              `Invalid response for request of type ${endpoint}: ${JSON.stringify(res, null, 2)}`
            )
          );
        }
        return Ok(resData);
      }
      handleSafeMessage(message) {
        if (message.response) {
          const request = this.safeRequestMap.get(message.response.requestId);
          if (!request) {
            return;
          }
          this.requestMap.delete(message.response.requestId);
          request.resolve(message.response);
          return;
        }
        if (message.event) {
          const { id, generic, launch } = message.event;
          if (launch) {
            for (const fn of this.onLaunchHandlers) {
              fn(launch);
            }
          }
          if (generic) {
            const listeners = this.listEventListeners(id);
            const args = JSON.parse(generic.json);
            for (const listener of listeners) {
              listener.callback(...args ?? []);
            }
          }
        }
      }
      onLaunch(handler) {
        this.onLaunchHandlers.push(handler);
      }
      emitCrash(errorText) {
        this.sendMessage({
          event: {
            id: (0, import_node_crypto3.randomUUID)(),
            crash: { text: errorText }
          }
        });
      }
      listEventListeners(type) {
        return this.eventListeners.get(type) ?? [];
      }
      subscribe(type, cb) {
        const item = { callback: cb };
        const listeners = this.eventListeners.get(type);
        if (!listeners) {
          this.eventListeners.set(type, [item]);
        } else {
          listeners.push(item);
        }
        return {
          unsubscribe: () => {
            const listeners2 = this.eventListeners.get(type) ?? [];
            const index = listeners2.indexOf(item);
            if (index != -1) {
              listeners2.splice(index, 1);
              if (listeners2.length === 0) {
                this.eventListeners.delete(type);
              }
            }
          }
        };
      }
      emit(action, data) {
        const message = ExtensionMessage.create({
          event: {
            id: action,
            generic: { json: JSON.stringify([data]) }
          }
        });
        this.sendMessage(message);
      }
      sendMessage(message) {
        this.port.postMessage(ExtensionMessage.encode(message).finish());
      }
      addEventHandler(cb) {
        const id = `handler-${(0, import_node_crypto3.randomUUID)()}`;
        const { unsubscribe } = this.subscribe(id, cb);
        return { id, unsubscribe };
      }
      replaceEventHandler(id, handler) {
        for (const listener of this.eventListeners.get(id) ?? []) {
          listener.callback = handler;
        }
      }
      removeEventHandler(id) {
        this.eventListeners.delete(id);
      }
      requestImpl(data, options = {}) {
        const req = Request9.create({ requestId: (0, import_node_crypto3.randomUUID)(), data });
        return new Promise(
          (resolve, reject) => {
            let timeout;
            if (options.timeout) {
              timeout = setTimeout(
                () => resolve(Err(Error(`request timed out`))),
                options.timeout
              );
            }
            const resolver = (response) => {
              clearTimeout(timeout);
              if (response.error) {
                return resolve(Err(new Error(response.error.errorText)));
              }
              if (!response.data) {
                return resolve(Err(new Error("No error and no data")));
              }
              resolve(Ok(response.data));
            };
            try {
              this.safeRequestMap.set(req.requestId, { resolve: resolver });
              this.sendMessage({ request: req });
            } catch (error) {
              reject(error);
            }
          }
        );
      }
    };
    bus = new Bus(import_node_worker_threads.parentPort);
  }
});

// ../api/src/api/clipboard.ts
var Clipboard;
var init_clipboard2 = __esm({
  "../api/src/api/clipboard.ts"() {
    "use strict";
    init_bus();
    init_clipboard();
    ((Clipboard3) => {
      function mapContent(content) {
        let ct = ClipboardContent.create();
        if (typeof content !== "object") {
          ct.text = `${content}`;
        } else {
          if (content["file"]) {
            ct.path = { path: content["file"] };
          } else if (content["html"]) {
            ct.html = { html: content["html"], text: content["text"] };
          } else {
            ct.text = content["text"];
          }
        }
        return ct;
      }
      async function copy(text, options = {}) {
        await bus.request("clipboard.copy", {
          content: mapContent(text),
          options: { concealed: options.concealed ?? false }
        });
      }
      Clipboard3.copy = copy;
      async function paste(text) {
        await bus.request("clipboard.paste", {
          content: mapContent(text)
        });
      }
      Clipboard3.paste = paste;
      async function read(options) {
        const res = await bus.request("clipboard.readContent", {});
        return res.unwrap().content;
      }
      Clipboard3.read = read;
      async function readText(options) {
        const { text } = await read(options);
        return text;
      }
      Clipboard3.readText = readText;
      async function clear() {
        await bus.request("clipboard.clear", {});
      }
      Clipboard3.clear = clear;
    })(Clipboard || (Clipboard = {}));
  }
});

// ../api/src/api/window-management.ts
var transformWorkspace, transformWindow, WindowManagement;
var init_window_management = __esm({
  "../api/src/api/window-management.ts"() {
    "use strict";
    init_bus();
    transformWorkspace = (proto) => {
      return {
        id: proto.id,
        name: proto.name,
        active: proto.active,
        monitorId: proto.monitor
      };
    };
    transformWindow = (proto) => {
      return {
        id: proto.id,
        title: proto.title,
        workspaceId: proto.workspaceId,
        active: proto.active,
        bounds: {
          position: { x: proto.x, y: proto.y },
          size: { width: proto.width, height: proto.height }
        },
        application: proto.app,
        focus() {
          return WindowManagement.focusWindow(this);
        }
      };
    };
    ((WindowManagement3) => {
      async function getWindows(options = {}) {
        const res = await bus.request("wm.getWindows", options);
        return res.unwrap().windows.map(transformWindow);
      }
      WindowManagement3.getWindows = getWindows;
      async function focusWindow(window2) {
        const res = await bus.request("wm.focusWindow", {
          id: window2.id
        });
        return res.unwrap().ok;
      }
      WindowManagement3.focusWindow = focusWindow;
      async function getScreens() {
        const res = await bus.request("wm.getScreens", {});
        return res.unwrap().screens.map((sc) => ({
          name: sc.name,
          make: sc.make,
          model: sc.model,
          serial: sc.serial,
          bounds: {
            position: { x: sc.x, y: sc.y },
            size: { width: sc.width, height: sc.height }
          }
        }));
      }
      WindowManagement3.getScreens = getScreens;
      async function getActiveWorkspace() {
        const res = await bus.request("wm.getActiveWorkspace", {});
        return transformWorkspace(res.unwrap().workspace);
      }
      WindowManagement3.getActiveWorkspace = getActiveWorkspace;
      async function getWorkspaces() {
        const res = await bus.request("wm.getWorkspaces", {});
        return res.unwrap().workspaces.map(transformWorkspace);
      }
      WindowManagement3.getWorkspaces = getWorkspaces;
      async function getWindowsOnActiveWorkspace() {
        const workspace = await getActiveWorkspace();
        return getWindows({ workspaceId: workspace.id });
      }
      WindowManagement3.getWindowsOnActiveWorkspace = getWindowsOnActiveWorkspace;
      async function setWindowBounds(payload) {
        await bus.request("wm.setWindowBounds", payload);
      }
      WindowManagement3.setWindowBounds = setWindowBounds;
      async function getActiveWindow() {
        const res = await bus.request("wm.getActiveWindow", {});
        return transformWindow(res.unwrap().window);
      }
      WindowManagement3.getActiveWindow = getActiveWindow;
    })(WindowManagement || (WindowManagement = {}));
  }
});

// ../api/src/api/utils.ts
var import_promises, trash, runInTerminal, open, getFrontmostApplication, getApplications, getDefaultApplication, showInFileBrowser;
var init_utils = __esm({
  "../api/src/api/utils.ts"() {
    "use strict";
    import_promises = require("node:fs/promises");
    init_bus();
    init_window_management();
    init_application();
    trash = async (path3) => {
      const targets = Array.isArray(path3) ? path3 : [path3];
      const promises = targets.map((p) => (0, import_promises.rm)(p, { recursive: true }));
      await Promise.all(promises);
    };
    runInTerminal = async (args, options = {}) => {
      const { hold = false, appId, title } = options;
      await bus.request("app.runInTerminal", {
        cmdline: args,
        hold,
        appId,
        title
      });
    };
    open = async (target, app) => {
      let appId;
      if (app) {
        if (typeof app === "string") {
          appId = app;
        } else {
          appId = app.id;
        }
      }
      await bus.request("app.open", {
        target,
        appId
      });
    };
    getFrontmostApplication = async () => {
      const { application } = await WindowManagement.getActiveWindow();
      if (!application) {
        throw new Error(`Could not get frontmost application`);
      }
      return application;
    };
    getApplications = async (target) => {
      const res = await bus.request("app.list", { target });
      return res.unwrap().apps;
    };
    getDefaultApplication = async (path3) => {
      const res = await bus.request("app.getDefault", { target: path3 });
      const app = res.unwrap().app;
      if (!app) throw new Error(`No default application for target ${path3}`);
      return app;
    };
    showInFileBrowser = async (path3) => {
      const fileBrowser = await getDefaultApplication("inode/directory");
      await open(path3.toString(), fileBrowser);
    };
  }
});

// ../api/src/api/icon.ts
var Icon;
var init_icon = __esm({
  "../api/src/api/icon.ts"() {
    "use strict";
    Icon = /* @__PURE__ */ ((Icon2) => {
      Icon2["AddPerson"] = "add-person";
      Icon2["Airplane"] = "airplane";
      Icon2["AirplaneFilled"] = "airplane-filled";
      Icon2["AirplaneLanding"] = "airplane-landing";
      Icon2["AirplaneTakeoff"] = "airplane-takeoff";
      Icon2["Airpods"] = "airpods";
      Icon2["Alarm"] = "alarm";
      Icon2["AlarmRinging"] = "alarm-ringing";
      Icon2["AlignCentre"] = "align-centre";
      Icon2["AlignLeft"] = "align-left";
      Icon2["AlignRight"] = "align-right";
      Icon2["AmericanFootball"] = "american-football";
      Icon2["Anchor"] = "anchor";
      Icon2["AppWindow"] = "app-window";
      Icon2["AppWindowGrid2x2"] = "app-window-grid-2x2";
      Icon2["AppWindowGrid3x3"] = "app-window-grid-3x3";
      Icon2["AppWindowList"] = "app-window-list";
      Icon2["AppWindowSidebarLeft"] = "app-window-sidebar-left";
      Icon2["AppWindowSidebarRight"] = "app-window-sidebar-right";
      Icon2["ArrowClockwise"] = "arrow-clockwise";
      Icon2["ArrowCounterClockwise"] = "arrow-counter-clockwise";
      Icon2["ArrowDown"] = "arrow-down";
      Icon2["ArrowDownCircle"] = "arrow-down-circle";
      Icon2["ArrowDownCircleFilled"] = "arrow-down-circle-filled";
      Icon2["ArrowLeft"] = "arrow-left";
      Icon2["ArrowLeftCircle"] = "arrow-left-circle";
      Icon2["ArrowLeftCircleFilled"] = "arrow-left-circle-filled";
      Icon2["ArrowNe"] = "arrow-ne";
      Icon2["ArrowRight"] = "arrow-right";
      Icon2["ArrowRightCircle"] = "arrow-right-circle";
      Icon2["ArrowRightCircleFilled"] = "arrow-right-circle-filled";
      Icon2["ArrowUp"] = "arrow-up";
      Icon2["ArrowUpCircle"] = "arrow-up-circle";
      Icon2["ArrowUpCircleFilled"] = "arrow-up-circle-filled";
      Icon2["ArrowsContract"] = "arrows-contract";
      Icon2["ArrowsExpand"] = "arrows-expand";
      Icon2["AtSymbol"] = "at-symbol";
      Icon2["BandAid"] = "band-aid";
      Icon2["BankNote"] = "bank-note";
      Icon2["BarChart"] = "bar-chart";
      Icon2["BarCode"] = "bar-code";
      Icon2["BathTub"] = "bath-tub";
      Icon2["Battery"] = "battery";
      Icon2["BatteryCharging"] = "battery-charging";
      Icon2["BatteryDisabled"] = "battery-disabled";
      Icon2["Bell"] = "bell";
      Icon2["BellDisabled"] = "bell-disabled";
      Icon2["Bike"] = "bike";
      Icon2["Binoculars"] = "binoculars";
      Icon2["Bird"] = "bird";
      Icon2["BlankDocument"] = "blank-document";
      Icon2["Bluetooth"] = "bluetooth";
      Icon2["Boat"] = "boat";
      Icon2["Bold"] = "bold";
      Icon2["Bolt"] = "bolt";
      Icon2["BoltDisabled"] = "bolt-disabled";
      Icon2["Book"] = "book";
      Icon2["Bookmark"] = "bookmark";
      Icon2["Box"] = "box";
      Icon2["Brush"] = "brush";
      Icon2["Bubble"] = "speech-bubble";
      Icon2["Bug"] = "bug";
      Icon2["Building"] = "building";
      Icon2["BulletPoints"] = "bullet-points";
      Icon2["BullsEye"] = "bulls-eye";
      Icon2["Buoy"] = "buoy";
      Icon2["Calculator"] = "calculator";
      Icon2["Calendar"] = "calendar";
      Icon2["Camera"] = "camera";
      Icon2["Car"] = "car";
      Icon2["Cart"] = "cart";
      Icon2["Cd"] = "cd";
      Icon2["Center"] = "center";
      Icon2["Check"] = "check";
      Icon2["CheckCircle"] = "check-circle";
      Icon2["CheckRosette"] = "check-rosette";
      Icon2["Checkmark"] = "check-circle";
      Icon2["ChessPiece"] = "chess-piece";
      Icon2["ChevronDown"] = "chevron-down";
      Icon2["ChevronDownSmall"] = "chevron-down-small";
      Icon2["ChevronLeft"] = "chevron-left";
      Icon2["ChevronLeftSmall"] = "chevron-left-small";
      Icon2["ChevronRight"] = "chevron-right";
      Icon2["ChevronRightSmall"] = "chevron-right-small";
      Icon2["ChevronUp"] = "chevron-up";
      Icon2["ChevronUpSmall"] = "chevron-up-small";
      Icon2["Circle"] = "circle";
      Icon2["CircleEllipsis"] = "circle-ellipsis";
      Icon2["CircleFilled"] = "circle-filled";
      Icon2["CircleProgress"] = "circle-progress";
      Icon2["CircleProgress100"] = "circle-progress-100";
      Icon2["CircleProgress25"] = "circle-progress-25";
      Icon2["CircleProgress50"] = "circle-progress-50";
      Icon2["CircleProgress75"] = "circle-progress-75";
      Icon2["ClearFormatting"] = "clear-formatting";
      Icon2["Clipboard"] = "copy-clipboard";
      Icon2["Clock"] = "clock";
      Icon2["Cloud"] = "cloud";
      Icon2["CloudLightning"] = "cloud-lightning";
      Icon2["CloudRain"] = "cloud-rain";
      Icon2["CloudSnow"] = "cloud-snow";
      Icon2["CloudSun"] = "cloud-sun";
      Icon2["Code"] = "code";
      Icon2["CodeBlock"] = "code-block";
      Icon2["Cog"] = "cog";
      Icon2["Coin"] = "coin";
      Icon2["Coins"] = "coins";
      Icon2["CommandSymbol"] = "command-symbol";
      Icon2["Compass"] = "compass";
      Icon2["ComputerChip"] = "computer-chip";
      Icon2["Contrast"] = "contrast";
      Icon2["CopyClipboard"] = "copy-clipboard";
      Icon2["CreditCard"] = "credit-card";
      Icon2["CricketBall"] = "cricket-ball";
      Icon2["Crop"] = "crop";
      Icon2["Crown"] = "crown";
      Icon2["Crypto"] = "crypto";
      Icon2["DeleteDocument"] = "delete-document";
      Icon2["Desktop"] = "desktop";
      Icon2["Dna"] = "dna";
      Icon2["Document"] = "blank-document";
      Icon2["Dot"] = "dot";
      Icon2["Download"] = "download";
      Icon2["EditShape"] = "edit-shape";
      Icon2["Eject"] = "eject";
      Icon2["Ellipsis"] = "ellipsis";
      Icon2["Emoji"] = "emoji";
      Icon2["Envelope"] = "envelope";
      Icon2["Eraser"] = "eraser";
      Icon2["ExclamationMark"] = "important-01";
      Icon2["Exclamationmark"] = "exclamationmark";
      Icon2["Exclamationmark2"] = "exclamationmark-2";
      Icon2["Exclamationmark3"] = "exclamationmark-3";
      Icon2["Eye"] = "eye";
      Icon2["EyeDisabled"] = "eye-disabled";
      Icon2["EyeDropper"] = "eye-dropper";
      Icon2["Female"] = "female";
      Icon2["FilmStrip"] = "film-strip";
      Icon2["Filter"] = "filter";
      Icon2["Finder"] = "finder";
      Icon2["Fingerprint"] = "fingerprint";
      Icon2["Flag"] = "flag";
      Icon2["Folder"] = "folder";
      Icon2["Footprints"] = "footprints";
      Icon2["Forward"] = "forward";
      Icon2["ForwardFilled"] = "forward-filled";
      Icon2["FountainTip"] = "fountain-tip";
      Icon2["FullSignal"] = "full-signal";
      Icon2["GameController"] = "game-controller";
      Icon2["Gauge"] = "gauge";
      Icon2["Gear"] = "cog";
      Icon2["Geopin"] = "geopin";
      Icon2["Germ"] = "germ";
      Icon2["Gift"] = "gift";
      Icon2["Glasses"] = "glasses";
      Icon2["Globe"] = "globe-01";
      Icon2["Goal"] = "goal";
      Icon2["Hammer"] = "hammer";
      Icon2["HardDrive"] = "hard-drive";
      Icon2["Hashtag"] = "hashtag";
      Icon2["Headphones"] = "headphones";
      Icon2["Heart"] = "heart";
      Icon2["HeartDisabled"] = "heart-disabled";
      Icon2["Heartbeat"] = "heartbeat";
      Icon2["Highlight"] = "highlight";
      Icon2["Hourglass"] = "hourglass";
      Icon2["House"] = "house";
      Icon2["Image"] = "image";
      Icon2["Important"] = "important-01";
      Icon2["Info"] = "info-01";
      Icon2["Italics"] = "italics";
      Icon2["Key"] = "key";
      Icon2["Keyboard"] = "keyboard";
      Icon2["Layers"] = "layers";
      Icon2["Leaderboard"] = "leaderboard";
      Icon2["Leaf"] = "leaf";
      Icon2["LevelMeter"] = "signal-2";
      Icon2["LightBulb"] = "light-bulb";
      Icon2["LightBulbOff"] = "light-bulb-off";
      Icon2["LineChart"] = "line-chart";
      Icon2["Link"] = "link";
      Icon2["List"] = "app-window-list";
      Icon2["Livestream"] = "livestream-01";
      Icon2["LivestreamDisabled"] = "livestream-disabled-01";
      Icon2["Lock"] = "lock";
      Icon2["LockDisabled"] = "lock-disabled";
      Icon2["LockUnlocked"] = "lock-unlocked";
      Icon2["Logout"] = "logout";
      Icon2["Lorry"] = "lorry";
      Icon2["Lowercase"] = "lowercase";
      Icon2["MagnifyingGlass"] = "magnifying-glass";
      Icon2["Male"] = "male";
      Icon2["Map"] = "map";
      Icon2["Mask"] = "mask";
      Icon2["Maximize"] = "maximize";
      Icon2["MedicalSupport"] = "medical-support";
      Icon2["Megaphone"] = "megaphone";
      Icon2["MemoryChip"] = "computer-chip";
      Icon2["MemoryStick"] = "memory-stick";
      Icon2["Message"] = "speech-bubble";
      Icon2["Microphone"] = "microphone";
      Icon2["MicrophoneDisabled"] = "microphone-disabled";
      Icon2["Minimize"] = "minimize";
      Icon2["Minus"] = "minus";
      Icon2["MinusCircle"] = "minus-circle";
      Icon2["MinusCircleFilled"] = "minus-circle-filled";
      Icon2["Mobile"] = "mobile";
      Icon2["Monitor"] = "monitor";
      Icon2["Moon"] = "moon";
      Icon2["Mountain"] = "mountain";
      Icon2["Mouse"] = "mouse";
      Icon2["Multiply"] = "multiply";
      Icon2["Music"] = "music";
      Icon2["Network"] = "network";
      Icon2["NewDocument"] = "new-document";
      Icon2["NewFolder"] = "new-folder";
      Icon2["Number00"] = "number-00";
      Icon2["Number01"] = "number-01";
      Icon2["Number02"] = "number-02";
      Icon2["Number03"] = "number-03";
      Icon2["Number04"] = "number-04";
      Icon2["Number05"] = "number-05";
      Icon2["Number06"] = "number-06";
      Icon2["Number07"] = "number-07";
      Icon2["Number08"] = "number-08";
      Icon2["Number09"] = "number-09";
      Icon2["Number10"] = "number-10";
      Icon2["Number11"] = "number-11";
      Icon2["Number12"] = "number-12";
      Icon2["Number13"] = "number-13";
      Icon2["Number14"] = "number-14";
      Icon2["Number15"] = "number-15";
      Icon2["Number16"] = "number";
      Icon2["Number17"] = "number-17";
      Icon2["Number18"] = "number-18";
      Icon2["Number19"] = "number-19";
      Icon2["Number20"] = "number-20";
      Icon2["Number21"] = "number-21";
      Icon2["Number22"] = "number-22";
      Icon2["Number23"] = "number-23";
      Icon2["Number24"] = "number-24";
      Icon2["Number25"] = "number-25";
      Icon2["Number26"] = "number-26";
      Icon2["Number27"] = "number-27";
      Icon2["Number28"] = "number-28";
      Icon2["Number29"] = "number-29";
      Icon2["Number30"] = "number-30";
      Icon2["Number31"] = "number-31";
      Icon2["Number32"] = "number-32";
      Icon2["Number33"] = "number-33";
      Icon2["Number34"] = "number-34";
      Icon2["Number35"] = "number-35";
      Icon2["Number36"] = "number-36";
      Icon2["Number37"] = "number-37";
      Icon2["Number38"] = "number-38";
      Icon2["Number39"] = "number-39";
      Icon2["Number40"] = "number-40";
      Icon2["Number41"] = "number-41";
      Icon2["Number42"] = "number-42";
      Icon2["Number43"] = "number-43";
      Icon2["Number44"] = "number-44";
      Icon2["Number45"] = "number-45";
      Icon2["Number46"] = "number-46";
      Icon2["Number47"] = "number-47";
      Icon2["Number48"] = "number-48";
      Icon2["Number49"] = "number-49";
      Icon2["Number50"] = "number-50";
      Icon2["Number51"] = "number-51";
      Icon2["Number52"] = "number-52";
      Icon2["Number53"] = "number-53";
      Icon2["Number54"] = "number-54";
      Icon2["Number55"] = "number-55";
      Icon2["Number56"] = "number-56";
      Icon2["Number57"] = "number-57";
      Icon2["Number58"] = "number-58";
      Icon2["Number59"] = "number-59";
      Icon2["Number60"] = "number-60";
      Icon2["Number61"] = "number-61";
      Icon2["Number62"] = "number-62";
      Icon2["Number63"] = "number-63";
      Icon2["Number64"] = "number-64";
      Icon2["Number65"] = "number-65";
      Icon2["Number66"] = "number-66";
      Icon2["Number67"] = "number-67";
      Icon2["Number68"] = "number-68";
      Icon2["Number69"] = "number-69";
      Icon2["Number70"] = "number-70";
      Icon2["Number71"] = "number-71";
      Icon2["Number72"] = "number-72";
      Icon2["Number73"] = "number-73";
      Icon2["Number74"] = "number-74";
      Icon2["Number75"] = "number-75";
      Icon2["Number76"] = "number-76";
      Icon2["Number77"] = "number-77";
      Icon2["Number78"] = "number-78";
      Icon2["Number79"] = "number-79";
      Icon2["Number80"] = "number-80";
      Icon2["Number81"] = "number-81";
      Icon2["Number82"] = "number-82";
      Icon2["Number83"] = "number-83";
      Icon2["Number84"] = "number-84";
      Icon2["Number85"] = "number-85";
      Icon2["Number86"] = "number-86";
      Icon2["Number87"] = "number-87";
      Icon2["Number88"] = "number-88";
      Icon2["Number89"] = "number-89";
      Icon2["Number90"] = "number-90";
      Icon2["Number91"] = "number-91";
      Icon2["Number92"] = "number-92";
      Icon2["Number93"] = "number-93";
      Icon2["Number94"] = "number-94";
      Icon2["Number95"] = "number-95";
      Icon2["Number96"] = "number-96";
      Icon2["Number97"] = "number-97";
      Icon2["Number98"] = "number-98";
      Icon2["Number99"] = "number-99";
      Icon2["Paperclip"] = "paperclip";
      Icon2["Paragraph"] = "paragraph";
      Icon2["Patch"] = "patch";
      Icon2["Pause"] = "pause";
      Icon2["PauseFilled"] = "pause-filled";
      Icon2["Pencil"] = "pencil";
      Icon2["Person"] = "person";
      Icon2["PersonCircle"] = "person-circle";
      Icon2["PersonLines"] = "person-lines";
      Icon2["Phone"] = "phone";
      Icon2["PhoneRinging"] = "phone-ringing";
      Icon2["PieChart"] = "pie-chart";
      Icon2["Pill"] = "pill";
      Icon2["Pin"] = "pin";
      Icon2["PinDisabled"] = "pin-disabled";
      Icon2["Play"] = "play";
      Icon2["PlayFilled"] = "play-filled";
      Icon2["Plug"] = "plug";
      Icon2["Plus"] = "plus";
      Icon2["PlusCircle"] = "plus-circle";
      Icon2["PlusCircleFilled"] = "plus-circle-filled";
      Icon2["PlusMinusDivideMultiply"] = "plus-minus-divide-multiply";
      Icon2["PlusSquare"] = "plus-square";
      Icon2["PlusTopRightSquare"] = "plus-top-right-square";
      Icon2["Power"] = "power";
      Icon2["Print"] = "print";
      Icon2["QuestionMark"] = "question-mark-circle";
      Icon2["QuestionMarkCircle"] = "question-mark-circle";
      Icon2["QuotationMarks"] = "quotation-marks";
      Icon2["QuoteBlock"] = "quote-block";
      Icon2["Racket"] = "racket";
      Icon2["Raindrop"] = "raindrop";
      Icon2["RaycastLogoNeg"] = "raycast-logo-neg";
      Icon2["RaycastLogoPos"] = "raycast-logo-pos";
      Icon2["Receipt"] = "receipt";
      Icon2["Redo"] = "redo";
      Icon2["RemovePerson"] = "remove-person";
      Icon2["Repeat"] = "repeat";
      Icon2["Reply"] = "reply";
      Icon2["Rewind"] = "rewind";
      Icon2["RewindFilled"] = "rewind-filled";
      Icon2["Rocket"] = "rocket";
      Icon2["Rosette"] = "rosette";
      Icon2["RotateAntiClockwise"] = "rotate-anti-clockwise";
      Icon2["RotateClockwise"] = "rotate-clockwise";
      Icon2["Ruler"] = "ruler";
      Icon2["SaveDocument"] = "save-document";
      Icon2["Shield"] = "shield-01";
      Icon2["ShortParagraph"] = "short-paragraph";
      Icon2["Shuffle"] = "shuffle";
      Icon2["Sidebar"] = "app-window-sidebar-right";
      Icon2["Signal1"] = "signal-1";
      Icon2["Signal2"] = "signal-2";
      Icon2["Signal3"] = "signal-3";
      Icon2["Snippets"] = "snippets";
      Icon2["Snowflake"] = "snowflake";
      Icon2["SoccerBall"] = "soccer-ball";
      Icon2["SpeakerDown"] = "speaker-down";
      Icon2["SpeakerHigh"] = "speaker-high";
      Icon2["SpeakerLow"] = "speaker-low";
      Icon2["SpeakerOff"] = "speaker-off";
      Icon2["SpeakerOn"] = "speaker-on";
      Icon2["SpeakerUp"] = "speaker-up";
      Icon2["SpeechBubble"] = "speech-bubble";
      Icon2["SpeechBubbleActive"] = "speech-bubble-active";
      Icon2["SpeechBubbleImportant"] = "speech-bubble-important";
      Icon2["Star"] = "star";
      Icon2["StarCircle"] = "star-circle";
      Icon2["StarDisabled"] = "star-disabled";
      Icon2["Stars"] = "stars";
      Icon2["Stop"] = "stop";
      Icon2["StopFilled"] = "stop-filled";
      Icon2["Stopwatch"] = "stopwatch";
      Icon2["Store"] = "store";
      Icon2["StrikeThrough"] = "strike-through";
      Icon2["Sun"] = "sun";
      Icon2["Sunrise"] = "sunrise";
      Icon2["Swatch"] = "swatch";
      Icon2["Switch"] = "switch";
      Icon2["Syringe"] = "syringe";
      Icon2["Tag"] = "tag";
      Icon2["Temperature"] = "temperature";
      Icon2["TennisBall"] = "tennis-ball";
      Icon2["Terminal"] = "terminal";
      Icon2["Text"] = "text";
      Icon2["TextCursor"] = "text-cursor";
      Icon2["TextInput"] = "text-input";
      Icon2["Torch"] = "torch";
      Icon2["Train"] = "train";
      Icon2["Trash"] = "trash";
      Icon2["Tray"] = "tray";
      Icon2["Tree"] = "tree";
      Icon2["Trophy"] = "trophy";
      Icon2["TwoPeople"] = "two-people";
      Icon2["Umbrella"] = "umbrella";
      Icon2["Underline"] = "underline";
      Icon2["Undo"] = "undo";
      Icon2["Upload"] = "upload";
      Icon2["Uppercase"] = "uppercase";
      Icon2["Video"] = "video";
      Icon2["Wallet"] = "wallet";
      Icon2["Wand"] = "wand";
      Icon2["Warning"] = "warning";
      Icon2["Weights"] = "weights";
      Icon2["Wifi"] = "wifi";
      Icon2["WifiDisabled"] = "wifi-disabled";
      Icon2["Window"] = "app-window";
      Icon2["WrenchScrewdriver"] = "wrench-screwdriver";
      Icon2["WristWatch"] = "wrist-watch";
      Icon2["XMarkCircle"] = "x-mark-circle";
      Icon2["XMarkCircleFilled"] = "x-mark-circle-filled";
      Icon2["XMarkTopRightSquare"] = "x-mark-top-right-square";
      Icon2["Zendesk"] = "zendesk";
      Icon2["TwoArrowsClockwise"] = "arrow-clockwise";
      Icon2["EyeSlash"] = "eye-disabled";
      Icon2["SpeakerArrowDown"] = "speaker-down";
      Icon2["SpeakerArrowUp"] = "speaker-up";
      Icon2["SpeakerSlash"] = "speaker-off";
      Icon2["TextDocument"] = "blank-document";
      Icon2["XmarkCircle"] = "x-mark-circle";
      return Icon2;
    })(Icon || {});
  }
});

// ../api/src/api/controls.ts
var PopToRootType2, popToRootProtoMap, showHUD, closeMainWindow, clearSearchBar, getSelectedText, popToRoot;
var init_controls = __esm({
  "../api/src/api/controls.ts"() {
    "use strict";
    init_bus();
    init_ui();
    PopToRootType2 = /* @__PURE__ */ ((PopToRootType3) => {
      PopToRootType3["Default"] = "default";
      PopToRootType3["Immediate"] = "immediate";
      PopToRootType3["Suspended"] = "suspended";
      return PopToRootType3;
    })(PopToRootType2 || {});
    popToRootProtoMap = {
      ["default" /* Default */]: 0 /* PopToRootDefault */,
      ["immediate" /* Immediate */]: 1 /* PopToRootImmediate */,
      ["suspended" /* Suspended */]: 2 /* PopToRootSuspended */
    };
    showHUD = async (title, options) => {
      bus.request("ui.showHud", {
        text: title,
        clearRootSearch: options?.clearRootSearch ?? false,
        popToRoot: popToRootProtoMap[options?.popToRootType ?? "default" /* Default */]
      });
    };
    closeMainWindow = async (options = {}) => {
      const { clearRootSearch = false, popToRootType = "default" /* Default */ } = options;
      await bus.request("ui.closeMainWindow", {
        clearRootSearch,
        popToRoot: popToRootProtoMap[popToRootType]
      });
    };
    clearSearchBar = async () => {
      await bus.request("ui.setSearchText", { text: "" });
    };
    getSelectedText = async () => {
      const response = await bus.request("ui.getSelectedText", {});
      if (!response.ok) {
        throw new Error(`Failed to get selected text`);
      }
      return response.value.text;
    };
    popToRoot = async (options) => {
      await bus.request("ui.popToRoot", {
        clearSearchBar: options?.clearSearchBar ?? false
      });
    };
  }
});

// ../api/src/api/components/actions.tsx
var import_react6, import_node_crypto4, import_jsx_runtime9, ActionRoot, CopyToClipboard, Paste, Open, OpenInBrowser, ShowInFinder, Push, SubmitForm, CreateQuicklink, Action;
var init_actions = __esm({
  "../api/src/api/components/actions.tsx"() {
    "use strict";
    import_react6 = __toESM(require_react());
    import_node_crypto4 = require("node:crypto");
    init_hooks();
    init_clipboard2();
    init_image();
    init_utils();
    init_icon();
    init_controls();
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    ActionRoot = ({ icon, ...props }) => {
      const serializedIcon = icon ? serializeProtoImage(icon) : icon;
      const stableIdRef = (0, import_react6.useRef)(void 0);
      if (!stableIdRef.current) {
        stableIdRef.current = (0, import_node_crypto4.randomUUID)();
      }
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("action", { ...props, icon: serializedIcon, stableId: stableIdRef.current });
    };
    CopyToClipboard = ({
      title = "Copy to clipboard",
      icon = "copy-clipboard" /* CopyClipboard */,
      content,
      concealed = false,
      onCopy,
      ...props
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          title,
          ...props,
          icon: "copy-clipboard" /* CopyClipboard */,
          onAction: async () => {
            Clipboard.copy(content, { concealed });
            closeMainWindow();
            onCopy?.(content);
          }
        }
      );
    };
    Paste = ({
      title = "Paste to active window",
      icon = "copy-clipboard" /* CopyClipboard */,
      content,
      onPaste,
      ...props
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          title,
          ...props,
          icon: "copy-clipboard" /* CopyClipboard */,
          onAction: async () => {
            closeMainWindow();
            Clipboard.paste(content);
            onPaste?.(content);
          }
        }
      );
    };
    Open = ({ target, app, ...props }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          ...props,
          onAction: () => {
            open(target, app);
          }
        }
      );
    };
    OpenInBrowser = ({
      url,
      title = "Open in Browser",
      ...props
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          ...props,
          title,
          onAction: async () => {
            await open(url);
            await closeMainWindow();
          }
        }
      );
    };
    ShowInFinder = ({
      path: path3,
      title = "Show in Finder",
      ...props
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          ...props,
          title,
          onAction: () => {
            showInFileBrowser(path3);
          }
        }
      );
    };
    Push = ({ target, ...props }) => {
      const { push } = useNavigation();
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ActionRoot,
        {
          ...props,
          onAction: () => {
            console.log("activate push action");
            push(target);
          }
        }
      );
    };
    SubmitForm = ({
      title = "Submit",
      ...props
    }) => {
      const stableIdRef = (0, import_react6.useRef)(void 0);
      if (!stableIdRef.current) {
        stableIdRef.current = (0, import_node_crypto4.randomUUID)();
      }
      const nativeProps = {
        ...props,
        stableId: stableIdRef.current,
        title,
        icon: props.icon ? serializeProtoImage(props.icon) : props.icon,
        onAction: () => {
        }
      };
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("action", { ...nativeProps });
    };
    CreateQuicklink = ({
      title = "Create Quicklink",
      quicklink,
      ...props
    }) => {
      const stableIdRef = (0, import_react6.useRef)(void 0);
      if (!stableIdRef.current) {
        stableIdRef.current = (0, import_node_crypto4.randomUUID)();
      }
      const nativeProps = {
        ...props,
        stableId: stableIdRef.current,
        title,
        type: "create-quicklink",
        quicklink: {
          link: quicklink.link,
          name: quicklink.name,
          application: typeof quicklink.application === "string" ? quicklink.application : quicklink.application?.name,
          icon: quicklink.icon
        },
        icon: props.icon ? serializeProtoImage(props.icon) : props.icon,
        onAction: () => {
        }
      };
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("action", { ...nativeProps });
    };
    Action = Object.assign(ActionRoot, {
      CopyToClipboard,
      Push,
      Open,
      Paste,
      SubmitForm,
      OpenInBrowser,
      ShowInFinder,
      CreateQuicklink,
      Style: {
        Regular: "regular",
        Destructive: "destructive"
      }
    });
  }
});

// ../api/src/api/hooks/use-imperative-form-handle.ts
var import_react7, import_node_crypto5, useImperativeFormHandle;
var init_use_imperative_form_handle = __esm({
  "../api/src/api/hooks/use-imperative-form-handle.ts"() {
    "use strict";
    import_react7 = __toESM(require_react());
    init_bus();
    import_node_crypto5 = require("node:crypto");
    useImperativeFormHandle = (ref) => {
      const handleId = (0, import_react7.useRef)((0, import_node_crypto5.randomUUID)());
      (0, import_react7.useImperativeHandle)(ref, () => {
        return {
          focus: () => {
            bus.emit(handleId.current, {
              type: "focus"
            });
          },
          reset: () => {
            bus.emit(handleId.current, {
              type: "reset"
            });
          }
        };
      }, []);
      return [handleId.current];
    };
  }
});

// ../api/src/api/components/form.tsx
var import_jsx_runtime10, wrapFormItemProps, FormRoot, TextField, PasswordField, DatePickerType, DatePickerRoot, DatePicker, Checkbox, DropdownRoot2, Dropdown2, TagPickerRoot, TagPickerItem, TagPicker, TextArea, FilePicker, Description, Form;
var init_form = __esm({
  "../api/src/api/components/form.tsx"() {
    "use strict";
    init_use_imperative_form_handle();
    init_image();
    init_dropdown();
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
    wrapFormItemProps = (props) => {
      return {
        ...props,
        onFocus: () => props.onFocus?.({
          type: "focus",
          target: {
            id: props.id,
            value: props.value ?? props.defaultValue
          }
        }),
        onBlur: () => props.onBlur?.({
          type: "blur",
          target: {
            id: props.id,
            value: props.value ?? props.defaultValue
          }
        })
      };
    };
    FormRoot = ({
      enableDrafts = false,
      actions,
      children,
      isLoading = false,
      navigationTitle,
      searchBarAccessory
    }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
        "form",
        {
          enableDrafts,
          isLoading,
          navigationTitle,
          children: [
            searchBarAccessory,
            children,
            actions
          ]
        }
      );
    };
    TextField = ({ ref, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("text-field", { ...wrapFormItemProps(props) });
    };
    PasswordField = ({ ref, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("password-field", { ...props });
    };
    DatePickerType = /* @__PURE__ */ ((DatePickerType2) => {
      DatePickerType2["DateTime"] = "dateTime";
      DatePickerType2["Date"] = "date";
      return DatePickerType2;
    })(DatePickerType || {});
    DatePickerRoot = ({
      ref,
      onChange,
      ...props
    }) => {
      useImperativeFormHandle(ref);
      const _onChange = onChange ? (newValue) => {
        const dateObj = newValue ? new Date(newValue) : null;
        onChange(dateObj);
      } : void 0;
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("date-picker-field", { ...wrapFormItemProps(props), onChange: _onChange });
    };
    DatePicker = Object.assign(DatePickerRoot, {
      Type: DatePickerType,
      isFullDay: (value) => {
        if (!value) return false;
        return value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0 && value.getMilliseconds() === 0;
      }
    });
    Checkbox = ({ ref, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("checkbox-field", { ...wrapFormItemProps(props) });
    };
    DropdownRoot2 = ({ ref, children, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("dropdown-field", { ...wrapFormItemProps(props), children });
    };
    Dropdown2 = Object.assign(DropdownRoot2, {
      Item: Dropdown.Item,
      Section: Dropdown.Section
    });
    TagPickerRoot = ({ children, ...props }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("tag-picker-field", { ...wrapFormItemProps(props), children });
    };
    TagPickerItem = ({ icon, ...props }) => {
      const serializedIcon = icon ? serializeProtoImage(icon) : icon;
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("tag-picker-item", { ...props, icon: serializedIcon });
    };
    TagPicker = Object.assign(TagPickerRoot, {
      Item: TagPickerItem
    });
    TextArea = ({ ref, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("text-area-field", { ...wrapFormItemProps(props) });
    };
    FilePicker = ({ ref, ...props }) => {
      useImperativeFormHandle(ref);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("file-picker-field", { ...wrapFormItemProps(props) });
    };
    Description = (props) => {
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("form-description", { ...props });
    };
    Form = Object.assign(FormRoot, {
      TextField,
      PasswordField,
      DatePicker,
      Checkbox,
      TextArea,
      Dropdown: Dropdown2,
      Description,
      TagPicker,
      FilePicker,
      Separator: () => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("separator", {}),
      LinkAccessory: ({ target, text }) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("link-accessory", { target, text })
    });
  }
});

// ../api/src/api/components/menu-bar.tsx
var import_jsx_runtime11, Root, Item2, Submenu, Section2, Separator, MenuBarExtra;
var init_menu_bar = __esm({
  "../api/src/api/components/menu-bar.tsx"() {
    "use strict";
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    Root = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("menu-bar", {});
    };
    Item2 = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("menu-bar-item", {});
    };
    Submenu = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("menu-bar-submenu", {});
    };
    Section2 = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("menu-bar-section", {});
    };
    Separator = () => {
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("separator", {});
    };
    MenuBarExtra = Object.assign(Root, {
      Item: Item2,
      Submenu,
      Section: Section2,
      Separator
    });
  }
});

// ../api/src/api/components/index.ts
var init_components = __esm({
  "../api/src/api/components/index.ts"() {
    "use strict";
    init_list();
    init_grid();
    init_detail();
    init_action_pannel();
    init_actions();
    init_form();
    init_menu_bar();
  }
});

// ../api/src/api/context/navigation-provider.tsx
var import_react8, import_jsx_runtime12, View, NavigationProvider;
var init_navigation_provider = __esm({
  "../api/src/api/context/navigation-provider.tsx"() {
    "use strict";
    import_react8 = __toESM(require_react());
    init_navigation_context();
    init_bus();
    import_jsx_runtime12 = __toESM(require_jsx_runtime());
    View = ({ children }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("view", { children });
    };
    NavigationProvider = ({ root }) => {
      const [navStack, setNavStack] = (0, import_react8.useState)([root]);
      const pendingShutdown = (0, import_react8.useRef)(false);
      const pop = () => {
        if (pendingShutdown.current) return;
        bus.request("ui.popView", {});
      };
      const push = (node) => {
        if (pendingShutdown.current) return;
        bus.request("ui.pushView", {}).then(() => {
          setNavStack((cur) => [...cur, node]);
        });
      };
      (0, import_react8.useEffect)(() => {
        if (pendingShutdown.current && navStack.length === 0) {
          process.exit(0);
        }
      }, [navStack]);
      (0, import_react8.useEffect)(() => {
        const shutdown = bus.subscribe("shutdown", () => {
          pendingShutdown.current = true;
          setNavStack([]);
        });
        const listener = bus.subscribe("pop-view", () => {
          setNavStack((cur) => cur.slice(0, -1));
        });
        return () => {
          shutdown.unsubscribe();
          listener.unsubscribe();
        };
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        navigation_context_default.Provider,
        {
          value: {
            push,
            pop
          },
          children: navStack.map((el, idx) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(View, { children: el }, idx))
        }
      );
    };
  }
});

// ../api/src/api/context/index.ts
var init_context = __esm({
  "../api/src/api/context/index.ts"() {
    "use strict";
    init_navigation_provider();
  }
});

// ../api/src/api/keyboard.ts
var Keyboard;
var init_keyboard = __esm({
  "../api/src/api/keyboard.ts"() {
    "use strict";
    ((Keyboard2) => {
      let Shortcut;
      ((Shortcut2) => {
        Shortcut2.Common = {
          Copy: "copy",
          CopyDeeplink: "copy",
          CopyName: "copy",
          CopyPath: "copy",
          Save: "save",
          Duplicate: "duplicate",
          Edit: "edit",
          MoveDown: "move-down",
          MoveUp: "move-up",
          New: "new",
          Open: "open",
          OpenWith: "open-with",
          Pin: "pin",
          Refresh: "refresh",
          Remove: "remove",
          RemoveAll: "remove-all"
        };
      })(Shortcut = Keyboard2.Shortcut || (Keyboard2.Shortcut = {}));
    })(Keyboard || (Keyboard = {}));
  }
});

// ../api/src/api/environment.ts
var LaunchType, environment;
var init_environment = __esm({
  "../api/src/api/environment.ts"() {
    "use strict";
    LaunchType = /* @__PURE__ */ ((LaunchType2) => {
      LaunchType2["UserInitiated"] = "userInitiated";
      LaunchType2["Background"] = "background";
      return LaunchType2;
    })(LaunchType || {});
    environment = globalThis.vicinae.environ;
  }
});

// ../api/src/api/cache.ts
var import_node_path, import_node_fs, import_node_crypto6, Cache;
var init_cache = __esm({
  "../api/src/api/cache.ts"() {
    "use strict";
    import_node_path = __toESM(require("node:path"));
    import_node_fs = require("node:fs");
    import_node_crypto6 = require("node:crypto");
    init_environment();
    Cache = class _Cache {
      constructor(options) {
        this.storageDir = import_node_path.default.join(environment.supportPath, _Cache.CACHE_DIR_NAME);
        this.capacity = options?.capacity ?? _Cache.DEFAULT_CACHE_SIZE;
        if (options?.namespace) {
          this.storageDir = import_node_path.default.join(this.storageDir, options.namespace);
        }
        (0, import_node_fs.mkdirSync)(this.dataDir, { recursive: true });
        this.index = this.loadIndex() ?? this.emptyIndex();
        if (this.index.revision !== this.revision) {
          this.clear();
        }
      }
      /**
       * @returns the full path to the directory where the data is stored on disk.
       * @remarks This is provided for informative purpose only. You should not attempt to mutate anything
       * in this directory by yourself. Also note that the way cache data is serialized on disk can (will) change
       * across versions.
       */
      get storageDirectory() {
        return this.storageDir;
      }
      /**
       * @returns the data for the given key, or `undefined` if there is no data.
       * @remarks To solely check for existence of a key, use {@link has}.
       */
      get = (key) => {
        const info = this.index.keys[key];
        if (!info) return void 0;
        this.updateLRU(key);
        this.syncIndex();
        return this.readKeyData(key);
      };
      /**
       * @returns `true` if data for the key exists, `false` otherwise.
       * @remarks You can use this method to check for entries without affecting the LRU access.
       */
      has = (key) => {
        return typeof this.index.keys[key] !== "undefined";
      };
      /**
       * @returns whether the cache is empty.
       */
      get isEmpty() {
        return Object.keys(this.index.keys).length === 0;
      }
      /**
       * Sets the data for the given key.
       * If the data exceeds the configured `capacity`, the least recently used entries are removed.
       * This also notifies registered subscribers (see {@link subscribe}).
       * @remarks An individual cache entry cannot be bigger than the configured capacity. If this happens, an error will be thrown.
       */
      set = (key, data) => {
        if (data.length > this.capacity) {
          throw new Error(
            `A single cache entry cannot be bigger than the total capacity of the cache. The data for key ${key} is ${data.length} bytes long while the capacity is set to ${this.capacity}. You should either reduce the amount of data stored or increase the cache's capacity.`
          );
        }
        const info = this.index.keys[key];
        const newTotalSize = this.index.size + data.length - (info?.size ?? 0);
        if (newTotalSize > this.capacity) {
          this.popLRU();
          this.set(key, data);
          return;
        }
        this.index.size = newTotalSize;
        this.index.keys[key] = { size: data.length };
        this.updateLRU(key);
        this.writeKeyData(key, data);
        this.syncIndex();
        for (const sub of this.subscribers) {
          sub(key, data);
        }
      };
      /**
       * Removes the data for the given key.
       * This also notifies registered subscribers (see {@link subscribe}).
       * @returns `true` if data for the key was removed, `false` otherwise.
       */
      remove = (key) => {
        const removed = this.removeImpl(key);
        this.syncIndex();
        return removed;
      };
      /**
       * Clears all stored data.
       * This also notifies registered subscribers (see {@link subscribe}) unless the  `notifySubscribers` option is set to `false`.
       */
      clear = (options) => {
        const notify = options?.notifySubscribers ?? true;
        this.removeCacheDirectory();
        this.initIndex();
        if (!notify) return;
        for (const key of Object.keys(this.index.keys)) {
          for (const subscriber of this.subscribers) {
            subscriber(key, void 0);
          }
        }
      };
      /**
       * Registers a new subscriber that gets notified when cache data is set or removed.
       * @returns a function that can be called to remove the subscriber.
       */
      subscribe = (subscriber) => {
        this.subscribers.push(subscriber);
        return () => {
          this.subscribers.splice(this.subscribers.indexOf(subscriber), 1);
        };
      };
      keyDataPath(key) {
        return this.dataPath(this.keyHash(key));
      }
      readKeyData(key) {
        return (0, import_node_fs.readFileSync)(this.keyDataPath(key), "utf8");
      }
      writeKeyData(key, data) {
        (0, import_node_fs.writeFileSync)(this.keyDataPath(key), data);
      }
      keyHash(key) {
        return (0, import_node_crypto6.hash)("md5", key);
      }
      get dataDir() {
        return import_node_path.default.join(this.storageDir, "data");
      }
      dataPath(id) {
        return import_node_path.default.join(this.dataDir, id);
      }
      get indexPath() {
        return import_node_path.default.join(this.storageDir, "index.json");
      }
      updateLRU(key) {
        const idx = this.index.lru.findIndex((entry) => key == entry.key);
        if (idx !== -1) this.index.lru.splice(idx, 1);
        this.index.lru.unshift({ key, lastUsedAt: Date.now() });
      }
      popLRU() {
        if (this.index.lru.length === 0) return;
        this.removeImpl(this.index.lru.pop().key);
      }
      removeImpl(key) {
        const info = this.index.keys[key];
        if (!info) return false;
        (0, import_node_fs.rmSync)(this.keyDataPath(key), { force: true });
        this.index.size -= info.size;
        delete this.index.keys[key];
        for (const sub of this.subscribers) {
          sub(key, void 0);
        }
        return true;
      }
      initIndex() {
        const index = {
          revision: this.revision,
          keys: {},
          size: 0,
          lru: []
        };
        (0, import_node_fs.mkdirSync)(this.dataDir, { recursive: true });
        const indexPath = import_node_path.default.join(this.storageDir, "index.json");
        (0, import_node_fs.writeFileSync)(indexPath, JSON.stringify(index, null, 2));
        return index;
      }
      loadIndex() {
        const indexPath = import_node_path.default.join(this.storageDir, "index.json");
        if (!(0, import_node_fs.existsSync)(indexPath)) return null;
        return JSON.parse((0, import_node_fs.readFileSync)(indexPath, "utf8"));
      }
      removeCacheDirectory() {
        (0, import_node_fs.rmSync)(this.dataDir, { recursive: true, force: true });
      }
      syncIndex() {
        (0, import_node_fs.writeFileSync)(this.indexPath, JSON.stringify(this.index, null, 2));
      }
      emptyIndex() {
        return { revision: this.revision, keys: {}, lru: [], size: 0 };
      }
      /**
       * We store this inside the cache index file in order to know
       * when a breaking change occurs.
       * If we want to change the way the data is stored we just change this,
       * which will force a full cache clear and use the new format.
       */
      revision = "1";
      capacity;
      subscribers = [];
      storageDir;
      index;
      static DEFAULT_CACHE_SIZE = 1e7;
      static CACHE_DIR_NAME = ".cache";
    };
  }
});

// ../api/src/api/toast.ts
var import_crypto2, Toast, showToast;
var init_toast = __esm({
  "../api/src/api/toast.ts"() {
    "use strict";
    import_crypto2 = require("crypto");
    init_bus();
    init_ui();
    Toast = class _Toast {
      options;
      callbacks = {};
      id;
      styleMap = {
        [_Toast.Style.Success]: 0 /* Success */,
        [_Toast.Style.Failure]: 3 /* Error */,
        [_Toast.Style.Animated]: 4 /* Dynamic */
      };
      /**
       * Deprecated - Use `showToast` instead
       */
      constructor(props) {
        this.id = `toast_${(0, import_crypto2.randomBytes)(16).toString("hex")}`;
        this.options = {
          title: props.title,
          style: props.style ?? _Toast.Style.Success,
          message: props.message
        };
        if (props.primaryAction) {
          const { onAction } = props.primaryAction;
          const { id } = bus.addEventHandler(() => onAction(this));
          this.options.primaryAction = props.primaryAction;
          this.callbacks.primary = id;
        }
        if (props.secondaryAction) {
          const { onAction } = props.secondaryAction;
          const { id } = bus.addEventHandler(() => onAction(this));
          this.options.secondaryAction = props.secondaryAction;
          this.callbacks.secondary = id;
        }
      }
      /**
       * The style of a Toast.
       */
      get style() {
        return this.options.style;
      }
      set style(style) {
        this.options.style = style;
        this.update();
      }
      /**
       * The title of a Toast. Displayed on the top.
       */
      get title() {
        return this.options.title;
      }
      set title(title) {
        this.options.title = title;
        this.update();
      }
      /**
       * An additional message for the Toast. Useful to show more information, e.g. an identifier of a newly created asset.
       */
      get message() {
        return this.options.message;
      }
      set message(message) {
        this.options.message = message;
      }
      /**
       * The primary Action the user can take when hovering on the Toast.
       */
      get primaryAction() {
        return this.options.primaryAction;
      }
      set primaryAction(action) {
        this.options.primaryAction = action;
      }
      /**
       * The secondary Action the user can take when hovering on the Toast.
       */
      get secondaryAction() {
        return this.options.secondaryAction;
      }
      set secondaryAction(action) {
        this.options.secondaryAction = action;
      }
      async update() {
        await bus.request("ui.showToast", {
          id: this.id,
          title: this.title,
          style: this.styleMap[this.style]
        });
      }
      /**
       * Shows the Toast.
       *
       * @returns A Promise that resolves when the toast is shown.
       */
      async show() {
        const payload = {
          title: this.options.title,
          message: this.options.message,
          style: this.options.style
        };
        if (this.options.primaryAction && this.callbacks.primary) {
          const { title, shortcut } = this.options.primaryAction;
          payload.primaryAction = {
            title,
            shortcut,
            onAction: this.callbacks.primary
          };
        }
        if (this.options.secondaryAction && this.callbacks.secondary) {
          const { title, shortcut } = this.options.secondaryAction;
          payload.secondaryAction = {
            title,
            shortcut,
            onAction: this.callbacks.secondary
          };
        }
        await bus.request("ui.showToast", {
          id: this.id,
          title: payload.title,
          style: this.styleMap[payload.style ?? _Toast.Style.Success]
        });
      }
      /**
       * Hides the Toast.
       *
       * @returns A Promise that resolves when toast is hidden.
       */
      async hide() {
        await bus.request("ui.hideToast", { id: this.id });
      }
    };
    ((Toast2) => {
      let Style;
      ((Style2) => {
        Style2["Success"] = "success";
        Style2["Failure"] = "failure";
        Style2["Animated"] = "animated";
      })(Style = Toast2.Style || (Toast2.Style = {}));
    })(Toast || (Toast = {}));
    showToast = async (init, title = "", message) => {
      const toast = typeof init === "string" ? new Toast({ style: init, message, title }) : new Toast(init);
      await toast.show();
      return toast;
    };
  }
});

// ../api/src/api/local-storage.ts
var LocalStorage;
var init_local_storage = __esm({
  "../api/src/api/local-storage.ts"() {
    "use strict";
    init_bus();
    ((LocalStorage2) => {
      async function getItem(key) {
        const res = await bus.request("storage.get", { key });
        if (!res.ok || res.value.value === null) {
          return void 0;
        }
        return res.value.value;
      }
      LocalStorage2.getItem = getItem;
      async function setItem(key, value) {
        await bus.request("storage.set", { key, value });
      }
      LocalStorage2.setItem = setItem;
      async function removeItem(key) {
        await bus.request("storage.remove", { key });
      }
      LocalStorage2.removeItem = removeItem;
      async function allItems() {
        const res = await bus.request("storage.list", {});
        if (!res.ok) return {};
        return res.value.values;
      }
      LocalStorage2.allItems = allItems;
      async function clear() {
        await bus.request("storage.clear", {});
      }
      LocalStorage2.clear = clear;
    })(LocalStorage || (LocalStorage = {}));
  }
});

// ../api/src/api/oauth.ts
var import_node_crypto7, OauthRedirectMethod, PKCEClient, OAuth;
var init_oauth2 = __esm({
  "../api/src/api/oauth.ts"() {
    "use strict";
    import_node_crypto7 = require("node:crypto");
    init_image();
    init_bus();
    OauthRedirectMethod = /* @__PURE__ */ ((OauthRedirectMethod2) => {
      OauthRedirectMethod2["Web"] = "web";
      OauthRedirectMethod2["App"] = "app";
      OauthRedirectMethod2["AppURI"] = "appURI";
      return OauthRedirectMethod2;
    })(OauthRedirectMethod || {});
    PKCEClient = class {
      redirectMethod;
      providerName;
      providerIcon;
      providerId;
      description;
      resolvesOnRedirect;
      isAuthorizing;
      constructor(options) {
        this.providerId = options.providerId;
        this.providerName = options.providerName;
        this.providerIcon = options.providerIcon;
        this.description = options.description;
        this.redirectMethod = options.redirectMethod;
        this.resolvesOnRedirect = false;
        this.isAuthorizing = false;
      }
      buildAuthUrl(options, state, codeChallenge, redirectURI) {
        const params = new URLSearchParams({
          response_type: "code",
          client_id: options.clientId,
          redirect_uri: redirectURI,
          scope: options.scope,
          state,
          code_challenge: codeChallenge,
          code_challenge_method: "S256",
          ...options.extraParameters
        });
        return `${options.endpoint}?${params}`;
      }
      getRedirectURI() {
        switch (this.redirectMethod) {
          case OAuth.RedirectMethod.Web:
            return "https://raycast.com/redirect?packageName=Extension";
          case OAuth.RedirectMethod.App:
            return "raycast://oauth?package_name=Extension";
          case OAuth.RedirectMethod.AppURI:
            return "com.raycast:/oauth?package_name=Extension";
        }
      }
      /**
       * Creates an authorization request for the provided authorization endpoint, client ID, and scopes.
       * You need to first create the authorization request before calling {@link OAuth.PKCEClient.authorize}.
       *
       * @remarks The generated code challenge for the PKCE request uses the S256 method.
       *
       * @returns A promise for an {@link OAuth.AuthorizationRequest} that you can use as input for {@link OAuth.PKCEClient.authorize}.
       */
      async authorizationRequest(options) {
        const codeVerifier = (0, import_node_crypto7.randomBytes)(32).toString("base64url");
        const codeChallenge = (0, import_node_crypto7.createHash)("sha256").update(codeVerifier).digest("base64url");
        const state = Buffer.from(
          JSON.stringify({
            flavor: "release",
            id: (0, import_node_crypto7.randomUUID)(),
            providerName: this.providerName
          })
        ).toString("base64url");
        const redirectURI = this.getRedirectURI();
        return {
          state,
          codeChallenge,
          codeVerifier,
          redirectURI,
          toURL: () => this.buildAuthUrl(options, state, codeChallenge, redirectURI)
        };
      }
      /**
       * Starts the authorization and shows the OAuth overlay in Raycast.
       * As parameter you can either directly use the returned request from {@link OAuth.PKCEClient.authorizationRequest},
       * or customize the URL by extracting parameters from {@link OAuth.AuthorizationRequest} and providing your own URL via {@link AuthorizationOptions}.
       * Eventually the URL will be used to open the authorization page of the provider in the web browser.
       *
       * @returns A promise for an {@link OAuth.AuthorizationResponse}, which contains the authorization code needed for the token exchange.
       * The promise is resolved when the user was redirected back from the provider's authorization page to the Raycast extension.
       */
      async authorize(options) {
        const isAuthorizationOptions = (s) => {
          return typeof s.url === "string";
        };
        const res = await bus.request("oauth.authorize", {
          client: {
            id: this.providerId,
            description: this.description ?? "Connect to your account",
            name: this.providerName,
            icon: this.providerIcon ? serializeProtoImage(this.providerIcon) : void 0
          },
          url: isAuthorizationOptions(options) ? options.url : options.toURL()
        });
        if (!res.ok) {
          throw res.error;
        }
        return { authorizationCode: res.value.code };
      }
      authorizationURL;
      /**
       * Securely stores a {@link OAuth.TokenSet} for the provider. Use this after fetching the access token from the provider.
       * If the provider returns a a standard OAuth JSON token response, you can directly pass the {@link OAuth.TokenResponse}.
       * At a minimum, you need to set the {@link OAuth.TokenSet.accessToken}, and typically you also set {@link OAuth.TokenSet.refreshToken} and {@link OAuth.TokenSet.isExpired}.
       * Raycast automatically shows a logout preference for the extension when a token set was saved.
       *
       * @remarks If you want to make use of the convenience {@link OAuth.TokenSet.isExpired} method, the property {@link OAuth.TokenSet.expiresIn} must be configured.
       *
       * @returns A promise that resolves when the token set has been stored.
       */
      async setTokens(options) {
        const isTokenResponse = (options2) => {
          return Object.hasOwn(options2, "access_token");
        };
        if (isTokenResponse(options)) {
          await bus.request("oauth.setTokens", {
            accessToken: options.access_token,
            refreshToken: options.refresh_token,
            idToken: options.id_token,
            scope: options.scope,
            expiresIn: options.expires_in,
            providerId: this.providerId
          });
        } else {
          await bus.request("oauth.setTokens", {
            ...options,
            providerId: this.providerId
          });
        }
      }
      /**
       * Retrieves the stored {@link OAuth.TokenSet} for the client.
       * You can use this to initially check whether the authorization flow should be initiated or
       * the user is already logged in and you might have to refresh the access token.
       *
       * @returns A promise that resolves when the token set has been retrieved.
       */
      async getTokens() {
        const res = await bus.request("oauth.getTokens", {
          providerId: this.providerId
        });
        const set = res.unwrap().tokenSet;
        if (!set) return void 0;
        const tokenSet = {
          accessToken: set.accessToken,
          refreshToken: set.refreshToken,
          scope: set.scope,
          idToken: set.idToken,
          updatedAt: new Date(set.updatedAt * 1e3),
          expiresIn: set.expiresIn,
          isExpired: () => {
            return !!(tokenSet.expiresIn && tokenSet.updatedAt.getTime() + tokenSet.expiresIn * 1e3 < Date.now());
          }
        };
        return tokenSet;
      }
      /**
       * Removes the stored {@link OAuth.TokenSet} for the client.
       */
      async removeTokens() {
        await bus.request("oauth.removeTokens", {
          providerId: this.providerId
        });
      }
    };
    OAuth = {
      PKCEClient,
      RedirectMethod: OauthRedirectMethod
    };
  }
});

// ../api/src/api/alert.ts
var Alert, styleMap, confirmAlert;
var init_alert = __esm({
  "../api/src/api/alert.ts"() {
    "use strict";
    init_bus();
    init_image();
    init_ui();
    ((Alert2) => {
      let ActionStyle;
      ((ActionStyle2) => {
        ActionStyle2["Default"] = "default";
        ActionStyle2["Destructive"] = "destructive";
        ActionStyle2["Cancel"] = "cancel";
      })(ActionStyle = Alert2.ActionStyle || (Alert2.ActionStyle = {}));
    })(Alert || (Alert = {}));
    styleMap = {
      ["default" /* Default */]: 0 /* Default */,
      ["destructive" /* Destructive */]: 1 /* Destructive */,
      ["cancel" /* Cancel */]: 2 /* Cancel */
    };
    confirmAlert = async (options) => {
      return new Promise((resolve) => {
        const req = ConfirmAlertRequest.create({
          title: options.title,
          description: options.message ?? "Are you sure?",
          icon: options.icon && serializeProtoImage(options.icon),
          rememberUserChoice: false,
          primaryAction: {
            title: options.primaryAction?.title ?? "Confirm",
            style: styleMap[options.primaryAction?.style ?? "default" /* Default */]
          },
          dismissAction: {
            title: options.dismissAction?.title ?? "Cancel",
            style: styleMap[options.dismissAction?.style ?? "cancel" /* Cancel */]
          }
        });
        bus.request("ui.confirmAlert", req).then((res) => {
          if (!res.ok) return false;
          if (res.value.confirmed) {
            options.primaryAction?.onAction?.();
          } else {
            options.dismissAction?.onAction?.();
          }
          resolve(res.value.confirmed);
        });
      });
    };
  }
});

// ../api/src/api/preference.ts
var getPreferenceValues, openExtensionPreferences, openCommandPreferences;
var init_preference = __esm({
  "../api/src/api/preference.ts"() {
    "use strict";
    getPreferenceValues = () => {
      return globalThis.vicinae.preferences;
    };
    openExtensionPreferences = async () => {
      console.error("openExtensionPreferences is not implemented");
    };
    openCommandPreferences = async () => {
      console.error("openCommandPreferences is not implemented");
    };
  }
});

// ../api/src/api/file-search.ts
var FileSearch;
var init_file_search2 = __esm({
  "../api/src/api/file-search.ts"() {
    "use strict";
    init_bus();
    ((FileSearch2) => {
      async function search(query, _ = {}) {
        const res = await bus.request("fileSearch.search", { query });
        return res.unwrap().files;
      }
      FileSearch2.search = search;
    })(FileSearch || (FileSearch = {}));
  }
});

// ../api/src/api/command.ts
async function updateCommandMetadata(metadata) {
  const payload = {};
  if (Object.prototype.hasOwnProperty.call(metadata, "subtitle")) {
    payload.subtitle = metadata.subtitle ?? void 0;
  }
  await bus.request("command.updateCommandMetadata", payload);
}
var init_command2 = __esm({
  "../api/src/api/command.ts"() {
    "use strict";
    init_bus();
  }
});

// ../api/src/api/index.ts
var init_api = __esm({
  "../api/src/api/index.ts"() {
    "use strict";
    init_ai();
    init_components();
    init_hooks();
    init_context();
    init_bus();
    init_color();
    init_keyboard();
    init_image();
    init_icon();
    init_environment();
    init_controls();
    init_cache();
    init_toast();
    init_clipboard2();
    init_utils();
    init_local_storage();
    init_oauth2();
    init_alert();
    init_preference();
    init_file_search2();
    init_window_management();
    init_command2();
  }
});

// ../api/src/index.ts
var src_exports = {};
__export(src_exports, {
  AI: () => AI,
  Action: () => Action,
  ActionPanel: () => ActionPanel,
  Alert: () => Alert,
  Application: () => Application,
  Cache: () => Cache,
  Clipboard: () => Clipboard,
  Color: () => Color,
  DatePickerType: () => DatePickerType,
  Detail: () => Detail,
  FileSearch: () => FileSearch,
  Form: () => Form,
  Grid: () => Grid,
  Icon: () => Icon,
  Image: () => Image2,
  Keyboard: () => Keyboard,
  LaunchType: () => LaunchType,
  List: () => List,
  LocalStorage: () => LocalStorage,
  MenuBarExtra: () => MenuBarExtra,
  NavigationProvider: () => NavigationProvider,
  OAuth: () => OAuth,
  PKCEClient: () => PKCEClient,
  PopToRootType: () => PopToRootType2,
  Toast: () => Toast,
  WindowManagement: () => WindowManagement,
  bus: () => bus,
  clearSearchBar: () => clearSearchBar,
  closeMainWindow: () => closeMainWindow,
  confirmAlert: () => confirmAlert,
  environment: () => environment,
  getApplications: () => getApplications,
  getDefaultApplication: () => getDefaultApplication,
  getFrontmostApplication: () => getFrontmostApplication,
  getPreferenceValues: () => getPreferenceValues,
  getSelectedText: () => getSelectedText,
  open: () => open,
  openCommandPreferences: () => openCommandPreferences,
  openExtensionPreferences: () => openExtensionPreferences,
  popToRoot: () => popToRoot,
  runInTerminal: () => runInTerminal,
  showHUD: () => showHUD,
  showInFileBrowser: () => showInFileBrowser,
  showToast: () => showToast,
  trash: () => trash,
  updateCommandMetadata: () => updateCommandMetadata,
  useNavigation: () => useNavigation
});
var init_src = __esm({
  "../api/src/index.ts"() {
    "use strict";
    init_api();
  }
});

// ../raycast-api-compat/src/system.ts
var transformApp, getApplications2, getDefaultApplication2, getFrontmostApplication2, captureException, showInFinder;
var init_system = __esm({
  "../raycast-api-compat/src/system.ts"() {
    "use strict";
    init_src();
    transformApp = (app) => {
      return {
        bundleId: app.id,
        name: app.name,
        path: app.path,
        localizedName: app.name,
        windowsAppId: app.id
      };
    };
    getApplications2 = async (path3) => {
      const apps = await getApplications(path3?.toString());
      return apps.map(transformApp);
    };
    getDefaultApplication2 = async (path3) => {
      return transformApp(await getDefaultApplication(path3.toString()));
    };
    getFrontmostApplication2 = async () => {
      return transformApp(await getFrontmostApplication());
    };
    captureException = (exception) => {
      console.error("captureException called on", exception);
    };
    showInFinder = (path3) => showInFileBrowser(path3);
  }
});

// ../raycast-api-compat/src/clipboard.ts
var Clipboard2;
var init_clipboard3 = __esm({
  "../raycast-api-compat/src/clipboard.ts"() {
    "use strict";
    init_src();
    ((Clipboard3) => {
      Clipboard3.copy = (content, opts) => {
        return Clipboard.copy(content, {
          concealed: opts?.concealed || opts?.transient,
          ...opts
        });
      };
      Clipboard3.paste = Clipboard.paste;
      Clipboard3.read = Clipboard.read;
      Clipboard3.readText = Clipboard.readText;
      Clipboard3.clear = Clipboard.clear;
    })(Clipboard2 || (Clipboard2 = {}));
  }
});

// ../raycast-api-compat/src/components/action-panel.tsx
var ActionPanel2;
var init_action_panel = __esm({
  "../raycast-api-compat/src/components/action-panel.tsx"() {
    "use strict";
    init_src();
    ActionPanel2 = Object.assign(ActionPanel, {
      Item: Action
    });
  }
});

// ../raycast-api-compat/src/utils.ts
var import_crypto3, randomId;
var init_utils2 = __esm({
  "../raycast-api-compat/src/utils.ts"() {
    "use strict";
    import_crypto3 = require("crypto");
    randomId = import_crypto3.randomUUID;
  }
});

// ../raycast-api-compat/src/local-storage.ts
var allLocalStorageItems, getLocalStorageItem, setLocalStorageItem, removeLocalStorageItem, clearLocalStorage;
var init_local_storage2 = __esm({
  "../raycast-api-compat/src/local-storage.ts"() {
    "use strict";
    init_src();
    init_src();
    allLocalStorageItems = LocalStorage.allItems;
    getLocalStorageItem = LocalStorage.getItem;
    setLocalStorageItem = LocalStorage.setItem;
    removeLocalStorageItem = LocalStorage.removeItem;
    clearLocalStorage = LocalStorage.clear;
  }
});

// ../raycast-api-compat/src/window-management.ts
var transformNativeDesktop, transformNativeWindow, RaycastWindowManagement, WindowManagement2;
var init_window_management2 = __esm({
  "../raycast-api-compat/src/window-management.ts"() {
    "use strict";
    init_system();
    init_src();
    transformNativeDesktop = (win) => {
      return {
        id: win.id,
        screenId: win.monitorId,
        size: { width: 0, height: 0 },
        // FIXME: implement
        active: win.active,
        type: 0 /* User */
      };
    };
    transformNativeWindow = (win) => {
      return {
        id: win.id,
        fullScreenSettable: true,
        positionable: true,
        resizable: true,
        active: win.active,
        bounds: win.bounds,
        desktopId: win.workspaceId ?? "0",
        application: win.application && transformApp(win.application)
      };
    };
    RaycastWindowManagement = class {
      async getActiveWindow() {
        const window2 = await WindowManagement.getActiveWindow();
        return transformNativeWindow(window2);
      }
      async getDesktops() {
        const workspaces = await WindowManagement.getWorkspaces();
        return workspaces.map(transformNativeDesktop);
      }
      async getWindowsOnActiveDesktop() {
        const wins = await WindowManagement.getWindowsOnActiveWorkspace();
        return wins.map(transformNativeWindow);
      }
      constructor() {
      }
    };
    WindowManagement2 = new RaycastWindowManagement();
  }
});

// ../raycast-api-compat/src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  AI: () => AI,
  Action: () => Action,
  ActionPanel: () => ActionPanel2,
  Alert: () => Alert,
  Cache: () => Cache,
  Clipboard: () => Clipboard2,
  Color: () => Color,
  Detail: () => Detail,
  Form: () => Form,
  Grid: () => Grid,
  Icon: () => Icon,
  Image: () => Image2,
  Keyboard: () => Keyboard,
  LaunchType: () => LaunchType,
  List: () => List,
  LocalStorage: () => LocalStorage,
  OAuth: () => OAuth,
  PopToRootType: () => PopToRootType2,
  Toast: () => Toast,
  WindowManagement: () => WindowManagement2,
  allLocalStorageItems: () => allLocalStorageItems,
  captureException: () => captureException,
  clearLocalStorage: () => clearLocalStorage,
  clearSearchBar: () => clearSearchBar,
  closeMainWindow: () => closeMainWindow,
  confirmAlert: () => confirmAlert,
  environment: () => environment,
  getApplications: () => getApplications2,
  getDefaultApplication: () => getDefaultApplication2,
  getFrontmostApplication: () => getFrontmostApplication2,
  getLocalStorageItem: () => getLocalStorageItem,
  getPreferenceValues: () => getPreferenceValues,
  getSelectedText: () => getSelectedText,
  open: () => open,
  openCommandPreferences: () => openCommandPreferences,
  openExtensionPreferences: () => openExtensionPreferences,
  popToRoot: () => popToRoot,
  randomId: () => randomId,
  removeLocalStorageItem: () => removeLocalStorageItem,
  setLocalStorageItem: () => setLocalStorageItem,
  showHUD: () => showHUD,
  showInFileBrowser: () => showInFileBrowser,
  showInFinder: () => showInFinder,
  showToast: () => showToast,
  updateCommandMetadata: () => updateCommandMetadata,
  useNavigation: () => useNavigation
});
var init_src2 = __esm({
  "../raycast-api-compat/src/index.ts"() {
    "use strict";
    init_src();
    init_system();
    init_clipboard3();
    init_action_panel();
    init_utils2();
    init_local_storage2();
    init_window_management2();
  }
});

// node_modules/scheduler/cjs/scheduler.production.js
var require_scheduler_production = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.js"(exports2) {
    "use strict";
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare(parent, node))
          heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
          var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap[index] = right, heap[rightIndex] = last, index = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    exports2.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      localPerformance = performance;
      exports2.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      localDate = Date, initialTime = localDate.now();
      exports2.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var localPerformance;
    var localDate;
    var initialTime;
    var taskQueue = [];
    var timerQueue = [];
    var taskIdCounter = 1;
    var currentTask = null;
    var currentPriorityLevel = 3;
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    var needsPaint = false;
    var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
    var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
    var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false;
    var taskTimeoutID = -1;
    var frameInterval = 5;
    var startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports2.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports2.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports2.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    var channel;
    var port;
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports2.unstable_now());
      }, ms);
    }
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports2.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports2.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports2.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports2.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports2.unstable_shouldYield = shouldYieldToHost;
    exports2.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (function() {
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports2.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports2.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
          }
      }
      function shouldYieldToHost() {
        return needsPaint ? true : exports2.unstable_now() - startTime < frameInterval ? false : true;
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports2.unstable_now());
        }, ms);
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      exports2.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports2.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports2.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      if ("function" === typeof localSetImmediate)
        var schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports2.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports2.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports2.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports2.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports2.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports2.unstable_shouldYield = shouldYieldToHost;
      exports2.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_scheduler_production();
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-reconciler/cjs/react-reconciler.production.js
var require_react_reconciler_production = __commonJS({
  "node_modules/react-reconciler/cjs/react-reconciler.production.js"(exports2, module2) {
    "use strict";
    module2.exports = function($$$config) {
      function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function noop() {
      }
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag))
            return tag;
          node = node.sibling;
        }
        return null;
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index$jscomp$0 || (cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, index$jscomp$0--);
      }
      function push(cursor, value) {
        index$jscomp$0++;
        valueStack[index$jscomp$0] = cursor.current;
        cursor.current = value;
      }
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;
      }
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
        root = root.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root, renderLanes2) {
        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root, updateLane) {
        root.pendingLanes |= updateLane;
        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
      }
      function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root.pendingLanes;
        root.pendingLanes = remainingLanes;
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.warmLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        root.errorRecoveryDisabledLanes &= remainingLanes;
        root.shellSuspendCounter = 0;
        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
        root.pendingLanes |= spawnedLane;
        root.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root.entangledLanes |= spawnedLane;
        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root, entangledLanes) {
        var rootEntangledLanes = root.entangledLanes |= entangledLanes;
        for (root = root.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root[index$6] & entangledLanes && (root[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$8) {
                      control = x$8;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$9) {
                    control = x$9;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        fiber = getRootHostContext(nextRootInstance);
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current, nextContext = getChildHostContext(context, fiber.type);
        context !== nextContext && (push(contextFiberStackCursor, fiber), push(contextStackCursor, nextContext));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);
      }
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber, hostContext) {
        if (!supportsHydration) throw Error(formatProdErrorMessage(175));
        hydrateInstance(
          fiber.stateNode,
          fiber.type,
          fiber.memoizedProps,
          hostContext,
          fiber
        ) || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (!supportsHydration || fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag;
        supportsSingletons ? 3 !== tag && 27 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && throwOnHydrationMismatch(fiber) : 3 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          if (!supportsHydration) throw Error(formatProdErrorMessage(316));
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
        } else
          nextHydratableInstance = supportsSingletons && 27 === tag ? getNextHydratableSiblingAfterSingleton(
            fiber.type,
            nextHydratableInstance
          ) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }
      function resetHydrationState() {
        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, isHydrating = false);
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function pushProvider(providerFiber, context, nextValue) {
        isPrimaryRenderer ? (push(valueCursor, context._currentValue), context._currentValue = nextValue) : (push(valueCursor, context._currentValue2), context._currentValue2 = nextValue);
      }
      function popProvider(context) {
        var currentValue = valueCursor.current;
        isPrimaryRenderer ? context._currentValue = currentValue : context._currentValue2 = currentValue;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          var context = currentDependencies.context;
          if (!objectIs(
            isPrimaryRenderer ? context._currentValue : context._currentValue2,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      function ensureRootIsScheduled(root) {
        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root = firstScheduledRoot; null !== root; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root,
                    root === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root, JSCompiler_inline_result));
              root = root.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root; ) {
          var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
          if (0 === nextLanes)
            root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root, currentTime) {
        for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root,
          root === currentTime ? suspendedLanes : 0,
          null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
        );
        pingedLanes = root.callbackNode;
        if (0 === suspendedLanes || root === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root.callbackPriority = currentTime;
          root.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root.callbackPriority = 2;
        root.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root.callbackNode = null, root.callbackPriority = 0, null;
        var originalCallbackNode = root.callbackNode;
        if (flushPendingEffects(true) && root.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root,
          root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root, now());
        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
      }
      function performSyncWorkOnRoot(root, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        supportsMicrotasks ? scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        }) : scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        );
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : {
          parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
          pool: cacheFromPool
        };
      }
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$1() {
      }
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$1, noop$1), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(
                        instance,
                        newState,
                        updateLane
                      );
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component2(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component2,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component2(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index);
        index = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$23 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$23 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$23 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$23 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$27) {
            onActionError(actionQueue, node, error$27);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  var markerInstance = canHydrateFormStateMarker(
                    nextHydratableInstance,
                    rootOrSingletonContext
                  );
                  if (markerInstance) {
                    nextHydratableInstance = getNextHydratableSibling(markerInstance);
                    JSCompiler_inline_result = isFormStateMarkerMatching(markerInstance);
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        var setPendingState = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        markerInstance = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = markerInstance;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          markerInstance,
          setPendingState,
          ssrFormState
        );
        markerInstance.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = {
          tag,
          create,
          deps: createDeps,
          inst,
          next: null
        };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(
          4,
          4,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(
          0 !== previousPriority && 8 > previousPriority ? previousPriority : 8
        );
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;
        }
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: NotPendingTransition,
          baseState: NotPendingTransition,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: NotPendingTransition
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root = enqueueUpdate(provider, fiber, lane);
              null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init = lazyType._init;
        return init(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(
                step,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              step.value,
              lanes
            ), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.children || []
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key)
                throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiber(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component2, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component2 = Component2.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$57 in Component2)
            void 0 === newProps[propName$57] && (newProps[propName$57] = Component2[propName$57]);
        }
        return newProps;
      }
      function logUncaughtError(root, errorInfo) {
        try {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      function logCaughtError(root, boundary, errorInfo) {
        try {
          var onCaughtError = root.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      function createRootErrorUpdate(root, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(
            createCapturedValueAtFiber(root, sourceFiber)
          ))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(
                wrapperError
              ))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component2, nextProps, renderLanes2) {
        Component2 = Component2.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component2,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component2.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component2.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component2.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component2 = Component2.compare;
          Component2 = null !== Component2 ? Component2 : shallowEqual;
          if (Component2(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component2,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
          parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
          pool: JSCompiler_inline_result
        };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component2 = renderWithHooks(
          current,
          workInProgress2,
          Component2,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component2, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component2,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component2 = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component2 && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component2.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component2(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component2.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component2.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component2.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(
            context,
            context.state,
            null
          ), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component2, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component2.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component2,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component2, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component2.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component2.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component2,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component2 = nextProps && "function" !== typeof Component2.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component2,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component2, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance)
                nextInstance = canHydrateSuspenseInstance(
                  nextInstance,
                  rootOrSingletonContext
                ), null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiber(18, null, null, 0), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance))
            JSCompiler_temp = getSuspenseInstanceFallbackErrorDetails(nextInstance).digest, nextProps = Error(formatProdErrorMessage(419)), nextProps.stack = "", nextProps.digest = JSCompiler_temp, queueHydrationError({ value: nextProps, source: null, stack: null }), workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (didReceiveUpdate || propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextInstance) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2)), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? { parent: didSuspend, pool: didSuspend } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiber(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              var nextProps = workInProgress2.pendingProps;
              init = workInProgress2.memoizedState;
              lazyComponent = init.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              nextProps = nextState.cache;
              pushProvider(workInProgress2, CacheContext, nextProps);
              nextProps !== init.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              nextProps = nextState.element;
              if (supportsHydration && init.isDehydrated)
                if (init = {
                  element: nextProps,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = init, workInProgress2.memoizedState = init, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                  break a;
                } else if (nextProps !== lazyComponent) {
                  lazyComponent = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(lazyComponent);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                  break a;
                } else
                  for (supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(
                    workInProgress2.stateNode.containerInfo
                  ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = true), renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    nextProps,
                    renderLanes2
                  ), workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              else {
                resetHydrationState();
                if (nextProps === lazyComponent) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            if (supportsResources)
              return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (workInProgress2.stateNode = createHoistableInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootInstanceStackCursor.current,
                workInProgress2
              )) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current.memoizedProps,
                workInProgress2.pendingProps,
                current.memoizedState
              ), null;
          case 27:
            if (supportsSingletons)
              return pushHostContext(workInProgress2), null === current && supportsSingletons && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootInstanceStackCursor.current,
                contextStackCursor.current,
                false
              ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getFirstHydratableChildWithinSingleton(
                workInProgress2.type,
                lazyComponent,
                nextHydratableInstance
              )), reconcileChildren(
                current,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              validateHydratableInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                contextStackCursor.current
              );
              if (init = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getFirstHydratableChild(lazyComponent), rootOrSingletonContext = false, init = true) : init = false;
              init || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init = workInProgress2.type;
            nextProps = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = nextProps.children;
            shouldSetTextContent(init, nextProps) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), isPrimaryRenderer ? HostTransitionContext._currentValue = init : HostTransitionContext._currentValue2 = init);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              validateHydratableTextInstance(
                workInProgress2.pendingProps,
                contextStackCursor.current
              );
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(
              workInProgress2,
              workInProgress2.type,
              lazyComponent.value
            ), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(
              current,
              workInProgress2,
              renderLanes2
            );
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(
              current.child,
              lazyComponent
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, nextProps = createCache(), init.pooledCache = nextProps, nextProps.refCount++, null !== nextProps && (init.pooledCacheLanes |= renderLanes2), init = nextProps), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, nextProps = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = nextProps.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function doesRequireClone(current, completedWork) {
        if (null !== current && current.child === completedWork.child) return false;
        if (0 !== (completedWork.flags & 16)) return true;
        for (current = completedWork.child; null !== current; ) {
          if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878))
            return true;
          current = current.sibling;
        }
        return false;
      }
      function appendAllChildren(parent, workInProgress2, needsVisibilityToggle, isHidden) {
        if (supportsMutation)
          for (needsVisibilityToggle = workInProgress2.child; null !== needsVisibilityToggle; ) {
            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag)
              appendInitialChild(parent, needsVisibilityToggle.stateNode);
            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {
              needsVisibilityToggle.child.return = needsVisibilityToggle;
              needsVisibilityToggle = needsVisibilityToggle.child;
              continue;
            }
            if (needsVisibilityToggle === workInProgress2) break;
            for (; null === needsVisibilityToggle.sibling; ) {
              if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress2)
                return;
              needsVisibilityToggle = needsVisibilityToggle.return;
            }
            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
            needsVisibilityToggle = needsVisibilityToggle.sibling;
          }
        else if (supportsPersistence)
          for (var node$93 = workInProgress2.child; null !== node$93; ) {
            if (5 === node$93.tag) {
              var instance = node$93.stateNode;
              needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(
                instance,
                node$93.type,
                node$93.memoizedProps
              ));
              appendInitialChild(parent, instance);
            } else if (6 === node$93.tag)
              instance = node$93.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(
                instance,
                node$93.memoizedProps
              )), appendInitialChild(parent, instance);
            else if (4 !== node$93.tag) {
              if (22 === node$93.tag && null !== node$93.memoizedState)
                instance = node$93.child, null !== instance && (instance.return = node$93), appendAllChildren(parent, node$93, true, true);
              else if (null !== node$93.child) {
                node$93.child.return = node$93;
                node$93 = node$93.child;
                continue;
              }
            }
            if (node$93 === workInProgress2) break;
            for (; null === node$93.sibling; ) {
              if (null === node$93.return || node$93.return === workInProgress2)
                return;
              node$93 = node$93.return;
            }
            node$93.sibling.return = node$93.return;
            node$93 = node$93.sibling;
          }
      }
      function appendAllChildrenToContainer(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
        var hasOffscreenComponentChild = false;
        if (supportsPersistence)
          for (var node = workInProgress2.child; null !== node; ) {
            if (5 === node.tag) {
              var instance = node.stateNode;
              needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(
                instance,
                node.type,
                node.memoizedProps
              ));
              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (6 === node.tag)
              instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(
                instance,
                node.memoizedProps
              )), appendChildToContainerChildSet(containerChildSet, instance);
            else if (4 !== node.tag) {
              if (22 === node.tag && null !== node.memoizedState)
                hasOffscreenComponentChild = node.child, null !== hasOffscreenComponentChild && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, true, true), hasOffscreenComponentChild = true;
              else if (null !== node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            }
            if (node === workInProgress2) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === workInProgress2)
                return hasOffscreenComponentChild;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        return hasOffscreenComponentChild;
      }
      function updateHostContainer(current, workInProgress2) {
        if (supportsPersistence && doesRequireClone(current, workInProgress2)) {
          current = workInProgress2.stateNode;
          var container = current.containerInfo, newChildSet = createContainerChildSet();
          appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
          current.pendingChildren = newChildSet;
          markUpdate(workInProgress2);
          finalizeContainerChildren(container, newChildSet);
        }
      }
      function updateHostComponent(current, workInProgress2, type, newProps) {
        if (supportsMutation)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else if (supportsPersistence) {
          var currentInstance = current.stateNode, oldProps$96 = current.memoizedProps;
          if ((current = doesRequireClone(current, workInProgress2)) || oldProps$96 !== newProps) {
            var currentHostContext = contextStackCursor.current;
            oldProps$96 = cloneInstance(
              currentInstance,
              type,
              oldProps$96,
              newProps,
              !current,
              null
            );
            oldProps$96 === currentInstance ? workInProgress2.stateNode = currentInstance : (finalizeInitialChildren(
              oldProps$96,
              type,
              newProps,
              currentHostContext
            ) && markUpdate(workInProgress2), workInProgress2.stateNode = oldProps$96, current ? appendAllChildren(oldProps$96, workInProgress2, false, false) : markUpdate(workInProgress2));
          } else workInProgress2.stateNode = currentInstance;
        }
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, props) {
        if (maySuspendCommit(type, props)) {
          if (workInProgress2.flags |= 16777216, !preloadInstance(type, props))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if (mayResourceSuspendCommit(resource)) {
          if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$98 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$98 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$98 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$98.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$99 = completedWork.child; null !== child$99; )
            newChildLanes |= child$99.lanes | child$99.childLanes, subtreeFlags |= child$99.subtreeFlags & 65011712, subtreeFlags |= child$99.flags & 65011712, child$99.return = completedWork, child$99 = child$99.sibling;
        else
          for (child$99 = completedWork.child; null !== child$99; )
            newChildLanes |= child$99.lanes | child$99.childLanes, subtreeFlags |= child$99.subtreeFlags, subtreeFlags |= child$99.flags, child$99.return = completedWork, child$99 = child$99.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            updateHostContainer(current, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            if (supportsResources) {
              renderLanes2 = workInProgress2.type;
              var nextResource = workInProgress2.memoizedState;
              null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2,
                newProps
              ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(
                current,
                workInProgress2,
                renderLanes2,
                newProps
              ), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2,
                newProps
              ));
              return null;
            }
          case 27:
            if (supportsSingletons) {
              popHostContext(workInProgress2);
              renderLanes2 = rootInstanceStackCursor.current;
              nextResource = workInProgress2.type;
              if (null !== current && null != workInProgress2.stateNode)
                supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(
                  current,
                  workInProgress2,
                  nextResource,
                  newProps
                );
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(formatProdErrorMessage(166));
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current = contextStackCursor.current;
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(
                  nextResource,
                  newProps,
                  renderLanes2,
                  current,
                  true
                ), workInProgress2.stateNode = current, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            }
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              updateHostComponent(current, workInProgress2, renderLanes2, newProps);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (nextResource = createInstance(
                renderLanes2,
                newProps,
                rootInstanceStackCursor.current,
                current,
                workInProgress2
              ), appendAllChildren(nextResource, workInProgress2, false, false), workInProgress2.stateNode = nextResource, finalizeInitialChildren(
                nextResource,
                renderLanes2,
                newProps,
                current
              ) && markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              renderLanes2 = current.memoizedProps, supportsMutation ? renderLanes2 !== newProps && markUpdate(workInProgress2) : supportsPersistence && (renderLanes2 !== newProps ? (workInProgress2.stateNode = createTextInstance(
                newProps,
                rootInstanceStackCursor.current,
                contextStackCursor.current,
                workInProgress2
              ), markUpdate(workInProgress2)) : workInProgress2.stateNode = current.stateNode);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              renderLanes2 = contextStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                if (!supportsHydration) throw Error(formatProdErrorMessage(176));
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                nextResource = hydrationParentFiber;
                if (null !== nextResource)
                  switch (nextResource.tag) {
                    case 27:
                    case 5:
                      newProps = nextResource.memoizedProps;
                  }
                hydrateTextInstance(
                  current,
                  renderLanes2,
                  workInProgress2,
                  newProps
                ) || throwOnHydrationMismatch(workInProgress2);
              } else
                workInProgress2.stateNode = createTextInstance(
                  newProps,
                  current,
                  renderLanes2,
                  workInProgress2
                );
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              nextResource = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!nextResource) throw Error(formatProdErrorMessage(318));
                  if (!supportsHydration) throw Error(formatProdErrorMessage(344));
                  nextResource = workInProgress2.memoizedState;
                  nextResource = null !== nextResource ? nextResource.dehydrated : null;
                  if (!nextResource) throw Error(formatProdErrorMessage(317));
                  hydrateSuspenseInstance(nextResource, workInProgress2);
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                nextResource = false;
              } else
                nextResource = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = nextResource), nextResource = true;
              if (!nextResource) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              nextResource = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool);
              var cache$113 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$113 = newProps.memoizedState.cachePool.pool);
              cache$113 !== nextResource && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), updateHostContainer(current, workInProgress2), null === current && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            nextResource = workInProgress2.memoizedState;
            if (null === nextResource)
              return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$113 = nextResource.rendering;
            if (null === cache$113)
              if (newProps) cutOffTailIfNeeded(nextResource, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$113 = findFirstSuspended(current);
                    if (null !== cache$113) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(nextResource, false);
                      current = cache$113.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== nextResource.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(nextResource, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$113), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(nextResource, true), null === nextResource.tail && "hidden" === nextResource.tailMode && !cache$113.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(nextResource, false), workInProgress2.lanes = 4194304);
              nextResource.isBackwards ? (cache$113.sibling = workInProgress2.child, workInProgress2.child = cache$113) : (current = nextResource.last, null !== current ? current.sibling = cache$113 : workInProgress2.child = cache$113, nextResource.last = cache$113);
            }
            if (null !== nextResource.tail)
              return workInProgress2 = nextResource.tail, nextResource.rendering = workInProgress2, nextResource.tail = workInProgress2.sibling, nextResource.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(
                suspenseStackCursor,
                newProps ? current & 1 | 2 : current & 1
              ), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = getPublicInstance(current.stateNode);
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$129) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$129);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          commitMount(instance, type, props, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          commitUpdate(
            finishedWork.stateNode,
            finishedWork.type,
            oldProps,
            newProps,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : false) || (supportsSingletons ? 27 === fiber.tag && isSingletonScope(fiber.type) : false) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (supportsSingletons && 27 === fiber.tag && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);
        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);
        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
        portal = portal.containerInfo;
        try {
          replaceContainerChildren(portal, pendingChildren);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          acquireSingletonInstance(
            finishedWork.type,
            props,
            singleton,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitBeforeMutationEffects(root, firstChild) {
        prepareForCommit(root.containerInfo);
        for (nextEffect = firstChild; null !== nextEffect; )
          if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1024) && null !== firstChild)
            firstChild.return = root, nextEffect = firstChild;
          else
            for (; null !== nextEffect; ) {
              root = nextEffect;
              var current = root.alternate;
              firstChild = root.flags;
              switch (root.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (firstChild & 1024) && null !== current) {
                    firstChild = void 0;
                    var finishedWork = root, prevProps = current.memoizedProps;
                    current = current.memoizedState;
                    var instance = finishedWork.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        finishedWork.type,
                        prevProps,
                        finishedWork.elementType === finishedWork.type
                      );
                      firstChild = instance.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        current
                      );
                      instance.__reactInternalSnapshotBeforeUpdate = firstChild;
                    } catch (error) {
                      captureCommitPhaseError(
                        finishedWork,
                        finishedWork.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  0 !== (firstChild & 1024) && supportsMutation && clearContainer(root.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (firstChild & 1024))
                    throw Error(formatProdErrorMessage(163));
              }
              firstChild = root.sibling;
              if (null !== firstChild) {
                firstChild.return = root.return;
                nextEffect = firstChild;
                break;
              }
              nextEffect = root.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$128) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$128
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = getPublicInstance(finishedWork.child.stateNode);
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            supportsSingletons && null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(
            finishedRoot,
            nearestMountedAncestor,
            parent
          ), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            if (supportsResources) {
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);
              break;
            }
          case 27:
            if (supportsSingletons) {
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              releaseSingletonInstance(deletedFiber.stateNode);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            }
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            if (supportsMutation) {
              if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              ), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    removeChild(hostParent, deletedFiber.stateNode);
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
            } else
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
            break;
          case 18:
            supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(
              hostParent,
              deletedFiber.stateNode
            ) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = true, recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            ), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(
              deletedFiber.stateNode,
              deletedFiber,
              createContainerChildSet()
            ), recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            commitHydratedSuspenseInstance(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root = root$jscomp$0, returnFiber = parentFiber;
            if (supportsMutation) {
              var parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (supportsSingletons) {
                      if (isSingletonScope(parent.type)) {
                        hostParent = parent.stateNode;
                        hostParentIsContainer = false;
                        break a;
                      }
                      break;
                    }
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent) throw Error(formatProdErrorMessage(160));
              commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
              hostParent = null;
              hostParentIsContainer = false;
            } else commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
            root = childToDelete.alternate;
            null !== root && (root.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      function commitMutationEffectsOnFiber(finishedWork, root) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            if (supportsResources) {
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
              if (flags & 4) {
                flags = null !== current ? current.memoizedState : null;
                var newResource = finishedWork.memoizedState;
                null === current ? null === newResource ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.memoizedProps,
                  finishedWork
                ) : mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  newResource,
                  finishedWork.memoizedProps
                ) : flags !== newResource ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === newResource ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  newResource,
                  finishedWork.memoizedProps
                )) : null === newResource && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
              }
              break;
            }
          case 27:
            if (supportsSingletons) {
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
              null !== current && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
              break;
            }
          case 5:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (supportsMutation) {
              if (finishedWork.flags & 32) {
                hoistableRoot = finishedWork.stateNode;
                try {
                  resetTextContent(hoistableRoot);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                hoistableRoot,
                null !== current ? current.memoizedProps : hoistableRoot
              ));
              flags & 1024 && (needsFormReset = true);
            }
            break;
          case 6:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && supportsMutation) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = null !== current ? current.memoizedProps : flags;
              hoistableRoot = finishedWork.stateNode;
              try {
                commitTextUpdate(hoistableRoot, current, flags);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            supportsResources ? (prepareToCommitHoistables(), hoistableRoot = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = hoistableRoot) : recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated)
                try {
                  commitHydratedContainer(root.containerInfo);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              if (supportsPersistence) {
                flags = root.containerInfo;
                current = root.pendingChildren;
                try {
                  replaceContainerChildren(flags, current);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
            }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            ), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));
            flags & 4 && supportsPersistence && commitHostPortalContainerChildren(
              finishedWork.stateNode,
              finishedWork,
              finishedWork.stateNode.pendingChildren
            );
            break;
          case 12:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation)) {
              a: if (current = null, supportsMutation)
                for (root = finishedWork; ; ) {
                  if (5 === root.tag || supportsResources && 26 === root.tag) {
                    if (null === current) {
                      wasHidden = current = root;
                      try {
                        newResource = wasHidden.stateNode, hoistableRoot ? hideInstance(newResource) : unhideInstance(
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root.tag) {
                    if (null === current) {
                      wasHidden = root;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot ? hideTextInstance(instance) : unhideTextInstance(instance, wasHidden.memoizedProps);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
                    root.child.return = root;
                    root = root.child;
                    continue;
                  }
                  if (root === finishedWork) break a;
                  for (; null === root.sibling; ) {
                    if (null === root.return || root.return === finishedWork)
                      break a;
                    current === root && (current = null);
                    root = root.return;
                  }
                  current === root && (current = null);
                  root.sibling.return = root.return;
                  root = root.sibling;
                }
            }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            if (supportsMutation) {
              for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
                if (isHostParent(parentFiber)) {
                  hostParentFiber = parentFiber;
                  break;
                }
                parentFiber = parentFiber.return;
              }
              if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
              switch (hostParentFiber.tag) {
                case 27:
                  if (supportsSingletons) {
                    var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                    insertOrAppendPlacementNode(finishedWork, before, parent);
                    break;
                  }
                case 5:
                  var parent$130 = hostParentFiber.stateNode;
                  hostParentFiber.flags & 32 && (resetTextContent(parent$130), hostParentFiber.flags &= -33);
                  var before$131 = getHostSibling(finishedWork);
                  insertOrAppendPlacementNode(finishedWork, before$131, parent$130);
                  break;
                case 3:
                case 4:
                  var parent$132 = hostParentFiber.stateNode.containerInfo, before$133 = getHostSibling(finishedWork);
                  insertOrAppendPlacementNodeIntoContainer(
                    finishedWork,
                    before$133,
                    parent$132
                  );
                  break;
                default:
                  throw Error(formatProdErrorMessage(161));
              }
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              supportsSingletons && releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              supportsSingletons && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            ) : suspendInstance(fiber.type, fiber.memoizedProps));
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);
            break;
          case 3:
          case 4:
            if (supportsResources) {
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
            } else recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      function findFiberRootForHostRoot(hostRoot) {
        var maybeFiber = getInstanceFromNode(hostRoot);
        if (null != maybeFiber) {
          if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
            throw Error(formatProdErrorMessage(364));
          return maybeFiber;
        }
        hostRoot = findFiberRoot(hostRoot);
        if (null === hostRoot) throw Error(formatProdErrorMessage(362));
        return hostRoot.stateNode.current;
      }
      function matchSelector(fiber$jscomp$0, selector) {
        var tag = fiber$jscomp$0.tag;
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            if (fiber$jscomp$0.type === selector.value) return true;
            break;
          case HAS_PSEUDO_CLASS_TYPE:
            a: {
              selector = selector.value;
              fiber$jscomp$0 = [fiber$jscomp$0, 0];
              for (tag = 0; tag < fiber$jscomp$0.length; ) {
                var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];
                if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {
                  for (; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0); )
                    selectorIndex++, selector$jscomp$0 = selector[selectorIndex];
                  if (selectorIndex === selector.length) {
                    selector = true;
                    break a;
                  } else
                    for (fiber = fiber.child; null !== fiber; )
                      fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;
                }
              }
              selector = false;
            }
            return selector;
          case ROLE_TYPE:
            if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value))
              return true;
            break;
          case TEXT_TYPE:
            if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {
              if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value))
                return true;
            }
            break;
          case TEST_NAME_TYPE:
            if (5 === tag || 26 === tag || 27 === tag) {
              if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"], "string" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
                return true;
            }
            break;
          default:
            throw Error(formatProdErrorMessage(365));
        }
        return false;
      }
      function selectorToString(selector) {
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            return "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">";
          case HAS_PSEUDO_CLASS_TYPE:
            return ":has(" + (selectorToString(selector) || "") + ")";
          case ROLE_TYPE:
            return '[role="' + selector.value + '"]';
          case TEXT_TYPE:
            return '"' + selector.value + '"';
          case TEST_NAME_TYPE:
            return '[data-testname="' + selector.value + '"]';
          default:
            throw Error(formatProdErrorMessage(365));
        }
      }
      function findPaths(root, selectors) {
        var matchingFibers = [];
        root = [root, 0];
        for (var index = 0; index < root.length; ) {
          var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];
          if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
            for (; null != selector && matchSelector(fiber, selector); )
              selectorIndex++, selector = selectors[selectorIndex];
            if (selectorIndex === selectors.length) matchingFibers.push(fiber);
            else
              for (fiber = fiber.child; null !== fiber; )
                root.push(fiber, selectorIndex), fiber = fiber.sibling;
          }
        }
        return matchingFibers;
      }
      function findAllNodes(hostRoot, selectors) {
        if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
        hostRoot = findFiberRootForHostRoot(hostRoot);
        hostRoot = findPaths(hostRoot, selectors);
        selectors = [];
        hostRoot = Array.from(hostRoot);
        for (var index = 0; index < hostRoot.length; ) {
          var node = hostRoot[index++], tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag)
            isHiddenSubtree(node) || selectors.push(node.stateNode);
          else
            for (node = node.child; null !== node; )
              hostRoot.push(node), node = node.sibling;
        }
        return selectors;
      }
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root, fiber, lane) {
        if (root === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit)
          prepareFreshStack(root, 0), markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root, lane);
        if (0 === (executionContext & 2) || root !== workInProgressRoot)
          root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = supportsHydration && root.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root.timeoutHandle = noTimeout;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
      }
      function flushSyncWork() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root, lanes) {
        var timeoutHandle = root.timeoutHandle;
        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
        timeoutHandle = root.cancelPendingCommit;
        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root;
        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$155) {
            handleThrow(root, thrownValue$155);
          }
        while (1);
        lanes && root.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;
                      if (resource ? preloadResource(resource) : preloadInstance(type, props)) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$157) {
            handleThrow(root, thrownValue$157);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(
          unitOfWork.alternate,
          unitOfWork,
          entangledRenderLanes
        );
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root,
              createCapturedValueAtFiber(thrownValue, root.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root.current)
            throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root.callbackNode = null, root.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root), resetAfterCommit(root.containerInfo);
            } finally {
              executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes));
          var remainingLanes = root.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, setCurrentUpdatePriority(remainingLanes);
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root);
          remainingLanes = root.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root, remainingLanes) {
        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;
        renderPriority = ReactSharedInternals.T;
        var previousPriority = getCurrentUpdatePriority();
        try {
          setCurrentUpdatePriority(priority);
          ReactSharedInternals.T = null;
          priority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6))
            throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            priority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root, wakeable, lanes) {
        var pingCache = root.pingCache;
        if (null === pingCache) {
          pingCache = root.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root = pingSuspendedRoot.bind(null, root, wakeable, lanes), wakeable.then(root, root));
      }
      function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
        root.warmLanes &= ~pingedLanes;
        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function shouldConstruct(Component2) {
        Component2 = Component2.prototype;
        return !(!Component2 || !Component2.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiber(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : {
          lanes: pendingProps.lanes,
          firstContext: pendingProps.firstContext
        };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = supportsResources && supportsSingletons ? isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : isHostSingletonType(type) ? 27 : 5 : supportsResources ? isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : 5 : supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiber(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(
                pendingProps.children,
                mode,
                lanes,
                key
              );
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiber(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiber(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(
                  130,
                  null === type ? "null" : typeof type,
                  ""
                )
              );
              owner = null;
          }
        key = createFiber(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiber(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiber(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiber(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = noTimeout;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiber(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function findHostInstance(component) {
        var fiber = component._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof component.render)
            throw Error(formatProdErrorMessage(188));
          component = Object.keys(component).join(",");
          throw Error(formatProdErrorMessage(268, component));
        }
        component = findCurrentFiberUsingSlowPath(fiber);
        component = null !== component ? findCurrentHostFiberImpl(component) : null;
        return null === component ? null : getPublicInstance(component.stateNode);
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      var exports3 = {};
      "use strict";
      var React6 = require_react(), Scheduler = require_scheduler(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;
      $$$config.cloneMutableInstance;
      var appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance;
      $$$config.cloneMutableTextInstance;
      var scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;
      $$$config.warnsIfNotActing;
      var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;
      $$$config.beforeActiveInstanceBlur;
      var preparePortalMount = $$$config.preparePortalMount;
      $$$config.prepareScopeUpdate;
      $$$config.getInstanceFromScope;
      var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;
      $$$config.trackSchedulerEvent;
      $$$config.resolveEventType;
      $$$config.resolveEventTimeStamp;
      var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;
      $$$config.requestPostPaintCallback;
      var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance;
      $$$config.suspendOnActiveViewTransition;
      var waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance;
      $$$config.bindToConsole;
      var supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance;
      $$$config.cancelViewTransitionName;
      $$$config.cancelRootViewTransitionName;
      $$$config.restoreRootViewTransitionName;
      $$$config.cloneRootViewTransitionContainer;
      $$$config.removeRootViewTransitionClone;
      $$$config.measureClonedInstance;
      $$$config.hasInstanceChanged;
      $$$config.hasInstanceAffectedParent;
      $$$config.startViewTransition;
      $$$config.startGestureTransition;
      $$$config.stopGestureTransition;
      $$$config.getCurrentGestureOffset;
      $$$config.subscribeToGestureDirection;
      $$$config.createViewTransitionInstance;
      var clearContainer = $$$config.clearContainer;
      $$$config.createFragmentInstance;
      $$$config.updateFragmentInstanceFiber;
      $$$config.commitNewChildToFragmentInstance;
      $$$config.deleteChildFromFragmentInstance;
      var cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getNextHydratableSiblingAfterSingleton = $$$config.getNextHydratableSiblingAfterSingleton, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton = $$$config.getFirstHydratableChildWithinSingleton, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;
      $$$config.diffHydratedPropsForDevWarnings;
      $$$config.diffHydratedTextForDevWarnings;
      $$$config.describeHydratableInstanceForDevWarnings;
      var validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, isSingletonScope = $$$config.isSingletonScope, valueStack = [], index$jscomp$0 = -1, emptyContextObject = {}, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, prefix, suffix, reentry = false, CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519)), objectIs = "function" === typeof Object.is ? Object.is : is, valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      }, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
      } }, suspendedThenable = null, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, hasForceUpdate = false, didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      }, HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            queue
          );
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "\xBB";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      }, HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      }, HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      }, thenableState = null, thenableIndexCounter = 0, reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, suspenseStackCursor = createCursor(0), classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false, SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      }, offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
      if ("function" === typeof Symbol && Symbol.for) {
        var symbolFor = Symbol.for;
        COMPONENT_TYPE = symbolFor("selector.component");
        HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
        ROLE_TYPE = symbolFor("selector.role");
        TEST_NAME_TYPE = symbolFor("selector.test_id");
        TEXT_TYPE = symbolFor("selector.text");
      }
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
      exports3.attemptContinuousHydration = function(fiber) {
        if (13 === fiber.tag) {
          var root = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      };
      exports3.attemptHydrationAtCurrentPriority = function(fiber) {
        if (13 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root && scheduleUpdateOnFiber(root, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      };
      exports3.attemptSynchronousHydration = function(fiber) {
        switch (fiber.tag) {
          case 3:
            fiber = fiber.stateNode;
            if (fiber.current.memoizedState.isDehydrated) {
              var lanes = getHighestPriorityLanes(fiber.pendingLanes);
              if (0 !== lanes) {
                fiber.pendingLanes |= 2;
                for (fiber.entangledLanes |= 2; lanes; ) {
                  var lane = 1 << 31 - clz32(lanes);
                  fiber.entanglements[1] |= lane;
                  lanes &= ~lane;
                }
                ensureRootIsScheduled(fiber);
                0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
              }
            }
            break;
          case 13:
            lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);
        }
      };
      exports3.batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports3.createComponentSelector = function(component) {
        return { $$typeof: COMPONENT_TYPE, value: component };
      };
      exports3.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {
        return createFiberRoot(
          containerInfo,
          tag,
          false,
          null,
          hydrationCallbacks,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
      };
      exports3.createHasPseudoClassSelector = function(selectors) {
        return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
      };
      exports3.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        initialChildren = createFiberRoot(
          containerInfo,
          tag,
          true,
          initialChildren,
          hydrationCallbacks,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        containerInfo = initialChildren.current;
        tag = requestUpdateLane();
        tag = getBumpedLaneForHydrationByLane(tag);
        hydrationCallbacks = createUpdate(tag);
        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;
        enqueueUpdate(containerInfo, hydrationCallbacks, tag);
        callback = tag;
        initialChildren.current.lanes = callback;
        markRootUpdated$1(initialChildren, callback);
        ensureRootIsScheduled(initialChildren);
        return initialChildren;
      };
      exports3.createPortal = function(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      };
      exports3.createRoleSelector = function(role) {
        return { $$typeof: ROLE_TYPE, value: role };
      };
      exports3.createTestNameSelector = function(id) {
        return { $$typeof: TEST_NAME_TYPE, value: id };
      };
      exports3.createTextSelector = function(text) {
        return { $$typeof: TEXT_TYPE, value: text };
      };
      exports3.defaultOnCaughtError = function(error) {
        console.error(error);
      };
      exports3.defaultOnRecoverableError = function(error) {
        reportGlobalError(error);
      };
      exports3.defaultOnUncaughtError = function(error) {
        reportGlobalError(error);
      };
      exports3.deferredUpdates = function(fn) {
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;
        }
      };
      exports3.discreteUpdates = function(fn, a, b, c, d) {
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, 0 === executionContext && (workInProgressRootRenderTargetTime = now() + 500);
        }
      };
      exports3.findAllNodes = findAllNodes;
      exports3.findBoundingRects = function(hostRoot, selectors) {
        if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
        selectors = findAllNodes(hostRoot, selectors);
        hostRoot = [];
        for (var i = 0; i < selectors.length; i++)
          hostRoot.push(getBoundingRect(selectors[i]));
        for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
          i = hostRoot[selectors];
          for (var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)
            if (selectors !== j) {
              var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
              if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                hostRoot.splice(selectors, 1);
                break;
              } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {
                otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);
                otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);
                hostRoot.splice(selectors, 1);
                break;
              } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {
                otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);
                otherRight < targetRight && (otherRect.width = targetRight - otherLeft);
                hostRoot.splice(selectors, 1);
                break;
              }
            }
        }
        return hostRoot;
      };
      exports3.findHostInstance = findHostInstance;
      exports3.findHostInstanceWithNoPortals = function(fiber) {
        fiber = findCurrentFiberUsingSlowPath(fiber);
        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
        return null === fiber ? null : getPublicInstance(fiber.stateNode);
      };
      exports3.findHostInstanceWithWarning = function(component) {
        return findHostInstance(component);
      };
      exports3.flushPassiveEffects = flushPendingEffects;
      exports3.flushSyncFromReconciler = function(fn) {
        var prevExecutionContext = executionContext;
        executionContext |= 1;
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn)
            return fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, 0 === (executionContext & 6) && flushSyncWorkAcrossRoots_impl(0, false);
        }
      };
      exports3.flushSyncWork = flushSyncWork;
      exports3.focusWithin = function(hostRoot, selectors) {
        if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
        hostRoot = findFiberRootForHostRoot(hostRoot);
        selectors = findPaths(hostRoot, selectors);
        selectors = Array.from(selectors);
        for (hostRoot = 0; hostRoot < selectors.length; ) {
          var fiber = selectors[hostRoot++], tag = fiber.tag;
          if (!isHiddenSubtree(fiber)) {
            if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode))
              return true;
            for (fiber = fiber.child; null !== fiber; )
              selectors.push(fiber), fiber = fiber.sibling;
          }
        }
        return false;
      };
      exports3.getFindAllNodesFailureDescription = function(hostRoot, selectors) {
        if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
        var maxSelectorIndex = 0, matchedNames = [];
        hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
        for (var index = 0; index < hostRoot.length; ) {
          var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];
          if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
            if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length)
              for (fiber = fiber.child; null !== fiber; )
                hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;
          }
        }
        if (maxSelectorIndex < selectors.length) {
          for (hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)
            hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
          return "findAllNodes was able to match part of the selector:\n  " + (matchedNames.join(" > ") + "\n\nNo matching component was found for:\n  ") + hostRoot.join(" > ");
        }
        return null;
      };
      exports3.getPublicRootInstance = function(container) {
        container = container.current;
        if (!container.child) return null;
        switch (container.child.tag) {
          case 27:
          case 5:
            return getPublicInstance(container.child.stateNode);
          default:
            return container.child.stateNode;
        }
      };
      exports3.injectIntoDevTools = function() {
        var internals = {
          bundleType: 0,
          version: rendererVersion,
          rendererPackageName,
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: "19.1.0"
        };
        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) internals = false;
        else {
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled || !hook.supportsFiber) internals = true;
          else {
            try {
              rendererID = hook.inject(internals), injectedHook = hook;
            } catch (err) {
            }
            internals = hook.checkDCE ? true : false;
          }
        }
        return internals;
      };
      exports3.isAlreadyRendering = function() {
        return 0 !== (executionContext & 6);
      };
      exports3.observeVisibleRects = function(hostRoot, selectors, callback, options) {
        if (!supportsTestSelectors) throw Error(formatProdErrorMessage(363));
        hostRoot = findAllNodes(hostRoot, selectors);
        var disconnect = setupIntersectionObserver(
          hostRoot,
          callback,
          options
        ).disconnect;
        return {
          disconnect: function() {
            disconnect();
          }
        };
      };
      exports3.shouldError = function() {
        return null;
      };
      exports3.shouldSuspend = function() {
        return false;
      };
      exports3.startHostTransition = function(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          NotPendingTransition,
          null === action ? noop : function() {
            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
            dispatchSetStateInternal(
              formFiber,
              resetStateQueue,
              {},
              requestUpdateLane()
            );
            return action(formData);
          }
        );
      };
      exports3.updateContainer = function(element, container, parentComponent, callback) {
        var current = container.current, lane = requestUpdateLane();
        updateContainerImpl(
          current,
          lane,
          element,
          container,
          parentComponent,
          callback
        );
        return lane;
      };
      exports3.updateContainerSync = function(element, container, parentComponent, callback) {
        updateContainerImpl(
          container.current,
          2,
          element,
          container,
          parentComponent,
          callback
        );
        return 2;
      };
      return exports3;
    };
    module2.exports.default = module2.exports;
    Object.defineProperty(module2.exports, "__esModule", { value: true });
  }
});

// node_modules/react-reconciler/cjs/react-reconciler.development.js
var require_react_reconciler_development = __commonJS({
  "node_modules/react-reconciler/cjs/react-reconciler.development.js"(exports2, module2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (module2.exports = function($$$config) {
      function findHook(fiber, id) {
        for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
          fiber = fiber.next, id--;
        return fiber;
      }
      function copyWithSetImpl(obj, path3, index, value) {
        if (index >= path3.length) return value;
        var key = path3[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        updated[key] = copyWithSetImpl(obj[key], path3, index + 1, value);
        return updated;
      }
      function copyWithRename(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length)
          console.warn("copyWithRename() expects paths of the same length");
        else {
          for (var i = 0; i < newPath.length - 1; i++)
            if (oldPath[i] !== newPath[i]) {
              console.warn(
                "copyWithRename() expects paths to be the same except for the deepest key"
              );
              return;
            }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        }
      }
      function copyWithRenameImpl(obj, oldPath, newPath, index) {
        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
          obj[oldKey],
          oldPath,
          newPath,
          index + 1
        );
        return updated;
      }
      function copyWithDeleteImpl(obj, path3, index) {
        var key = path3[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
        if (index + 1 === path3.length)
          return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
        updated[key] = copyWithDeleteImpl(obj[key], path3, index + 1);
        return updated;
      }
      function shouldSuspendImpl() {
        return false;
      }
      function shouldErrorImpl() {
        return null;
      }
      function createFiber(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function scheduleRoot(root, element) {
        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());
      }
      function scheduleRefresh(root, update) {
        if (null !== resolveFamily) {
          var staleFamilies = update.staleFamilies;
          update = update.updatedFamilies;
          flushPendingEffects();
          scheduleFibersWithFamiliesRecursively(
            root.current,
            update,
            staleFamilies
          );
          flushSyncWork();
        }
      }
      function setRefreshHandler(handler) {
        resolveFamily = handler;
      }
      function warnForMissingKey() {
      }
      function warnInvalidHookAccess() {
        console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
      }
      function warnInvalidContextAccess() {
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      }
      function noop() {
      }
      function setToSortedString(set) {
        var array = [];
        set.forEach(function(value) {
          array.push(value);
        });
        return array.sort().join(", ");
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error("Unable to find node on an unmounted component.");
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate)
            throw Error("Unable to find node on an unmounted component.");
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, _child = parentA.child; _child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              for (_child = parentB.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild)
                throw Error(
                  "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                );
            }
          }
          if (a.alternate !== b)
            throw Error(
              "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
            );
        }
        if (3 !== a.tag)
          throw Error("Unable to find node on an unmounted component.");
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiber(parent) {
        parent = findCurrentFiberUsingSlowPath(parent);
        return null !== parent ? findCurrentHostFiberImpl(parent) : null;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag))
            return tag;
          node = node.sibling;
        }
        return null;
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function getComponentNameFromFiber(fiber) {
        var type = fiber.type;
        switch (fiber.tag) {
          case 31:
            return "Activity";
          case 24:
            return "Cache";
          case 9:
            return (type._context.displayName || "Context") + ".Consumer";
          case 10:
            return (type.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 26:
          case 27:
          case 5:
            return type;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return getComponentNameFromType(type);
          case 8:
            return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 14:
          case 15:
            if ("function" === typeof type)
              return type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            break;
          case 29:
            type = fiber._debugInfo;
            if (null != type) {
              for (var i = type.length - 1; 0 <= i; i--)
                if ("string" === typeof type[i].name) return type[i].name;
            }
            if (null !== fiber.return)
              return getComponentNameFromFiber(fiber.return);
        }
        return null;
      }
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor, fiber) {
        0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
      }
      function push(cursor, value, fiber) {
        index$jscomp$0++;
        valueStack[index$jscomp$0] = cursor.current;
        fiberStack[index$jscomp$0] = fiber;
        cursor.current = value;
      }
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;
      }
      function getLabelForLane(lane) {
        if (lane & 1) return "SyncHydrationLane";
        if (lane & 2) return "Sync";
        if (lane & 4) return "InputContinuousHydration";
        if (lane & 8) return "InputContinuous";
        if (lane & 16) return "DefaultHydration";
        if (lane & 32) return "Default";
        if (lane & 128) return "TransitionHydration";
        if (lane & 4194048) return "Transition";
        if (lane & 62914560) return "Retry";
        if (lane & 67108864) return "SelectiveHydration";
        if (lane & 134217728) return "IdleHydration";
        if (lane & 268435456) return "Idle";
        if (lane & 536870912) return "Offscreen";
        if (lane & 1073741824) return "Deferred";
      }
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), lanes;
        }
      }
      function getNextLanes(root, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
        root = root.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root, renderLanes2) {
        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root, updateLane) {
        root.pendingLanes |= updateLane;
        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
      }
      function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root.pendingLanes;
        root.pendingLanes = remainingLanes;
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.warmLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        root.errorRecoveryDisabledLanes &= remainingLanes;
        root.shellSuspendCounter = 0;
        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index = 31 - clz32(remainingLanes), lane = 1 << index;
          entanglements[index] = 0;
          expirationTimes[index] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
              var update = hiddenUpdatesForLane[index];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
        root.pendingLanes |= spawnedLane;
        root.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root.entangledLanes |= spawnedLane;
        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root, entangledLanes) {
        var rootEntangledLanes = root.entangledLanes |= entangledLanes;
        for (root = root.entanglements; rootEntangledLanes; ) {
          var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
          lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function addFiberToLanesMap(root, fiber, lanes) {
        if (isDevToolsPresent)
          for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            root[index].add(fiber);
            lanes &= ~lane;
          }
      }
      function movePendingFibersToMemoized(root, lanes) {
        if (isDevToolsPresent)
          for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes; ) {
            var index = 31 - clz32(lanes);
            root = 1 << index;
            index = pendingUpdatersLaneMap[index];
            0 < index.size && (index.forEach(function(fiber) {
              var alternate = fiber.alternate;
              null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
            }), index.clear());
            lanes &= ~root;
          }
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function injectInternals(internals) {
        if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) return true;
        if (!hook.supportsFiber)
          return console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ), true;
        try {
          rendererID = hook.inject(internals), injectedHook = hook;
        } catch (err) {
          console.error("React instrumentation encountered an error: %s.", err);
        }
        return hook.checkDCE ? true : false;
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
          }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function markCommitStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
      }
      function markComponentRenderStarted(fiber) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
      }
      function markComponentRenderStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
      }
      function markRenderStarted(lanes) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
      }
      function markRenderStopped() {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
      }
      function markStateUpdateScheduled(fiber, lane) {
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
      }
      function disabledLog() {
      }
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign({}, props, { value: prevLog }),
            info: assign({}, props, { value: prevInfo }),
            warn: assign({}, props, { value: prevWarn }),
            error: assign({}, props, { value: prevError }),
            group: assign({}, props, { value: prevGroup }),
            groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do {
            info += describeFiber(workInProgress2);
            var debugInfo = workInProgress2._debugInfo;
            if (debugInfo)
              for (var i = debugInfo.length - 1; 0 <= i; i--) {
                var entry = debugInfo[i];
                if ("string" === typeof entry.name) {
                  var JSCompiler_temp_const = info, env = entry.env;
                  var JSCompiler_inline_result = describeBuiltInComponentFrame(
                    entry.name + (env ? " [" + env + "]" : "")
                  );
                  info = JSCompiler_temp_const + JSCompiler_inline_result;
                }
              }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function describeFunctionComponentFrameWithoutLineNumber(fn) {
        return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
      }
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function warnIfNotHydrating() {
        isHydrating || console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
      }
      function requiredContext(c) {
        null === c && console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        );
        return c;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor, null, fiber);
        nextRootInstance = getRootHostContext(nextRootInstance);
        pop(contextStackCursor, fiber);
        push(contextStackCursor, nextRootInstance, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        return requiredContext(contextStackCursor.current);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);
        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);
      }
      function findNotableNode(node, indent) {
        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
      }
      function indentation(indent) {
        return "  " + "  ".repeat(indent);
      }
      function added(indent) {
        return "+ " + "  ".repeat(indent);
      }
      function removed(indent) {
        return "- " + "  ".repeat(indent);
      }
      function describeFiberType(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return fiber.type;
          case 16:
            return "Lazy";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 0:
          case 15:
            return fiber = fiber.type, fiber.displayName || fiber.name || null;
          case 11:
            return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
          case 1:
            return fiber = fiber.type, fiber.displayName || fiber.name || null;
          default:
            return null;
        }
      }
      function describeTextNode(content, maxLength) {
        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
      }
      function describeTextDiff(clientText, serverProps, indent) {
        var maxLength = 120 - 2 * indent;
        if (null === serverProps)
          return added(indent) + describeTextNode(clientText, maxLength) + "\n";
        if ("string" === typeof serverProps) {
          for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
          firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
          return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
        }
        return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
      }
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      function describeValue(value, maxLength) {
        switch (typeof value) {
          case "string":
            return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
          case "object":
            if (null === value) return "null";
            if (isArrayImpl(value)) return "[...]";
            if (value.$$typeof === REACT_ELEMENT_TYPE)
              return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
            var name = objectName(value);
            if ("Object" === name) {
              name = "";
              maxLength -= 2;
              for (var propName in value)
                if (value.hasOwnProperty(propName)) {
                  var jsonPropName = JSON.stringify(propName);
                  jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                  maxLength -= propName.length - 2;
                  jsonPropName = describeValue(
                    value[propName],
                    15 > maxLength ? maxLength : 15
                  );
                  maxLength -= jsonPropName.length;
                  if (0 > maxLength) {
                    name += "" === name ? "..." : ", ...";
                    break;
                  }
                  name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                }
              return "{" + name + "}";
            }
            return name;
          case "function":
            return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
          default:
            return String(value);
        }
      }
      function describePropValue(value, maxLength) {
        return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
      }
      function describeExpandedElement(type, props, rowPrefix) {
        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
        for (propName in props)
          if (props.hasOwnProperty(propName) && "children" !== propName) {
            var propValue = describePropValue(
              props[propName],
              120 - rowPrefix.length - propName.length - 1
            );
            remainingRowLength -= propName.length + propValue.length + 2;
            properties.push(propName + "=" + propValue);
          }
        return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
      }
      function describePropertiesDiff(clientObject, serverObject, indent) {
        var properties = "", remainingServerProperties = assign({}, serverObject), propName;
        for (propName in clientObject)
          if (clientObject.hasOwnProperty(propName)) {
            delete remainingServerProperties[propName];
            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
          }
        for (var _propName in remainingServerProperties)
          remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
            remainingServerProperties[_propName],
            120 - 2 * indent - _propName.length - 2
          ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
        return properties;
      }
      function describeElementDiff(type, clientProps, serverProps, indent) {
        var content = "", serverPropNames = /* @__PURE__ */ new Map();
        for (propName$jscomp$0 in serverProps)
          serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
            propName$jscomp$0.toLowerCase(),
            propName$jscomp$0
          );
        if (1 === serverPropNames.size && serverPropNames.has("children"))
          content += describeExpandedElement(
            type,
            clientProps,
            indentation(indent)
          );
        else {
          for (var _propName2 in clientProps)
            if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
              var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
              if (void 0 !== serverPropName) {
                serverPropNames.delete(_propName2.toLowerCase());
                var propName$jscomp$0 = clientProps[_propName2];
                serverPropName = serverProps[serverPropName];
                var clientPropValue = describePropValue(
                  propName$jscomp$0,
                  maxLength$jscomp$0
                );
                maxLength$jscomp$0 = describePropValue(
                  serverPropName,
                  maxLength$jscomp$0
                );
                "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                  propName$jscomp$0,
                  serverPropName,
                  indent + 2
                ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
              } else
                content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
            }
          serverPropNames.forEach(function(propName) {
            if ("children" !== propName) {
              var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
              content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
            }
          });
          content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
        }
        type = serverProps.children;
        clientProps = clientProps.children;
        if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
          serverPropNames = "";
          if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            serverPropNames = "" + clientProps;
          content += describeTextDiff(serverPropNames, "" + type, indent + 1);
        } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
          content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
        return content;
      }
      function describeSiblingFiber(fiber, indent) {
        var type = describeFiberType(fiber);
        if (null === type) {
          type = "";
          for (fiber = fiber.child; fiber; )
            type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
          return type;
        }
        return indentation(indent) + "<" + type + ">\n";
      }
      function describeNode(node, indent) {
        var skipToNode = findNotableNode(node, indent);
        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
          return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
        skipToNode = "";
        var debugInfo = node.fiber._debugInfo;
        if (debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var serverComponentName = debugInfo[i].name;
            "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
          }
        debugInfo = "";
        i = node.fiber.pendingProps;
        if (6 === node.fiber.tag)
          debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
          if (void 0 === node.serverProps) {
            debugInfo = indent;
            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
            for (propName in i)
              if (i.hasOwnProperty(propName) && "children" !== propName) {
                var propValue = describePropValue(i[propName], 15);
                maxLength -= propName.length + propValue.length + 2;
                if (0 > maxLength) {
                  content += " ...";
                  break;
                }
                content += " " + propName + "=" + propValue;
              }
            debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
            indent++;
          } else
            null === node.serverProps ? (debugInfo = describeExpandedElement(
              serverComponentName,
              i,
              added(indent)
            ), indent++) : "string" === typeof node.serverProps ? console.error(
              "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
            ) : (debugInfo = describeElementDiff(
              serverComponentName,
              i,
              node.serverProps,
              indent
            ), indent++);
        var propName = "";
        i = node.fiber.child;
        for (serverComponentName = 0; i && serverComponentName < node.children.length; )
          maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
        i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
        i = node.serverTail;
        null === node.serverProps && indent--;
        for (node = 0; node < i.length; node++)
          serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
            serverComponentName.type,
            serverComponentName.props,
            removed(indent)
          );
        return skipToNode + debugInfo + propName;
      }
      function describeDiff(rootNode) {
        try {
          return "\n\n" + describeNode(rootNode, 0);
        } catch (x) {
          return "";
        }
      }
      function getCurrentFiberStackInDev() {
        if (null === current) return "";
        var workInProgress2 = current;
        try {
          var info = "";
          6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
          switch (workInProgress2.tag) {
            case 26:
            case 27:
            case 5:
              info += describeBuiltInComponentFrame(workInProgress2.type);
              break;
            case 13:
              info += describeBuiltInComponentFrame("Suspense");
              break;
            case 19:
              info += describeBuiltInComponentFrame("SuspenseList");
              break;
            case 31:
              info += describeBuiltInComponentFrame("Activity");
              break;
            case 30:
            case 0:
            case 15:
            case 1:
              workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress2.type
              ));
              break;
            case 11:
              workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress2.type.render
              ));
          }
          for (; workInProgress2; )
            if ("number" === typeof workInProgress2.tag) {
              var fiber = workInProgress2;
              workInProgress2 = fiber._debugOwner;
              var debugStack = fiber._debugStack;
              workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
            } else if (null != workInProgress2.debugStack) {
              var ownerStack = workInProgress2.debugStack;
              (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
            } else break;
          var JSCompiler_inline_result = info;
        } catch (x) {
          JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result;
      }
      function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
        var previousFiber = current;
        setCurrentFiber(fiber);
        try {
          return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
            callback.bind(null, arg0, arg1, arg2, arg3, arg4)
          ) : callback(arg0, arg1, arg2, arg3, arg4);
        } finally {
          setCurrentFiber(previousFiber);
        }
        throw Error(
          "runWithFiberInDEV should never be called in production. This is a bug in React."
        );
      }
      function setCurrentFiber(fiber) {
        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
        isRendering = false;
        current = fiber;
      }
      function buildHydrationDiffNode(fiber, distanceFromLeaf) {
        if (null === fiber.return) {
          if (null === hydrationDiffRootDEV)
            hydrationDiffRootDEV = {
              fiber,
              children: [],
              serverProps: void 0,
              serverTail: [],
              distanceFromLeaf
            };
          else {
            if (hydrationDiffRootDEV.fiber !== fiber)
              throw Error(
                "Saw multiple hydration diff roots in a pass. This is a bug in React."
              );
            hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
          }
          return hydrationDiffRootDEV;
        }
        var siblings = buildHydrationDiffNode(
          fiber.return,
          distanceFromLeaf + 1
        ).children;
        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
          return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
        distanceFromLeaf = {
          fiber,
          children: [],
          serverProps: void 0,
          serverTail: [],
          distanceFromLeaf
        };
        siblings.push(distanceFromLeaf);
        return distanceFromLeaf;
      }
      function warnNonHydratedInstance(fiber, rejectedCandidate) {
        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
      }
      function throwOnHydrationMismatch(fiber) {
        var diff = "", diffRoot = hydrationDiffRootDEV;
        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
        queueHydrationError(
          createCapturedValueAtFiber(
            Error(
              "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
            ),
            fiber
          )
        );
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber, hostContext) {
        if (!supportsHydration)
          throw Error(
            "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
          );
        hydrateInstance(
          fiber.stateNode,
          fiber.type,
          fiber.memoizedProps,
          hostContext,
          fiber
        ) || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (!supportsHydration || fiber !== hydrationParentFiber) return false;
        if (!isHydrating)
          return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag;
        supportsSingletons ? 3 !== tag && 27 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber)) : 3 !== tag && (5 !== tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber));
        popToNextHostParent(fiber);
        if (13 === tag) {
          if (!supportsHydration)
            throw Error(
              "Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
            );
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber)
            throw Error(
              "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
            );
          nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
        } else
          nextHydratableInstance = supportsSingletons && 27 === tag ? getNextHydratableSiblingAfterSingleton(
            fiber.type,
            nextHydratableInstance
          ) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        for (var nextInstance = nextHydratableInstance; nextInstance; ) {
          var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(nextInstance);
          diffNode.serverTail.push(description);
          nextInstance = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(nextInstance) : getNextHydratableSibling(nextInstance);
        }
      }
      function resetHydrationState() {
        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = false);
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      function emitPendingHydrationWarnings() {
        var diffRoot = hydrationDiffRootDEV;
        if (null !== diffRoot) {
          hydrationDiffRootDEV = null;
          for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
            diffRoot = diffRoot.children[0];
          runWithFiberInDEV(diffRoot.fiber, function() {
            console.error(
              "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
              "https://react.dev/link/hydration-mismatch",
              diff
            );
          });
        }
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function resetContextDependencies() {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        isDisallowedContextReadInDEV = false;
      }
      function pushProvider(providerFiber, context, nextValue) {
        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        ), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        ), context._currentRenderer2 = rendererSigil);
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);
        pop(valueCursor, providerFiber);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
        parent !== propagationRoot && console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber)
              throw Error(
                "We just came from a parent so we must have had a parent. This is a bug in React."
              );
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(
              nextFiber,
              renderLanes2,
              workInProgress2
            );
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current2 = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent)
              throw Error("Should have a current fiber. This is a bug in React.");
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent)
              throw Error("Should have a current fiber. This is a bug in React.");
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current2 && propagateContextChanges(
          workInProgress2,
          current2,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          var context = currentDependencies.context;
          if (!objectIs(
            isPrimaryRenderer ? context._currentValue : context._currentValue2,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        isDisallowedContextReadInDEV && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer)
            throw Error(
              "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
            );
          lastContextDependency = context;
          consumer.dependencies = {
            lanes: 0,
            firstContext: context,
            _debugThenableState: null
          };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function retainCache(cache) {
        cache.controller.signal.aborted && console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        );
        cache.refCount++;
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 > cache.refCount && console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        );
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      function pushNestedEffectDurations() {
        var prevEffectDuration = profilerEffectDuration;
        profilerEffectDuration = 0;
        return prevEffectDuration;
      }
      function popNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration = prevEffectDuration;
        return elapsedTime;
      }
      function bubbleNestedEffectDurations(prevEffectDuration) {
        var elapsedTime = profilerEffectDuration;
        profilerEffectDuration += prevEffectDuration;
        return elapsedTime;
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now();
        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
      }
      function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
        if (0 <= profilerStartTime) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          fiber.selfBaseDuration = elapsedTime;
          profilerStartTime = -1;
        }
      }
      function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
        if (0 <= profilerStartTime) {
          var elapsedTime = now() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          profilerStartTime = -1;
        }
      }
      function recordEffectDuration() {
        if (0 <= profilerStartTime) {
          var elapsedTime = now() - profilerStartTime;
          profilerStartTime = -1;
          profilerEffectDuration += elapsedTime;
        }
      }
      function startEffectTimer() {
        profilerStartTime = now();
      }
      function transferActualDuration(fiber) {
        for (var child = fiber.child; child; )
          fiber.actualDuration += child.actualDuration, child = child.sibling;
      }
      function ensureRootIsScheduled(root) {
        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
        mightHavePendingSyncWork = true;
        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root = firstScheduledRoot; null !== root; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root.pendingLanes;
                  if (0 === pendingLanes) var nextLanes = 0;
                  else {
                    var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
                    nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                  }
                  0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
                } else
                  nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                    root,
                    root === workInProgressRoot ? nextLanes : 0,
                    null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
                  ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
              root = root.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root; ) {
          var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
          if (0 === nextLanes)
            root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root, currentTime) {
        for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root,
          root === currentTime ? suspendedLanes : 0,
          null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
        );
        pingedLanes = root.callbackNode;
        if (0 === suspendedLanes || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit)
          return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1)
            cancelCallback(pingedLanes);
          else return currentTime;
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
          null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root.callbackPriority = currentTime;
          root.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && cancelCallback(pingedLanes);
        root.callbackPriority = 2;
        root.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root, didTimeout) {
        nestedUpdateScheduled = currentUpdateIsNested = false;
        if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
          return root.callbackNode = null, root.callbackPriority = 0, null;
        var originalCallbackNode = root.callbackNode;
        if (flushPendingEffects(true) && root.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root,
          root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(
          root,
          workInProgressRootRenderLanes$jscomp$0,
          didTimeout
        );
        scheduleTaskForRootDuringMicrotask(root, now$1());
        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
      }
      function performSyncWorkOnRoot(root, lanes) {
        if (flushPendingEffects()) return null;
        currentUpdateIsNested = nestedUpdateScheduled;
        nestedUpdateScheduled = false;
        performWorkOnRoot(root, lanes, true);
      }
      function cancelCallback(callbackNode) {
        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);
      }
      function scheduleImmediateRootScheduleTask() {
        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
          processRootScheduleInMicrotask();
          return null;
        });
        supportsMicrotasks ? scheduleMicrotask(function() {
          (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        }) : scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        );
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : {
          parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
          pool: cacheFromPool
        };
      }
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function createThenableState() {
        return { didWarnAboutUncachedPromise: false, thenables: [] };
      }
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$1() {
      }
      function trackUsedThenable(thenableState2, thenable, index) {
        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
        var trackedThenables = thenableState2.thenables;
        index = trackedThenables[index];
        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
          "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
        )), thenable.then(noop$1, noop$1), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status)
              thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(
                  "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                );
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            needsToResetSuspendedThenableDEV = true;
            throw SuspenseException;
        }
      }
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        needsToResetSuspendedThenableDEV = false;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(
            "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
          );
      }
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
          throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          );
        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        ));
        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        for (var node = sourceFiber, parent = node.return; null !== parent; )
          null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
        return 3 === node.tag ? node.stateNode : null;
      }
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        current2 = current2.updateQueue;
        workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
          baseState: current2.baseState,
          firstBaseUpdate: current2.firstBaseUpdate,
          lastBaseUpdate: current2.lastBaseUpdate,
          shared: current2.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return {
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
          var componentName2 = getComponentNameFromFiber(fiber);
          console.error(
            "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
            componentName2
          );
          didWarnUpdateInsideUpdate = true;
        }
        if ((executionContext & RenderContext) !== NoContext)
          return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
        if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current2.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current2.shared,
            callbacks: current2.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = false;
        currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current2 = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current2 && (current2 = current2.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                updateLane = workInProgress2;
                var partialState = pendingQueue;
                var nextProps = props, instance = instance$jscomp$0;
                switch (partialState.tag) {
                  case ReplaceState:
                    partialState = partialState.payload;
                    if ("function" === typeof partialState) {
                      isDisallowedContextReadInDEV = true;
                      var nextState = partialState.call(
                        instance,
                        newState,
                        nextProps
                      );
                      if (updateLane.mode & 8) {
                        setIsStrictModeForDevtools(true);
                        try {
                          partialState.call(instance, newState, nextProps);
                        } finally {
                          setIsStrictModeForDevtools(false);
                        }
                      }
                      isDisallowedContextReadInDEV = false;
                      newState = nextState;
                      break a;
                    }
                    newState = partialState;
                    break a;
                  case CaptureUpdate:
                    updateLane.flags = updateLane.flags & -65537 | 128;
                  case UpdateState:
                    nextState = partialState.payload;
                    if ("function" === typeof nextState) {
                      isDisallowedContextReadInDEV = true;
                      partialState = nextState.call(
                        instance,
                        newState,
                        nextProps
                      );
                      if (updateLane.mode & 8) {
                        setIsStrictModeForDevtools(true);
                        try {
                          nextState.call(instance, newState, nextProps);
                        } finally {
                          setIsStrictModeForDevtools(false);
                        }
                      }
                      isDisallowedContextReadInDEV = false;
                    } else partialState = nextState;
                    if (null === partialState || void 0 === partialState) break a;
                    newState = assign({}, newState, partialState);
                    break a;
                  case ForceUpdate:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current2 && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current2;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress2.lanes = lastBaseUpdate;
          workInProgress2.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(
            "Invalid argument passed as callback. Expected a function. Instead received: " + callback
          );
        callback.call(context);
      }
      function commitHiddenCallbacks(updateQueue, context) {
        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
        if (null !== hiddenCallbacks)
          for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
            callCallback(hiddenCallbacks[updateQueue], context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      function pushHiddenContext(fiber, context) {
        var prevEntangledRenderLanes = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
        push(currentTreeHiddenStackCursor, context, fiber);
        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
      }
      function reuseHiddenContextOnStack(fiber) {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
        push(
          currentTreeHiddenStackCursor,
          currentTreeHiddenStackCursor.current,
          fiber
        );
      }
      function popHiddenContext(fiber) {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor, fiber);
        pop(prevEntangledRenderLanesCursor, fiber);
      }
      function mountHookTypesDev() {
        var hookName = currentHookNameInDev;
        null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
      }
      function updateHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
            for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
              var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
              for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                oldHookName += " ";
              oldHookName += newHookName + "\n";
              table += oldHookName;
            }
            console.error(
              "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
              componentName2,
              table
            );
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          currentHookNameInDev,
          typeof deps
        );
      }
      function warnOnUseFormStateInDev() {
        var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          componentName2
        ));
      }
      function throwInvalidHookError() {
        throw Error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies) return false;
        if (null === prevDeps)
          return console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            currentHookNameInDev
          ), false;
        nextDeps.length !== prevDeps.length && console.error(
          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
          currentHookNameInDev,
          "[" + prevDeps.join(", ") + "]",
          "[" + nextDeps.join(", ") + "]"
        );
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
        if ("[object AsyncFunction]" === Object.prototype.toString.call(Component2) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component2))
          nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
            "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
            null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
          ));
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & 8) !== NoMode;
        var children = callComponentInDEV(Component2, props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
          workInProgress2,
          Component2,
          props,
          secondArg
        ));
        if (nextRenderLanes) {
          setIsStrictModeForDevtools(true);
          try {
            children = renderWithHooksAgain(
              workInProgress2,
              Component2,
              props,
              secondArg
            );
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        finishRenderingHooks(current2, workInProgress2);
        return children;
      }
      function finishRenderingHooks(current2, workInProgress2) {
        workInProgress2._debugHookTypes = hookTypesDev;
        null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
          lanes: 0,
          firstContext: null,
          _debugThenableState: thenableState$1
        }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
        hookTypesUpdateIndexDev = -1;
        null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        );
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks)
          throw Error(
            "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
          );
        null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
        current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
          "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
        )));
      }
      function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (numberOfReRenders >= RE_RENDER_LIMIT)
            throw Error(
              "Too many re-renders. React limits the number of renders to prevent an infinite loop."
            );
          numberOfReRenders += 1;
          ignorePreviousDependencies = false;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          hookTypesUpdateIndexDev = -1;
          ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
          children = callComponentInDEV(Component2, props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue;
        workInProgress2.flags = (workInProgress2.mode & 16) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
        current2.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
        hookTypesUpdateIndexDev = -1;
        currentHookNameInDev = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(
                "Update hook called on initial render. This is likely a bug in React. Please file an issue."
              );
            throw Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = createThenableState());
        thenable = trackUsedThenable(thenableState$1, thenable, index);
        index = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current2 = currentlyRenderingFiber.alternate;
          null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
            data: current2.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue || ignorePreviousDependencies)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
            updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
        else
          updateQueue.length !== size && console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            updateQueue.length,
            size
          );
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current2, reducer) {
        var queue = hook.queue;
        if (null === queue)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current2.baseQueue !== baseQueue && console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          );
          current2.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current2 = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current2);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          var nextSnapshot = getServerSnapshot();
          didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        } else {
          nextSnapshot = getSnapshot();
          didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true));
          if (null === workInProgressRoot)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
        }
        hook.memoizedState = nextSnapshot;
        getServerSnapshot = { value: nextSnapshot, getSnapshot };
        hook.queue = getServerSnapshot;
        mountEffect(
          subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
          [subscribe]
        );
        fiber.flags |= 2048;
        pushSimpleEffect(
          HasEffect | Passive,
          createEffectInstance(),
          updateStoreInstance.bind(
            null,
            fiber,
            getServerSnapshot,
            nextSnapshot,
            getSnapshot
          ),
          null
        );
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          getServerSnapshot = getServerSnapshot();
        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
          var cachedSnapshot = getSnapshot();
          objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        if (cachedSnapshot = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        ))
          hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, Passive, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function mountState(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      }
      function mountOptimistic(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      }
      function updateOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      }
      function updateOptimisticImpl(hook, current2, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function rerenderOptimistic(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber))
          throw Error("Cannot update form state while rendering.");
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        } else
          try {
            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
          } catch (error$2) {
            onActionError(actionQueue, node, error$2);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ), node.isTransition || console.error(
          "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
        )) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var isMatching = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  var markerInstance = canHydrateFormStateMarker(
                    nextHydratableInstance,
                    rootOrSingletonContext
                  );
                  if (markerInstance) {
                    nextHydratableInstance = getNextHydratableSibling(markerInstance);
                    isMatching = isFormStateMarkerMatching(markerInstance);
                    break a;
                  }
                }
                throwOnHydrationMismatch(isMatching);
              }
              isMatching = false;
            }
            isMatching && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        isMatching = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = isMatching;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          isMatching
        );
        isMatching.dispatch = ssrFormState;
        isMatching = mountStateImpl(false);
        var setPendingState = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          isMatching.queue
        );
        isMatching = mountWorkInProgressHook();
        markerInstance = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        isMatching.queue = markerInstance;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          markerInstance,
          setPendingState,
          ssrFormState
        );
        markerInstance.dispatch = ssrFormState;
        isMatching.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          HasEffect | Passive,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = {
          tag,
          create,
          deps: createDeps,
          inst,
          next: null
        };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          HasEffect | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          HasEffect | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        (currentlyRenderingFiber.mode & 16) !== NoMode && (currentlyRenderingFiber.mode & 64) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
      }
      function mountLayoutEffect(create, deps) {
        var fiberFlags = 4194308;
        (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
        return mountEffectImpl(fiberFlags, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return ref.hasOwnProperty("current") || console.error(
            "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
            "an object with keys {" + Object.keys(ref).join(", ") + "}"
          ), create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function mountImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        var fiberFlags = 4194308;
        (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
        mountEffectImpl(
          fiberFlags,
          Layout,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }
      function updateImperativeHandle(ref, create, deps) {
        "function" !== typeof create && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(
          4,
          Layout,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }
      function mountCallback(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValue(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      }
      function updateDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }
      function rerenderDeferredValue(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(
          0 !== previousPriority && 8 > previousPriority ? previousPriority : 8
        );
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane(fiber)
          );
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: NotPendingTransition,
          baseState: NotPendingTransition,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: NotPendingTransition
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function mountTransition() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      }
      function updateTransition() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }
      function rerenderTransition() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function mountId() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var treeId = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
          identifierPrefix = "\xAB" + identifierPrefix + "R" + treeId;
          treeId = localIdCounter++;
          0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
          identifierPrefix += "\xBB";
        } else
          treeId = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + treeId.toString(32) + "\xBB";
        return hook.memoizedState = identifierPrefix;
      }
      function mountRefresh() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      }
      function refreshCache(fiber, seedKey) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane(provider);
              fiber = createUpdate(lane);
              var root = enqueueUpdate(provider, fiber, lane);
              null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
              provider = createCache();
              null !== seedKey && void 0 !== seedKey && null !== root && console.error(
                "The seed argument is not enabled outside experimental channels."
              );
              fiber.payload = { cache: provider };
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var args = arguments;
        "function" === typeof args[3] && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
        args = requestUpdateLane(fiber);
        var update = {
          lane: args,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
        markStateUpdateScheduled(fiber, args);
      }
      function dispatchSetState(fiber, queue, action) {
        var args = arguments;
        "function" === typeof args[3] && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
        args = requestUpdateLane(fiber);
        dispatchSetStateInternal(fiber, queue, action, args);
        markStateUpdateScheduled(fiber, args);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender)
            throw Error("Cannot update optimistic state while rendering.");
          console.error("Cannot call startTransition while rendering.");
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
        markStateUpdateScheduled(fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      function pushDebugInfo(debugInfo) {
        var previousDebugInfo = currentDebugInfo;
        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
        return previousDebugInfo;
      }
      function validateFragmentProps(element, fiber, returnFiber) {
        for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
          var key = keys[i];
          if ("children" !== key && "key" !== key) {
            null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
            runWithFiberInDEV(
              fiber,
              function(erroredKey) {
                console.error(
                  "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                  erroredKey
                );
              },
              key
            );
            break;
          }
        }
      }
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = createThenableState());
        return trackUsedThenable(thenableState, thenable, index);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(
            'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
          );
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      function warnOnFunctionType(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
          "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
          invalidChild,
          invalidChild,
          invalidChild
        ) : console.error(
          "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
          invalidChild,
          invalidChild,
          parentName,
          invalidChild,
          parentName
        ));
      }
      function warnOnSymbolType(returnFiber, invalidChild) {
        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
          "Symbols are not valid as a React child.\n  root.render(%s)",
          invalidChild
        ) : console.error(
          "Symbols are not valid as a React child.\n  <%s>%s</%s>",
          parentName,
          invalidChild,
          parentName
        ));
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (null === current2 || 6 !== current2.tag)
            return current2 = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes
            ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, textContent);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return current2 = updateFragment(
              returnFiber,
              current2,
              element.props.children,
              lanes,
              element.key
            ), validateFragmentProps(element, current2, returnFiber), current2;
          if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
            return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
          current2 = createFiberFromElement(element, returnFiber.mode, lanes);
          coerceRef(current2, element);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
            return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, portal.children || []);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function updateFragment(returnFiber, current2, fragment, lanes, key) {
          if (null === current2 || 7 !== current2.tag)
            return current2 = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
          current2 = useFiber(current2, fragment);
          current2.return = returnFiber;
          current2._debugInfo = currentDebugInfo;
          return current2;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromElement(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
              case REACT_LAZY_TYPE:
                var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                newChild = callLazyInitInDEV(newChild);
                returnFiber = createChild(returnFiber, newChild, lanes);
                currentDebugInfo = _prevDebugInfo;
                return returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return lanes = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            if ("function" === typeof newChild.then)
              return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                returnFiber,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = _prevDebugInfo, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                ), currentDebugInfo = key, returnFiber) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                ), currentDebugInfo = key, returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
              if (null !== key) return null;
              key = pushDebugInfo(newChild._debugInfo);
              returnFiber = updateFragment(
                returnFiber,
                oldFiber,
                newChild,
                lanes,
                null
              );
              currentDebugInfo = key;
              return returnFiber;
            }
            if ("function" === typeof newChild.then)
              return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = key, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newIdx = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                ), currentDebugInfo = existingChildren, returnFiber;
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                newChild = callLazyInitInDEV(newChild);
                returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
                currentDebugInfo = _prevDebugInfo7;
                return returnFiber;
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                returnFiber,
                newIdx,
                newChild,
                lanes,
                null
              ), currentDebugInfo = existingChildren, returnFiber;
            if ("function" === typeof newChild.then)
              return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = _prevDebugInfo7, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return null;
        }
        function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
          if ("object" !== typeof child || null === child) return knownKeys;
          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(returnFiber, workInProgress2, child);
              var key = child.key;
              if ("string" !== typeof key) break;
              if (null === knownKeys) {
                knownKeys = /* @__PURE__ */ new Set();
                knownKeys.add(key);
                break;
              }
              if (!knownKeys.has(key)) {
                knownKeys.add(key);
                break;
              }
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                  key
                );
              });
              break;
            case REACT_LAZY_TYPE:
              child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            knownKeys = warnOnInvalidKey(
              returnFiber,
              newFiber,
              newChildren[newIdx],
              knownKeys
            );
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                knownKeys
              ), currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
              returnFiber,
              nextOldFiber,
              newChildren[newIdx],
              knownKeys
            ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren)
            throw Error("An iterable object provided no iterator.");
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            knownKeys = warnOnInvalidKey(
              returnFiber,
              newFiber,
              step.value,
              knownKeys
            );
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                oldFiber,
                step.value,
                knownKeys
              ), currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              step.value,
              lanes
            ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
              returnFiber,
              nextOldFiber,
              step.value,
              knownKeys
            ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          validateFragmentProps(newChild, lanes, returnFiber);
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                        currentFirstChild,
                        newChild
                      ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                }
                returnFiber = placeSingleChild(returnFiber);
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              case REACT_PORTAL_TYPE:
                a: {
                  prevDebugInfo = newChild;
                  for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === newChild)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          prevDebugInfo.children || []
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(
                    prevDebugInfo,
                    returnFiber.mode,
                    lanes
                  );
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
            }
            if (isArrayImpl(newChild))
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              ), currentDebugInfo = prevDebugInfo, returnFiber;
            if (getIteratorFn(newChild)) {
              prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              key = getIteratorFn(newChild);
              if ("function" !== typeof key)
                throw Error(
                  "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                );
              var newChildren = key.call(newChild);
              if (newChildren === newChild) {
                if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                newChild.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              returnFiber = reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChildren,
                lanes
              );
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            }
            if ("function" === typeof newChild.then)
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              ), currentDebugInfo = prevDebugInfo, returnFiber;
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
              returnFiber,
              currentFirstChild.sibling
            ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
              prevDebugInfo,
              returnFiber.mode,
              lanes
            ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
          "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
          "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          var prevDebugInfo = currentDebugInfo;
          currentDebugInfo = null;
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiber(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            var debugInfo = fiber._debugInfo = currentDebugInfo;
            fiber._debugOwner = returnFiber._debugOwner;
            fiber._debugTask = returnFiber._debugTask;
            if (null != debugInfo) {
              for (var i = debugInfo.length - 1; 0 <= i; i--)
                if ("string" === typeof debugInfo[i].stack) {
                  fiber._debugOwner = debugInfo[i];
                  fiber._debugTask = debugInfo[i].debugTask;
                  break;
                }
            }
            return fiber;
          } finally {
            currentDebugInfo = prevDebugInfo;
          }
        };
      }
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current2 = handler.alternate;
        push(
          suspenseStackCursor,
          suspenseStackCursor.current & SubtreeSuspenseContextMask,
          handler
        );
        push(suspenseHandlerStackCursor, handler, handler);
        null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
            var current2 = fiber.alternate;
            null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current, fiber);
        push(
          suspenseHandlerStackCursor,
          suspenseHandlerStackCursor.current,
          fiber
        );
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor, fiber);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor, fiber);
      }
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
        if (workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            partialState = getDerivedStateFromProps(nextProps, prevState);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
          ctor
        )));
        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
        workInProgress2.memoizedState = prevState;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
      }
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if ("function" === typeof instance.shouldComponentUpdate) {
          oldProps = instance.shouldComponentUpdate(
            newProps,
            newState,
            nextContext
          );
          if (workInProgress2.mode & 8) {
            setIsStrictModeForDevtools(true);
            try {
              oldProps = instance.shouldComponentUpdate(
                newProps,
                newState,
                nextContext
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === oldProps && console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            getComponentNameFromType(ctor) || "Component"
          );
          return oldProps;
        }
        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
          "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          workInProgress2
        )), classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ));
      }
      function resolveClassComponentProps(Component2, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component2 = Component2.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var _propName in Component2)
            void 0 === newProps[_propName] && (newProps[_propName] = Component2[_propName]);
        }
        return newProps;
      }
      function logUncaughtError(root, errorInfo) {
        try {
          componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
          errorBoundaryName = null;
          var error = errorInfo.value;
          if (null !== ReactSharedInternals.actQueue)
            ReactSharedInternals.thrownErrors.push(error);
          else {
            var onUncaughtError = root.onUncaughtError;
            onUncaughtError(error, { componentStack: errorInfo.stack });
          }
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      function logCaughtError(root, boundary, errorInfo) {
        try {
          componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
          errorBoundaryName = getComponentNameFromFiber(boundary);
          var onCaughtError = root.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      function createRootErrorUpdate(root, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        lane.payload = { element: null };
        lane.callback = function() {
          runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = CaptureUpdate;
        return lane;
      }
      function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root,
              fiber,
              errorInfo
            );
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          callComponentDidCatchInDEV(this, errorInfo);
          "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
            "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
            getComponentNameFromFiber(fiber) || "Unknown"
          );
        });
      }
      function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          isHydrating && (didSuspendOrErrorDEV = true);
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
            }
            throw Error(
              "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
            );
          }
          attachPingListener(root, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                { cause: value }
              ),
              sourceFiber
            )
          )) : (value !== HydrationMismatchException && queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                { cause: value }
              ),
              sourceFiber
            )
          ), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
        var error = createCapturedValueAtFiber(
          Error(
            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
            { cause: value }
          ),
          sourceFiber
        );
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root
              ), enqueueCapturedUpdate(sourceFiber, root), false;
            case 1:
              if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current2.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
        Component2 = Component2.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        markComponentRenderStarted(workInProgress2);
        nextProps = renderWithHooks(
          current2,
          workInProgress2,
          Component2,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
        if (null === current2) {
          var type = Component2.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component2.compare)
            return Component2 = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component2, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
              current2,
              workInProgress2,
              Component2,
              nextProps,
              renderLanes2
            );
          current2 = createFiberFromTypeAndProps(
            Component2.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        type = current2.child;
        if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component2 = Component2.compare;
          Component2 = null !== Component2 ? Component2 : shallowEqual;
          if (Component2(prevProps, nextProps) && current2.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
        }
        workInProgress2.flags |= 1;
        current2 = createWorkInProgress(type, nextProps);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
        if (null !== current2) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
              0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current2,
          workInProgress2,
          Component2,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current2) {
              nextChildren = workInProgress2.child = current2.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current2,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current2,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
          parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
          pool: JSCompiler_inline_result
        };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current2 && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack(workInProgress2);
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(
              "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
            );
          if (null === current2 || current2.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
        if (Component2.prototype && "function" === typeof Component2.prototype.render) {
          var componentName2 = getComponentNameFromType(Component2) || "Unknown";
          didWarnAboutBadClass[componentName2] || (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName2,
            componentName2
          ), didWarnAboutBadClass[componentName2] = true);
        }
        workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress2,
          null
        );
        null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component2.contextTypes && (componentName2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
          componentName2
        ))));
        prepareToReadContext(workInProgress2);
        markComponentRenderStarted(workInProgress2);
        Component2 = renderWithHooks(
          current2,
          workInProgress2,
          Component2,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, Component2, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current2, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        markComponentRenderStarted(workInProgress2);
        hookTypesUpdateIndexDev = -1;
        ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component2,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current2, workInProgress2);
        Component2 = checkDidRenderIdHook();
        markComponentRenderStopped();
        if (null !== current2 && !didReceiveUpdate)
          return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        isHydrating && Component2 && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
        switch (shouldErrorImpl(workInProgress2)) {
          case false:
            var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
              workInProgress2.memoizedProps,
              _instance.context
            ).state;
            _instance.updater.enqueueSetState(_instance, state, null);
            break;
          case true:
            workInProgress2.flags |= 128;
            workInProgress2.flags |= 65536;
            _instance = Error("Simulated error coming from DevTools");
            var lane = renderLanes2 & -renderLanes2;
            workInProgress2.lanes |= lane;
            state = workInProgressRoot;
            if (null === state)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            lane = createClassErrorUpdate(lane);
            initializeClassErrorUpdate(
              lane,
              state,
              workInProgress2,
              createCapturedValueAtFiber(_instance, workInProgress2)
            );
            enqueueCapturedUpdate(workInProgress2, lane);
        }
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          state = emptyContextObject;
          _instance = Component2.contextType;
          "contextType" in Component2 && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component2) && (didWarnAboutInvalidateContextType.add(Component2), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            getComponentNameFromType(Component2) || "Component",
            lane
          ));
          "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
          _instance = new Component2(nextProps, state);
          if (workInProgress2.mode & 8) {
            setIsStrictModeForDevtools(true);
            try {
              _instance = new Component2(nextProps, state);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
          _instance.updater = classComponentUpdater;
          workInProgress2.stateNode = _instance;
          _instance._reactInternals = workInProgress2;
          _instance._reactInternalInstance = fakeInternalInstance;
          "function" === typeof Component2.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component2) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
            "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
            state,
            null === _instance.state ? "null" : "undefined",
            state
          )));
          if ("function" === typeof Component2.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
            var foundWillUpdateName = lane = state = null;
            "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
            "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
            "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
            if (null !== state || null !== lane || null !== foundWillUpdateName) {
              _instance = getComponentNameFromType(Component2) || "Component";
              var newApiName = "function" === typeof Component2.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                _instance,
                newApiName,
                null !== state ? "\n  " + state : "",
                null !== lane ? "\n  " + lane : "",
                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
              ));
            }
          }
          _instance = workInProgress2.stateNode;
          state = getComponentNameFromType(Component2) || "Component";
          _instance.render || (Component2.prototype && "function" === typeof Component2.prototype.render ? console.error(
            "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
            state
          ) : console.error(
            "No `render` method found on the %s instance: you may have forgotten to define `render`.",
            state
          ));
          !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            state
          );
          _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            state
          );
          _instance.contextType && console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            state
          );
          Component2.childContextTypes && !didWarnAboutChildContextTypes.has(Component2) && (didWarnAboutChildContextTypes.add(Component2), console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            state
          ));
          Component2.contextTypes && !didWarnAboutContextTypes$1.has(Component2) && (didWarnAboutContextTypes$1.add(Component2), console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            state
          ));
          "function" === typeof _instance.componentShouldUpdate && console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            state
          );
          Component2.prototype && Component2.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            getComponentNameFromType(Component2) || "A pure component"
          );
          "function" === typeof _instance.componentDidUnmount && console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            state
          );
          "function" === typeof _instance.componentDidReceiveProps && console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            state
          );
          "function" === typeof _instance.componentWillRecieveProps && console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            state
          );
          "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            state
          );
          lane = _instance.props !== nextProps;
          void 0 !== _instance.props && lane && console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            state
          );
          _instance.defaultProps && console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            state,
            state
          );
          "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component2) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component2), console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            getComponentNameFromType(Component2)
          ));
          "function" === typeof _instance.getDerivedStateFromProps && console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
          "function" === typeof _instance.getDerivedStateFromError && console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
          "function" === typeof Component2.getSnapshotBeforeUpdate && console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            state
          );
          (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
          "function" === typeof _instance.getChildContext && "object" !== typeof Component2.childContextTypes && console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            state
          );
          _instance = workInProgress2.stateNode;
          _instance.props = nextProps;
          _instance.state = workInProgress2.memoizedState;
          _instance.refs = {};
          initializeUpdateQueue(workInProgress2);
          state = Component2.contextType;
          _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
          _instance.state === nextProps && (state = getComponentNameFromType(Component2) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
            "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
            state
          )));
          workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            _instance
          );
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
            workInProgress2,
            _instance
          );
          _instance.state = workInProgress2.memoizedState;
          state = Component2.getDerivedStateFromProps;
          "function" === typeof state && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            state,
            nextProps
          ), _instance.state = workInProgress2.memoizedState);
          "function" === typeof Component2.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
            "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            getComponentNameFromFiber(workInProgress2) || "Component"
          ), classComponentUpdater.enqueueReplaceState(
            _instance,
            _instance.state,
            null
          )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
          "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
          (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728);
          _instance = true;
        } else if (null === current2) {
          _instance = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps;
          lane = resolveClassComponentProps(Component2, unresolvedOldProps);
          _instance.props = lane;
          var oldContext = _instance.context;
          foundWillUpdateName = Component2.contextType;
          state = emptyContextObject;
          "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
          newApiName = Component2.getDerivedStateFromProps;
          foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
            workInProgress2,
            _instance,
            nextProps,
            state
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          _instance.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            newApiName,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component2,
            lane,
            nextProps,
            oldState,
            oldContext,
            state
          )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
        } else {
          _instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          state = workInProgress2.memoizedProps;
          foundWillUpdateName = resolveClassComponentProps(Component2, state);
          _instance.props = foundWillUpdateName;
          newApiName = workInProgress2.pendingProps;
          oldState = _instance.context;
          oldContext = Component2.contextType;
          lane = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
          unresolvedOldProps = Component2.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
            workInProgress2,
            _instance,
            nextProps,
            lane
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          _instance.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component2,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component2,
            foundWillUpdateName,
            nextProps,
            oldState,
            newState,
            lane
          ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            lane
          )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
        }
        lane = _instance;
        markRef(current2, workInProgress2);
        state = 0 !== (workInProgress2.flags & 128);
        if (lane || state) {
          lane = workInProgress2.stateNode;
          setCurrentFiber(workInProgress2);
          if (state && "function" !== typeof Component2.getDerivedStateFromError)
            Component2 = null, profilerStartTime = -1;
          else {
            markComponentRenderStarted(workInProgress2);
            Component2 = callRenderInDEV(lane);
            if (workInProgress2.mode & 8) {
              setIsStrictModeForDevtools(true);
              try {
                callRenderInDEV(lane);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            markComponentRenderStopped();
          }
          workInProgress2.flags |= 1;
          null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            current2.child,
            null,
            renderLanes2
          ), workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            Component2,
            renderLanes2
          )) : reconcileChildren(current2, workInProgress2, Component2, renderLanes2);
          workInProgress2.memoizedState = lane.state;
          current2 = workInProgress2.child;
        } else
          current2 = bailoutOnAlreadyFinishedWork(
            current2,
            workInProgress2,
            renderLanes2
          );
        renderLanes2 = workInProgress2.stateNode;
        _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
          "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
          getComponentNameFromFiber(workInProgress2) || "a component"
        ), didWarnAboutReassigningProps = true);
        return current2;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function validateFunctionComponentInDev(workInProgress2, Component2) {
        Component2 && Component2.childContextTypes && console.error(
          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
          Component2.displayName || Component2.name || "Component"
        );
        "function" === typeof Component2.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
          "%s: Function components do not support getDerivedStateFromProps.",
          workInProgress2
        ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
        "object" === typeof Component2.contextType && null !== Component2.contextType && (Component2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component2] || (console.error(
          "%s: Function components do not support contextType.",
          Component2
        ), didWarnAboutContextTypeOnFunctionComponent[Component2] = true));
      }
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
        current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
        return current2;
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
        var showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current2) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(
                nextInstance,
                rootOrSingletonContext
              ), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                dehydrated: JSCompiler_temp$jscomp$0,
                treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress2, workInProgress2.child = didSuspend, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);
              JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress2, nextInstance), throwOnHydrationMismatch(workInProgress2));
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current2.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          ), isSuspenseInstanceFallback(nextInstance))
            nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(
              "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
            ), showFallback.stack = nextProps || "", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {
              value: showFallback,
              source: null,
              stack: JSCompiler_temp
            }, "string" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2
            );
          else if (didReceiveUpdate || propagateParentContextChanges(
            current2,
            workInProgress2,
            renderLanes2,
            false
          ), JSCompiler_temp = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current2, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current2, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextInstance) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2)), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current2.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current2.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? { parent: didSuspend, pool: didSuspend } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current2,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current2.child;
        current2 = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current2 && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_temp.push(current2));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiber(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        current2 = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current2.flags |= 2;
        workInProgress2.memoizedState = null;
        return current2;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(
          fiber.return,
          renderLanes2,
          propagationRoot
        );
      }
      function validateSuspenseListNestedChild(childSlot, index) {
        var isAnArray = isArrayImpl(childSlot);
        childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
        return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
          "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
          isAnArray,
          index,
          isAnArray
        ), false) : true;
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
          if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
            switch (revealOrder.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                  revealOrder,
                  revealOrder.toLowerCase()
                );
                break;
              case "forward":
              case "backward":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                  revealOrder,
                  revealOrder.toLowerCase()
                );
                break;
              default:
                console.error(
                  '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                  revealOrder
                );
            }
          else
            console.error(
              '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
              revealOrder
            );
        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
          '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
          tailMode
        )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
          '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
          tailMode
        )));
        a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
          if (isArrayImpl(nextProps))
            for (var i = 0; i < nextProps.length; i++) {
              if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
            }
          else if (i = getIteratorFn(nextProps), "function" === typeof i) {
            if (i = i.call(nextProps))
              for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                _i++;
              }
          } else
            console.error(
              'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
              revealOrder
            );
        reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & ForceSuspenseFallback))
          nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
        else {
          if (null !== current2 && 0 !== (current2.flags & 128))
            a: for (current2 = workInProgress2.child; null !== current2; ) {
              if (13 === current2.tag)
                null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
                  current2,
                  renderLanes2,
                  workInProgress2
                );
              else if (19 === current2.tag)
                scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
              else if (null !== current2.child) {
                current2.child.return = current2;
                current2 = current2.child;
                continue;
              }
              if (current2 === workInProgress2) break a;
              for (; null === current2.sibling; ) {
                if (null === current2.return || current2.return === workInProgress2)
                  break a;
                current2 = current2.return;
              }
              current2.sibling.return = current2.return;
              current2 = current2.sibling;
            }
          nextProps &= SubtreeSuspenseContextMask;
        }
        push(suspenseStackCursor, nextProps, workInProgress2);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current2 = revealOrder.alternate;
              if (null !== current2 && null === findFirstSuspended(current2)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current2 = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current2;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        null !== current2 && (workInProgress2.dependencies = current2.dependencies);
        profilerStartTime = -1;
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current2) {
            if (propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current2 && workInProgress2.child !== current2.child)
          throw Error("Resuming work not yet implemented.");
        if (null !== workInProgress2.child) {
          current2 = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
            current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        if (0 !== (current2.lanes & renderLanes2)) return true;
        current2 = current2.dependencies;
        return null !== current2 && checkIfContextChanged(current2) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            pushProvider(
              workInProgress2,
              CacheContext,
              current2.memoizedState.cache
            );
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 12:
            0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
            workInProgress2.flags |= 2048;
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = -0;
            stateNode.passiveEffectDuration = -0;
            break;
          case 13:
            stateNode = workInProgress2.memoizedState;
            if (null !== stateNode) {
              if (null !== stateNode.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current2 = bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
              return null !== current2 ? current2.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current2.flags & 128);
            stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
            stateNode || (propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (stateNode)
                return updateSuspenseListComponent(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(
              suspenseStackCursor,
              suspenseStackCursor.current,
              workInProgress2
            );
            if (stateNode) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          case 24:
            pushProvider(
              workInProgress2,
              CacheContext,
              current2.memoizedState.cache
            );
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        if (workInProgress2._debugNeedsRemount && null !== current2) {
          renderLanes2 = createFiberFromTypeAndProps(
            workInProgress2.type,
            workInProgress2.key,
            workInProgress2.pendingProps,
            workInProgress2._debugOwner || null,
            workInProgress2.mode,
            workInProgress2.lanes
          );
          renderLanes2._debugStack = workInProgress2._debugStack;
          renderLanes2._debugTask = workInProgress2._debugTask;
          var returnFiber = workInProgress2.return;
          if (null === returnFiber) throw Error("Cannot swap the root fiber.");
          current2.alternate = null;
          workInProgress2.alternate = null;
          renderLanes2.index = workInProgress2.index;
          renderLanes2.sibling = workInProgress2.sibling;
          renderLanes2.return = workInProgress2.return;
          renderLanes2.ref = workInProgress2.ref;
          renderLanes2._debugInfo = workInProgress2._debugInfo;
          if (workInProgress2 === returnFiber.child)
            returnFiber.child = renderLanes2;
          else {
            var prevSibling = returnFiber.child;
            if (null === prevSibling)
              throw Error("Expected parent to have a child.");
            for (; prevSibling.sibling !== workInProgress2; )
              if (prevSibling = prevSibling.sibling, null === prevSibling)
                throw Error("Expected to find the previous sibling.");
            prevSibling.sibling = renderLanes2;
          }
          workInProgress2 = returnFiber.deletions;
          null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
          renderLanes2.flags |= 2;
          return renderLanes2;
        }
        if (null !== current2)
          if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current2,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
          }
        else {
          didReceiveUpdate = false;
          if (returnFiber = isHydrating)
            warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
          returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
        }
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                current2,
                returnFiber
              ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current2,
                returnFiber,
                renderLanes2
              )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current2,
                returnFiber,
                renderLanes2
              ));
            else {
              if (void 0 !== current2 && null !== current2) {
                if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                } else if (prevSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = "";
              null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              current2 = getComponentNameFromType(current2) || current2;
              throw Error(
                "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
              );
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
              returnFiber,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current2,
              workInProgress2,
              returnFiber,
              prevSibling,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current2)
                throw Error(
                  "Should have a current fiber. This is a bug in React."
                );
              var nextProps = workInProgress2.pendingProps;
              prevSibling = workInProgress2.memoizedState;
              returnFiber = prevSibling.element;
              cloneUpdateQueue(current2, workInProgress2);
              processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              nextProps = nextState.cache;
              pushProvider(workInProgress2, CacheContext, nextProps);
              nextProps !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              nextProps = nextState.element;
              if (supportsHydration && prevSibling.isDehydrated)
                if (prevSibling = {
                  element: nextProps,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevSibling, workInProgress2.memoizedState = prevSibling, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current2,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                  break a;
                } else if (nextProps !== returnFiber) {
                  returnFiber = createCapturedValueAtFiber(
                    Error(
                      "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                    ),
                    workInProgress2
                  );
                  queueHydrationError(returnFiber);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current2,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                  break a;
                } else
                  for (supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(
                    workInProgress2.stateNode.containerInfo
                  ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = true), current2 = mountChildFibers(
                    workInProgress2,
                    null,
                    nextProps,
                    renderLanes2
                  ), workInProgress2.child = current2; current2; )
                    current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
              else {
                resetHydrationState();
                if (nextProps === returnFiber) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current2,
                  workInProgress2,
                  nextProps,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            if (supportsResources)
              return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = current2 : isHydrating || (workInProgress2.stateNode = createHoistableInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                requiredContext(rootInstanceStackCursor.current),
                workInProgress2
              )) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
          case 27:
            if (supportsSingletons)
              return pushHostContext(workInProgress2), null === current2 && supportsSingletons && isHydrating && (prevSibling = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getHostContext(), prevSibling = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling,
                returnFiber,
                false
              ), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber
              ), null !== returnFiber && (buildHydrationDiffNode(workInProgress2, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getFirstHydratableChildWithinSingleton(
                workInProgress2.type,
                prevSibling,
                nextHydratableInstance
              )), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            return null === current2 && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              nextProps
            ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
              prevSibling,
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(
              nextState,
              workInProgress2.type,
              workInProgress2.pendingProps,
              nextProps
            ), null !== nextProps && (buildHydrationDiffNode(workInProgress2, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = false, nextProps = true) : nextProps = false, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, nextProps = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
              current2,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 6:
            return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), current2 = validateHydratableTextInstance(current2, renderLanes2), renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
              renderLanes2,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
          case 13:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              returnFiber,
              renderLanes2
            ) : reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
              "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
            )), pushProvider(workInProgress2, returnFiber, nextProps), reconcileChildren(
              current2,
              workInProgress2,
              prevSibling.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
              "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
            ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
              returnFiber,
              prevSibling,
              void 0
            ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
              current2,
              workInProgress2,
              returnFiber,
              renderLanes2
            ), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current2,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(
              current2,
              workInProgress2,
              renderLanes2
            );
          case 31:
            return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
              mode: returnFiber.mode,
              children: returnFiber.children
            }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
              returnFiber,
              renderLanes2
            ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = nextProps), workInProgress2.memoizedState = {
              parent: returnFiber,
              cache: prevSibling
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, nextProps = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
              parent: returnFiber,
              cache: returnFiber
            }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current2,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(
          "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function doesRequireClone(current2, completedWork) {
        if (null !== current2 && current2.child === completedWork.child) return false;
        if (0 !== (completedWork.flags & 16)) return true;
        for (current2 = completedWork.child; null !== current2; ) {
          if (0 !== (current2.flags & 13878) || 0 !== (current2.subtreeFlags & 13878))
            return true;
          current2 = current2.sibling;
        }
        return false;
      }
      function appendAllChildren(parent, workInProgress2, needsVisibilityToggle, isHidden) {
        if (supportsMutation)
          for (needsVisibilityToggle = workInProgress2.child; null !== needsVisibilityToggle; ) {
            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag)
              appendInitialChild(parent, needsVisibilityToggle.stateNode);
            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {
              needsVisibilityToggle.child.return = needsVisibilityToggle;
              needsVisibilityToggle = needsVisibilityToggle.child;
              continue;
            }
            if (needsVisibilityToggle === workInProgress2) break;
            for (; null === needsVisibilityToggle.sibling; ) {
              if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress2)
                return;
              needsVisibilityToggle = needsVisibilityToggle.return;
            }
            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
            needsVisibilityToggle = needsVisibilityToggle.sibling;
          }
        else if (supportsPersistence)
          for (var _node = workInProgress2.child; null !== _node; ) {
            if (5 === _node.tag) {
              var instance = _node.stateNode;
              needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(
                instance,
                _node.type,
                _node.memoizedProps
              ));
              appendInitialChild(parent, instance);
            } else if (6 === _node.tag)
              instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(
                instance,
                _node.memoizedProps
              )), appendInitialChild(parent, instance);
            else if (4 !== _node.tag) {
              if (22 === _node.tag && null !== _node.memoizedState)
                instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, true, true);
              else if (null !== _node.child) {
                _node.child.return = _node;
                _node = _node.child;
                continue;
              }
            }
            if (_node === workInProgress2) break;
            for (; null === _node.sibling; ) {
              if (null === _node.return || _node.return === workInProgress2)
                return;
              _node = _node.return;
            }
            _node.sibling.return = _node.return;
            _node = _node.sibling;
          }
      }
      function appendAllChildrenToContainer(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
        var hasOffscreenComponentChild = false;
        if (supportsPersistence)
          for (var node = workInProgress2.child; null !== node; ) {
            if (5 === node.tag) {
              var instance = node.stateNode;
              needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(
                instance,
                node.type,
                node.memoizedProps
              ));
              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (6 === node.tag)
              instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(
                instance,
                node.memoizedProps
              )), appendChildToContainerChildSet(containerChildSet, instance);
            else if (4 !== node.tag) {
              if (22 === node.tag && null !== node.memoizedState)
                hasOffscreenComponentChild = node.child, null !== hasOffscreenComponentChild && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, true, true), hasOffscreenComponentChild = true;
              else if (null !== node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            }
            if (node === workInProgress2) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === workInProgress2)
                return hasOffscreenComponentChild;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        return hasOffscreenComponentChild;
      }
      function updateHostContainer(current2, workInProgress2) {
        if (supportsPersistence && doesRequireClone(current2, workInProgress2)) {
          current2 = workInProgress2.stateNode;
          var container = current2.containerInfo, newChildSet = createContainerChildSet();
          appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
          current2.pendingChildren = newChildSet;
          markUpdate(workInProgress2);
          finalizeContainerChildren(container, newChildSet);
        }
      }
      function updateHostComponent(current2, workInProgress2, type, newProps) {
        if (supportsMutation)
          current2.memoizedProps !== newProps && markUpdate(workInProgress2);
        else if (supportsPersistence) {
          var currentInstance = current2.stateNode, _oldProps = current2.memoizedProps;
          if ((current2 = doesRequireClone(current2, workInProgress2)) || _oldProps !== newProps) {
            var currentHostContext = getHostContext();
            _oldProps = cloneInstance(
              currentInstance,
              type,
              _oldProps,
              newProps,
              !current2,
              null
            );
            _oldProps === currentInstance ? workInProgress2.stateNode = currentInstance : (finalizeInitialChildren(
              _oldProps,
              type,
              newProps,
              currentHostContext
            ) && markUpdate(workInProgress2), workInProgress2.stateNode = _oldProps, current2 ? appendAllChildren(_oldProps, workInProgress2, false, false) : markUpdate(workInProgress2));
          } else workInProgress2.stateNode = currentInstance;
        }
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, props) {
        if (maySuspendCommit(type, props)) {
          if (workInProgress2.flags |= 16777216, !preloadInstance(type, props))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if (mayResourceSuspendCommit(resource)) {
          if (workInProgress2.flags |= 16777216, !preloadResource(resource))
            if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var _lastTailNode = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          if ((completedWork.mode & 2) !== NoMode) {
            for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
              newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        else if ((completedWork.mode & 2) !== NoMode) {
          _treeBaseDuration = completedWork.actualDuration;
          _child2 = completedWork.selfBaseDuration;
          for (var child = completedWork.child; null !== child; )
            newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
          completedWork.actualDuration = _treeBaseDuration;
          completedWork.treeBaseDuration = _child2;
        } else
          for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current2 && (newProps = current2.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext, workInProgress2);
            popHostContainer(workInProgress2);
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current2 || null === current2.child)
              popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            updateHostContainer(current2, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            if (supportsResources) {
              renderLanes2 = workInProgress2.type;
              var nextResource = workInProgress2.memoizedState;
              null === current2 ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2,
                newProps
              ))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (supportsMutation ? current2.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(
                current2,
                workInProgress2,
                renderLanes2,
                newProps
              ), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2,
                newProps
              ));
              return null;
            }
          case 27:
            if (supportsSingletons) {
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              nextResource = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                supportsMutation ? current2.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(
                  current2,
                  workInProgress2,
                  nextResource,
                  newProps
                );
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  nextResource,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            }
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current2 && null != workInProgress2.stateNode)
              updateHostComponent(current2, workInProgress2, renderLanes2, newProps);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                bubbleProperties(workInProgress2);
                return null;
              }
              current2 = getHostContext();
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (nextResource = requiredContext(
                rootInstanceStackCursor.current
              ), nextResource = createInstance(
                renderLanes2,
                newProps,
                nextResource,
                current2,
                workInProgress2
              ), appendAllChildren(nextResource, workInProgress2, false, false), workInProgress2.stateNode = nextResource, finalizeInitialChildren(
                nextResource,
                renderLanes2,
                newProps,
                current2
              ) && markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps
            );
            return null;
          case 6:
            if (current2 && null != workInProgress2.stateNode)
              renderLanes2 = current2.memoizedProps, supportsMutation ? renderLanes2 !== newProps && markUpdate(workInProgress2) : supportsPersistence && (renderLanes2 !== newProps ? (current2 = requiredContext(
                rootInstanceStackCursor.current
              ), renderLanes2 = getHostContext(), workInProgress2.stateNode = createTextInstance(
                newProps,
                current2,
                renderLanes2,
                workInProgress2
              ), markUpdate(workInProgress2)) : workInProgress2.stateNode = current2.stateNode);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              current2 = requiredContext(rootInstanceStackCursor.current);
              renderLanes2 = getHostContext();
              if (popHydrationState(workInProgress2)) {
                if (!supportsHydration)
                  throw Error(
                    "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                nextResource = !didSuspendOrErrorDEV;
                newProps = null;
                var returnFiber = hydrationParentFiber;
                if (null !== returnFiber)
                  switch (returnFiber.tag) {
                    case 3:
                      nextResource && (nextResource = diffHydratedTextForDevWarnings(
                        current2,
                        renderLanes2,
                        newProps
                      ), null !== nextResource && (buildHydrationDiffNode(workInProgress2, 0).serverProps = nextResource));
                      break;
                    case 27:
                    case 5:
                      newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(
                        current2,
                        renderLanes2,
                        newProps
                      ), null !== nextResource && (buildHydrationDiffNode(
                        workInProgress2,
                        0
                      ).serverProps = nextResource));
                  }
                hydrateTextInstance(
                  current2,
                  renderLanes2,
                  workInProgress2,
                  newProps
                ) || throwOnHydrationMismatch(workInProgress2);
              } else
                workInProgress2.stateNode = createTextInstance(
                  newProps,
                  current2,
                  renderLanes2,
                  workInProgress2
                );
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
              nextResource = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current2) {
                  if (!nextResource)
                    throw Error(
                      "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                    );
                  if (!supportsHydration)
                    throw Error(
                      "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
                    );
                  nextResource = workInProgress2.memoizedState;
                  nextResource = null !== nextResource ? nextResource.dehydrated : null;
                  if (!nextResource)
                    throw Error(
                      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                    );
                  hydrateSuspenseInstance(nextResource, workInProgress2);
                  bubbleProperties(workInProgress2);
                  (workInProgress2.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress2.child, null !== nextResource && (workInProgress2.treeBaseDuration -= nextResource.treeBaseDuration));
                } else
                  emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress2.child, null !== nextResource && (workInProgress2.treeBaseDuration -= nextResource.treeBaseDuration));
                nextResource = false;
              } else
                nextResource = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = nextResource), nextResource = true;
              if (!nextResource) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
            renderLanes2 = null !== newProps;
            current2 = null !== current2 && null !== current2.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));
            renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            (workInProgress2.mode & 2) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
            return null;
          case 4:
            return popHostContainer(workInProgress2), updateHostContainer(current2, workInProgress2), null === current2 && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor, workInProgress2);
            nextResource = workInProgress2.memoizedState;
            if (null === nextResource)
              return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            returnFiber = nextResource.rendering;
            if (null === returnFiber)
              if (newProps) cutOffTailIfNeeded(nextResource, false);
              else {
                if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                  for (current2 = workInProgress2.child; null !== current2; ) {
                    returnFiber = findFirstSuspended(current2);
                    if (null !== returnFiber) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(nextResource, false);
                      current2 = returnFiber.updateQueue;
                      workInProgress2.updateQueue = current2;
                      scheduleRetryEffect(workInProgress2, current2);
                      workInProgress2.subtreeFlags = 0;
                      current2 = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                        workInProgress2
                      );
                      return workInProgress2.child;
                    }
                    current2 = current2.sibling;
                  }
                null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(nextResource, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current2 = findFirstSuspended(returnFiber), null !== current2) {
                  if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(nextResource, true), null === nextResource.tail && "hidden" === nextResource.tailMode && !returnFiber.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(nextResource, false), workInProgress2.lanes = 4194304);
              nextResource.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = nextResource.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, nextResource.last = returnFiber);
            }
            if (null !== nextResource.tail)
              return current2 = nextResource.tail, nextResource.rendering = current2, nextResource.tail = current2.sibling, nextResource.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
          case 24:
            return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(
          "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function unwindWork(current2, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 3:
            return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current2 = workInProgress2.memoizedState;
            if (null !== current2 && null !== current2.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(
                  "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                );
              resetHydrationState();
            }
            current2 = workInProgress2.flags;
            return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor, workInProgress2), null;
          case 4:
            return popHostContainer(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type, workInProgress2), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          case 24:
            return popProvider(CacheContext, workInProgress2), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext, interruptedWork);
            popHostContainer(interruptedWork);
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor, interruptedWork);
            break;
          case 10:
            popProvider(interruptedWork.type, interruptedWork);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext(interruptedWork);
            null !== current2 && pop(resumedCache, interruptedWork);
            break;
          case 24:
            popProvider(CacheContext, interruptedWork);
        }
      }
      function shouldProfile(current2) {
        return (current2.mode & 2) !== NoMode;
      }
      function commitHookLayoutEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
      }
      function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        ), recordEffectDuration()) : commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        );
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                finishedWork
              ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                finishedWork
              ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                finishedWork,
                callCreateInDEV,
                updateQueue
              ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                var hookName = void 0;
                hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                var addendum = void 0;
                addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                runWithFiberInDEV(
                  finishedWork,
                  function(n, a) {
                    console.error(
                      "%s must not return anything besides a function, which is used for clean-up.%s",
                      n,
                      a
                    );
                  },
                  hookName,
                  addendum
                );
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                  finishedWork
                ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                  finishedWork
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                  lastEffect,
                  callDestroyInDEV,
                  lastEffect,
                  nearestMountedAncestor,
                  destroy
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookPassiveMountEffects(finishedWork, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
      }
      function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        ), recordEffectDuration()) : commitHookEffectListUnmount(
          hookFlags,
          finishedWork,
          nearestMountedAncestor
        );
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), instance.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            runWithFiberInDEV(
              finishedWork,
              commitCallbacks,
              updateQueue,
              instance
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
        return instance.getSnapshotBeforeUpdate(prevProps, prevState);
      }
      function commitClassSnapshot(finishedWork, current2) {
        var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
        current2 = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
          "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        ), current2.state !== finishedWork.memoizedState && console.error(
          "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        ));
        try {
          var resolvedPrevProps = resolveClassComponentProps(
            finishedWork.type,
            prevProps,
            finishedWork.elementType === finishedWork.type
          );
          var snapshot = runWithFiberInDEV(
            finishedWork,
            callGetSnapshotBeforeUpdates,
            current2,
            resolvedPrevProps,
            prevState
          );
          prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
          void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              getComponentNameFromFiber(finishedWork)
            );
          }));
          current2.__reactInternalSnapshotBeforeUpdate = snapshot;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current2.type,
          current2.memoizedProps
        );
        instance.state = current2.memoizedState;
        shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
          current2,
          callComponentWillUnmountInDEV,
          current2,
          nearestMountedAncestor,
          instance
        ), recordEffectDuration()) : runWithFiberInDEV(
          current2,
          callComponentWillUnmountInDEV,
          current2,
          nearestMountedAncestor,
          instance
        );
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (null !== ref) {
          switch (finishedWork.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = getPublicInstance(finishedWork.stateNode);
              break;
            case 30:
              instanceToUse = finishedWork.stateNode;
              break;
            default:
              instanceToUse = finishedWork.stateNode;
          }
          if ("function" === typeof ref)
            if (shouldProfile(finishedWork))
              try {
                startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
              } finally {
                recordEffectDuration();
              }
            else finishedWork.refCleanup = ref(instanceToUse);
          else
            "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
              "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
              getComponentNameFromFiber(finishedWork)
            ), ref.current = instanceToUse;
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          runWithFiberInDEV(current2, commitAttachRef, current2);
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref = current2.ref, refCleanup = current2.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              if (shouldProfile(current2))
                try {
                  startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                } finally {
                  recordEffectDuration(current2);
                }
              else runWithFiberInDEV(current2, refCleanup);
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            } finally {
              current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              if (shouldProfile(current2))
                try {
                  startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                } finally {
                  recordEffectDuration(current2);
                }
              else runWithFiberInDEV(current2, ref, null);
            } catch (error$3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error$3);
            }
          else ref.current = null;
      }
      function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
        _finishedWork$memoize = _finishedWork$memoize.onRender;
        current2 = null === current2 ? "mount" : "update";
        currentUpdateIsNested && (current2 = "nested-update");
        "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
          id,
          current2,
          finishedWork.actualDuration,
          finishedWork.treeBaseDuration,
          finishedWork.actualStartTime,
          commitStartTime2
        );
        "function" === typeof onCommit && onCommit(
          finishedWork.memoizedProps.id,
          current2,
          effectDuration,
          commitStartTime2
        );
      }
      function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
        var _finishedWork$memoize2 = finishedWork.memoizedProps;
        finishedWork = _finishedWork$memoize2.id;
        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
        current2 = null === current2 ? "mount" : "update";
        currentUpdateIsNested && (current2 = "nested-update");
        "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
          finishedWork,
          current2,
          passiveEffectDuration,
          commitStartTime2
        );
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          runWithFiberInDEV(
            finishedWork,
            commitMount,
            instance,
            type,
            props,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          runWithFiberInDEV(
            finishedWork,
            commitUpdate,
            finishedWork.stateNode,
            finishedWork.type,
            oldProps,
            newProps,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : false) || (supportsSingletons ? 27 === fiber.tag && isSingletonScope(fiber.type) : false) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (supportsSingletons && 27 === fiber.tag && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);
        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);
        else if (4 !== tag && (supportsSingletons && 27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitPlacement(finishedWork) {
        if (supportsMutation) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              if (supportsSingletons) {
                hostParentFiber = hostParentFiber.stateNode;
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(
                  finishedWork,
                  parentFiber,
                  hostParentFiber
                );
                break;
              }
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
      }
      function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
        portal = portal.containerInfo;
        try {
          runWithFiberInDEV(
            finishedWork,
            replaceContainerChildren,
            portal,
            pendingChildren
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          runWithFiberInDEV(
            finishedWork,
            acquireSingletonInstance,
            finishedWork.type,
            props,
            singleton,
            finishedWork
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitBeforeMutationEffects(root, firstChild) {
        prepareForCommit(root.containerInfo);
        for (nextEffect = firstChild; null !== nextEffect; )
          if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1024) && null !== firstChild)
            firstChild.return = root, nextEffect = firstChild;
          else
            for (; null !== nextEffect; ) {
              firstChild = root = nextEffect;
              var current2 = firstChild.alternate, flags = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  0 !== (flags & 1024) && null !== current2 && commitClassSnapshot(firstChild, current2);
                  break;
                case 3:
                  0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (flags & 1024))
                    throw Error(
                      "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                    );
              }
              firstChild = root.sibling;
              if (null !== firstChild) {
                firstChild.return = root.return;
                nextEffect = firstChild;
                break;
              }
              nextEffect = root.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current2)
                finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                  finishedWork,
                  callComponentDidMountInDEV,
                  finishedWork,
                  finishedRoot
                ), recordEffectDuration()) : runWithFiberInDEV(
                  finishedWork,
                  callComponentDidMountInDEV,
                  finishedWork,
                  finishedRoot
                );
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current2.memoizedProps
                );
                current2 = current2.memoizedState;
                finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  getComponentNameFromFiber(finishedWork) || "instance"
                ));
                shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                  finishedWork,
                  callComponentDidUpdateInDEV,
                  finishedWork,
                  finishedRoot,
                  prevProps,
                  current2,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                ), recordEffectDuration()) : runWithFiberInDEV(
                  finishedWork,
                  callComponentDidUpdateInDEV,
                  finishedWork,
                  finishedRoot,
                  prevProps,
                  current2,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            current2 = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
              prevProps = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    prevProps = getPublicInstance(finishedWork.child.stateNode);
                    break;
                  case 1:
                    prevProps = finishedWork.child.stateNode;
                }
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitCallbacks,
                  flags,
                  prevProps
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            finishedRoot.effectDuration += popNestedEffectDurations(current2);
            break;
          case 27:
            supportsSingletons && null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current2 && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            if (flags & 4) {
              flags = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              finishedRoot = finishedWork.stateNode;
              finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfiler,
                  finishedWork,
                  current2,
                  commitStartTime,
                  finishedRoot.effectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber._debugOwner = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(
            finishedRoot,
            nearestMountedAncestor,
            parent
          ), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
          }
        switch (deletedFiber.tag) {
          case 26:
            if (supportsResources) {
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);
              break;
            }
          case 27:
            if (supportsSingletons) {
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            }
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            if (supportsMutation) {
              if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              ), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
            } else
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
            break;
          case 18:
            supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(
              hostParent,
              deletedFiber.stateNode
            ) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = true, recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            ), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(
              deletedFiber.stateNode,
              deletedFiber,
              createContainerChildSet()
            ), recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(
              Insertion,
              deletedFiber,
              nearestMountedAncestor
            );
            offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
              deletedFiber,
              nearestMountedAncestor,
              Layout
            );
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            runWithFiberInDEV(
              finishedWork,
              commitHydratedSuspenseInstance,
              finishedRoot
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(
              "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
            );
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            if (isDevToolsPresent)
              if (null !== inProgressLanes && null !== inProgressRoot)
                restorePendingUpdaters(inProgressRoot, inProgressLanes);
              else
                throw Error(
                  "Expected finished root and lanes to be set. This is a bug in React."
                );
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];
            if (supportsMutation) {
              var parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (supportsSingletons) {
                      if (isSingletonScope(parent.type)) {
                        hostParent = parent.stateNode;
                        hostParentIsContainer = false;
                        break a;
                      }
                      break;
                    }
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
            root = deletedFiber;
            returnFiber = root.alternate;
            null !== returnFiber && (returnFiber.return = null);
            root.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      function commitMutationEffectsOnFiber(finishedWork, root) {
        var current2 = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(
              Insertion | HasEffect,
              finishedWork,
              finishedWork.return
            ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout | HasEffect
            ));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
            break;
          case 26:
            if (supportsResources) {
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              flags & 4 && (flags = null !== current2 ? current2.memoizedState : null, root = finishedWork.memoizedState, null === current2 ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.memoizedProps,
                finishedWork
              ) : mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : finishedWork.stateNode = acquireResource(
                hoistableRoot,
                root,
                finishedWork.memoizedProps
              ) : flags !== root ? (null === flags ? null !== current2.stateNode && unmountHoistable(current2.stateNode) : releaseResource(flags), null === root ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                root,
                finishedWork.memoizedProps
              )) : null === root && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              ));
              break;
            }
          case 27:
            if (supportsSingletons) {
              recursivelyTraverseMutationEffects(root, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            }
          case 5:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
            if (supportsMutation) {
              if (finishedWork.flags & 32) {
                root = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(finishedWork, resetTextContent, root);
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error
                  );
                }
              }
              flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                root,
                null !== current2 ? current2.memoizedProps : root
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
            }
            break;
          case 6:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && supportsMutation) {
              if (null === finishedWork.stateNode)
                throw Error(
                  "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                );
              flags = finishedWork.memoizedProps;
              current2 = null !== current2 ? current2.memoizedProps : flags;
              root = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitTextUpdate,
                  root,
                  current2,
                  flags
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            hoistableRoot = pushNestedEffectDurations();
            if (supportsResources) {
              prepareToCommitHoistables();
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root.containerInfo);
              recursivelyTraverseMutationEffects(root, finishedWork);
              currentHoistableRoot = previousHoistableRoot;
            } else recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (supportsMutation && supportsHydration && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error
                  );
                }
              if (supportsPersistence) {
                flags = root.containerInfo;
                current2 = root.pendingChildren;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    replaceContainerChildren,
                    flags,
                    current2
                  );
                } catch (error) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error
                  );
                }
              }
            }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            root.effectDuration += popNestedEffectDurations(hoistableRoot);
            break;
          case 4:
            supportsResources ? (current2 = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            ), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current2) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));
            flags & 4 && supportsPersistence && commitHostPortalContainerChildren(
              finishedWork.stateNode,
              finishedWork,
              finishedWork.stateNode.pendingChildren
            );
            break;
          case 12:
            flags = pushNestedEffectDurations();
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation)) {
              a: if (current2 = null, supportsMutation)
                for (root = finishedWork; ; ) {
                  if (5 === root.tag || supportsResources && 26 === root.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root;
                      try {
                        previousHoistableRoot = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(
                          wasHidden,
                          hideInstance,
                          previousHoistableRoot
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(
                          wasHidden,
                          wasHidden.return,
                          error
                        );
                      }
                    }
                  } else if (6 === root.tag) {
                    if (null === current2) {
                      wasHidden = root;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot ? runWithFiberInDEV(
                          wasHidden,
                          hideTextInstance,
                          instance
                        ) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          instance,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(
                          wasHidden,
                          wasHidden.return,
                          error
                        );
                      }
                    }
                  } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
                    root.child.return = root;
                    root = root.child;
                    continue;
                  }
                  if (root === finishedWork) break a;
                  for (; null === root.sibling; ) {
                    if (null === root.return || root.return === finishedWork)
                      break a;
                    current2 === root && (current2 = null);
                    root = root.return;
                  }
                  current2 === root && (current2 = null);
                  root.sibling.return = root.return;
                  root = root.sibling;
                }
            }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function disappearLayoutEffects(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            supportsSingletons && runWithFiberInDEV(
              finishedWork,
              releaseSingletonInstance,
              finishedWork.stateNode
            );
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
      }
      function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookLayoutEffects(finishedWork, Layout);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current2 = finishedWork.stateNode;
            "function" === typeof current2.componentDidMount && runWithFiberInDEV(
              finishedWork,
              callComponentDidMountInDEV,
              finishedWork,
              current2
            );
            current2 = finishedWork.updateQueue;
            if (null !== current2) {
              finishedRoot = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitHiddenCallbacks,
                  current2,
                  finishedRoot
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            supportsSingletons && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            if (includeWorkInProgressEffects && flags & 4) {
              flags = pushNestedEffectDurations();
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects = finishedWork.stateNode;
              includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfiler,
                  finishedWork,
                  current2,
                  commitStartTime,
                  includeWorkInProgressEffects.effectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          reappearLayoutEffects(
            finishedRoot,
            parentFiber.alternate,
            parentFiber,
            includeWorkInProgressEffects
          ), parentFiber = parentFiber.sibling;
      }
      function commitOffscreenPassiveMountEffects(current2, finishedWork) {
        var previousCache = null;
        null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
        current2 = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
        current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current2, finishedWork) {
        current2 = null;
        null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
      }
      function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            var prevEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
            finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
            break;
          case 12:
            if (flags & 2048) {
              flags = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitProfilerPostCommitImpl,
                  finishedWork,
                  finishedWork.alternate,
                  commitStartTime,
                  finishedRoot.passiveEffectDuration
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            prevEffectDuration = finishedWork.stateNode;
            var _current = finishedWork.alternate;
            null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : prevEffectDuration._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (prevEffectDuration._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          reconnectPassiveEffects(
            finishedRoot,
            parentFiber,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ), parentFiber = parentFiber.sibling;
      }
      function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookPassiveMountEffects(finishedWork, Passive);
            break;
          case 23:
            break;
          case 22:
            var _instance2 = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? _instance2._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (_instance2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                );
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                );
                flags & 2048 && commitCachePassiveMountEffect(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                );
            }
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            ) : suspendInstance(fiber.type, fiber.memoizedProps));
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);
            break;
          case 3:
          case 4:
            if (supportsResources) {
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
            } else recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive | HasEffect
            );
            break;
          case 3:
            var prevEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
            break;
          case 12:
            prevEffectDuration = pushNestedEffectDurations();
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
            break;
          case 22:
            prevEffectDuration = finishedWork.stateNode;
            null !== finishedWork.memoizedState && prevEffectDuration._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
      }
      function disconnectPassiveEffect(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive
            );
            recursivelyTraverseDisconnectPassiveEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            instance._visibility & 2 && (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect, current2 = fiber;
          switch (current2.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                current2,
                nearestMountedAncestor,
                Passive
              );
              break;
            case 23:
            case 22:
              null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
              break;
            case 24:
              releaseCache(current2.memoizedState.cache);
          }
          current2 = fiber.child;
          if (null !== current2) current2.return = fiber, nextEffect = current2;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              current2 = nextEffect;
              var sibling = current2.sibling, returnFiber = current2.return;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      function findFiberRootForHostRoot(hostRoot) {
        var maybeFiber = getInstanceFromNode(hostRoot);
        if (null != maybeFiber) {
          if ("string" !== typeof maybeFiber.memoizedProps["data-testname"])
            throw Error(
              "Invalid host root specified. Should be either a React container or a node with a testname attribute."
            );
          return maybeFiber;
        }
        hostRoot = findFiberRoot(hostRoot);
        if (null === hostRoot)
          throw Error(
            "Could not find React container within specified host subtree."
          );
        return hostRoot.stateNode.current;
      }
      function matchSelector(fiber$jscomp$0, selector) {
        var tag = fiber$jscomp$0.tag;
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            if (fiber$jscomp$0.type === selector.value) return true;
            break;
          case HAS_PSEUDO_CLASS_TYPE:
            a: {
              selector = selector.value;
              fiber$jscomp$0 = [fiber$jscomp$0, 0];
              for (tag = 0; tag < fiber$jscomp$0.length; ) {
                var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];
                if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {
                  for (; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0); )
                    selectorIndex++, selector$jscomp$0 = selector[selectorIndex];
                  if (selectorIndex === selector.length) {
                    selector = true;
                    break a;
                  } else
                    for (fiber = fiber.child; null !== fiber; )
                      fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;
                }
              }
              selector = false;
            }
            return selector;
          case ROLE_TYPE:
            if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value))
              return true;
            break;
          case TEXT_TYPE:
            if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {
              if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value))
                return true;
            }
            break;
          case TEST_NAME_TYPE:
            if (5 === tag || 26 === tag || 27 === tag) {
              if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"], "string" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
                return true;
            }
            break;
          default:
            throw Error("Invalid selector type specified.");
        }
        return false;
      }
      function selectorToString(selector) {
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            return "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">";
          case HAS_PSEUDO_CLASS_TYPE:
            return ":has(" + (selectorToString(selector) || "") + ")";
          case ROLE_TYPE:
            return '[role="' + selector.value + '"]';
          case TEXT_TYPE:
            return '"' + selector.value + '"';
          case TEST_NAME_TYPE:
            return '[data-testname="' + selector.value + '"]';
          default:
            throw Error("Invalid selector type specified.");
        }
      }
      function findPaths(root, selectors) {
        var matchingFibers = [];
        root = [root, 0];
        for (var index = 0; index < root.length; ) {
          var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];
          if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
            for (; null != selector && matchSelector(fiber, selector); )
              selectorIndex++, selector = selectors[selectorIndex];
            if (selectorIndex === selectors.length) matchingFibers.push(fiber);
            else
              for (fiber = fiber.child; null !== fiber; )
                root.push(fiber, selectorIndex), fiber = fiber.sibling;
          }
        }
        return matchingFibers;
      }
      function findAllNodes(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw Error("Test selector API is not supported by this renderer.");
        hostRoot = findFiberRootForHostRoot(hostRoot);
        hostRoot = findPaths(hostRoot, selectors);
        selectors = [];
        hostRoot = Array.from(hostRoot);
        for (var index = 0; index < hostRoot.length; ) {
          var node = hostRoot[index++], tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag)
            isHiddenSubtree(node) || selectors.push(node.stateNode);
          else
            for (node = node.child; null !== node; )
              hostRoot.push(node), node = node.sibling;
        }
        return selectors;
      }
      function onCommitRoot() {
        supportsTestSelectors && commitHooks.forEach(function(commitHook) {
          return commitHook();
        });
      }
      function isConcurrentActEnvironment() {
        var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
          "The current testing environment is not configured to support act(...)"
        );
        return isReactActEnvironmentGlobal;
      }
      function requestUpdateLane(fiber) {
        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        var transition = ReactSharedInternals.T;
        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root, fiber, lane) {
        isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
        if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit)
          prepareFreshStack(root, 0), markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root, lane);
        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {
          if (isRendering)
            switch (fiber.tag) {
              case 0:
              case 11:
              case 15:
                root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  fiber,
                  root,
                  root
                ));
                break;
              case 1:
                didWarnAboutUpdateInRender || (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ), didWarnAboutUpdateInRender = true);
            }
        } else
          isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root);
      }
      function performWorkOnRoot(root, lanes, forceSync) {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (exitStatus === RootInProgress) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, false);
            break;
          } else {
            forceSync = root.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (exitStatus === RootErrored) {
              renderWasConcurrent = lanes;
              if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
                var errorRetryLanes = 0;
              else
                errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
              if (0 !== errorRetryLanes) {
                lanes = errorRetryLanes;
                a: {
                  exitStatus = root;
                  var errorRetryLanes$jscomp$0 = errorRetryLanes;
                  errorRetryLanes = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(
                    exitStatus,
                    errorRetryLanes$jscomp$0
                  ).flags |= 256);
                  errorRetryLanes$jscomp$0 = renderRootSync(
                    exitStatus,
                    errorRetryLanes$jscomp$0,
                    false
                  );
                  if (errorRetryLanes$jscomp$0 !== RootErrored) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = RootSuspendedWithDelay;
                      break a;
                    }
                    exitStatus = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = errorRetryLanes;
                    null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      exitStatus
                    ));
                  }
                  exitStatus = errorRetryLanes$jscomp$0;
                }
                renderWasConcurrent = false;
                if (exitStatus !== RootErrored) continue;
              }
            }
            if (exitStatus === RootFatalErrored) {
              prepareFreshStack(root, 0);
              markRootSuspended(root, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root;
              switch (exitStatus) {
                case RootInProgress:
                case RootFatalErrored:
                  throw Error("Root did not complete. This is a bug in React.");
                case RootSuspendedWithDelay:
                  if ((lanes & 4194048) !== lanes) break;
                case RootSuspendedAtTheShell:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case RootErrored:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case RootSuspended:
                case RootCompleted:
                  break;
                default:
                  throw Error("Unknown root exit status.");
              }
              if (null !== ReactSharedInternals.actQueue)
                commitRoot(
                  shouldTimeSlice,
                  forceSync,
                  lanes,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes
                );
              else {
                if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                  shouldTimeSlice.timeoutHandle = scheduleTimeout(
                    commitRootWhenReady.bind(
                      null,
                      shouldTimeSlice,
                      forceSync,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      lanes,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes,
                      workInProgressRootDidSkipSuspendedSiblings,
                      exitStatus,
                      THROTTLED_COMMIT,
                      -0,
                      0
                    ),
                    renderWasConcurrent
                  );
                  break a;
                }
                commitRootWhenReady(
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  exitStatus,
                  IMMEDIATE_COMMIT,
                  -0,
                  0
                );
              }
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root);
      }
      function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root.timeoutHandle = noTimeout;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                SUSPENDED_COMMIT,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(
              root,
              lanes,
              spawnedLane,
              !didSkipSuspendedSiblings
            );
            return;
          }
        }
        commitRoot(
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index;
          didAttemptEntireTree[index] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
      }
      function flushSyncWork() {
        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (workInProgressSuspendedReason === NotSuspended)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root, lanes) {
        var timeoutHandle = root.timeoutHandle;
        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
        timeoutHandle = root.cancelPendingCommit;
        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root;
        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = NotSuspended;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
            lanes |= root[index];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        lanes = getCurrentTime();
        1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
        ReactStrictModeWarnings.discardPendingWarnings();
        return timeoutHandle;
      }
      function handleThrow(root, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        ReactSharedInternals.getCurrentStack = null;
        isRendering = false;
        current = null;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
        workInProgressThrownValue = thrownValue;
        var erroredWork = workInProgress;
        if (null === erroredWork)
          workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
        else
          switch (erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
            case SuspendedOnError:
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
              break;
            case SuspendedOnData:
            case SuspendedOnAction:
            case SuspendedOnImmediate:
            case SuspendedOnDeprecatedThrowPromise:
            case SuspendedAndReadyToContinue:
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                erroredWork,
                thrownValue,
                workInProgressRootRenderLanes
              );
          }
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = RootSuspendedWithDelay;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root.memoizedUpdaters;
            0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
            movePendingFibersToMemoized(root, lanes);
          }
          workInProgressTransitions = null;
          prepareFreshStack(root, lanes);
        }
        markRenderStarted(lanes);
        lanes = false;
        memoizedUpdaters = workInProgressRootExitStatus;
        a: do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$4) {
            handleThrow(root, thrownValue$4);
          }
        while (1);
        lanes && root.shellSuspendCounter++;
        resetContextDependencies();
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        markRenderStopped();
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return memoizedUpdaters;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root.memoizedUpdaters;
            0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
            movePendingFibersToMemoized(root, lanes);
          }
          workInProgressTransitions = null;
          workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
          prepareFreshStack(root, lanes);
        } else
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
            root,
            lanes
          );
        markRenderStarted(lanes);
        a: do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
              b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                case SuspendedOnError:
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnError
                  );
                  break;
                case SuspendedOnData:
                case SuspendedOnAction:
                  if (isThenableResolved(memoizedUpdaters)) {
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                    ensureRootIsScheduled(root);
                  };
                  memoizedUpdaters.then(lanes, lanes);
                  break a;
                case SuspendedOnImmediate:
                  workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                  break a;
                case SuspendedOnInstance:
                  workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                  break a;
                case SuspendedAndReadyToContinue:
                  isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                    root,
                    lanes,
                    memoizedUpdaters,
                    SuspendedAndReadyToContinue
                  ));
                  break;
                case SuspendedOnInstanceAndReadyToContinue:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;
                      if (resource ? preloadResource(resource) : preloadInstance(type, props)) {
                        workInProgressSuspendedReason = NotSuspended;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                      break;
                    default:
                      console.error(
                        "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                      );
                  }
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnInstanceAndReadyToContinue
                  );
                  break;
                case SuspendedOnDeprecatedThrowPromise:
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(
                    root,
                    lanes,
                    memoizedUpdaters,
                    SuspendedOnDeprecatedThrowPromise
                  );
                  break;
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = RootSuspendedAtTheShell;
                  break a;
                default:
                  throw Error(
                    "Unexpected SuspendedReason. This is a bug in React."
                  );
              }
            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$5) {
            handleThrow(root, thrownValue$5);
          }
        while (1);
        resetContextDependencies();
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress)
          return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
        markRenderStopped();
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
          unitOfWork,
          beginWork,
          current2,
          unitOfWork,
          entangledRenderLanes
        ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
          unitOfWork,
          beginWork,
          current2,
          unitOfWork,
          entangledRenderLanes
        );
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replayBeginWork(unitOfWork) {
        var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;
        isProfilingMode && startProfilerTimer(unitOfWork);
        switch (unitOfWork.tag) {
          case 15:
          case 0:
            current2 = replayFunctionComponent(
              current2,
              unitOfWork,
              unitOfWork.pendingProps,
              unitOfWork.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            current2 = replayFunctionComponent(
              current2,
              unitOfWork,
              unitOfWork.pendingProps,
              unitOfWork.type.render,
              unitOfWork.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(unitOfWork);
          default:
            unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
        }
        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
        return current2;
      }
      function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
        resetContextDependencies();
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root,
              createCapturedValueAtFiber(thrownValue, root.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || suspendedReason === SuspendedOnError) root = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          var current2 = completedWork.alternate;
          unitOfWork = completedWork.return;
          startProfilerTimer(completedWork);
          current2 = runWithFiberInDEV(
            completedWork,
            completeWork,
            current2,
            completedWork,
            entangledRenderLanes
          );
          (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
          if (null !== current2) {
            workInProgress = current2;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          if ((unitOfWork.mode & 2) !== NoMode) {
            stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
            next = unitOfWork.actualDuration;
            for (var child = unitOfWork.child; null !== child; )
              next += child.actualDuration, child = child.sibling;
            unitOfWork.actualDuration = next;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = RootSuspendedAtTheShell;
        workInProgress = null;
      }
      function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
        ReactStrictModeWarnings.flushLegacyContextWarning();
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
        if (null === finishedWork) markCommitStopped();
        else {
          0 === lanes && console.error(
            "finishedLanes should not be empty during a commit. This is a bug in React."
          );
          if (finishedWork === root.current)
            throw Error(
              "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
            );
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root.callbackNode = null, root.callbackPriority = 0);
          commitStartTime = now();
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            spawnedLane = executionContext;
            executionContext |= CommitContext;
            try {
              commitBeforeMutationEffects(root, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = PENDING_MUTATION_PHASE;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            try {
              inProgressLanes = lanes, inProgressRoot = root, commitMutationEffectsOnFiber(finishedWork, root), inProgressRoot = inProgressLanes = null, resetAfterCommit(root.containerInfo);
            } finally {
              executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root.current = finishedWork;
          pendingEffectsStatus = PENDING_LAYOUT_PHASE;
        }
      }
      function flushLayoutEffects() {
        if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            try {
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root, commitLayoutEffectOnFiber(
                root,
                finishedWork.alternate,
                finishedWork
              ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
            } finally {
              executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
        }
      }
      function flushSpawnedWork() {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          requestPaint();
          var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
          rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
          var remainingLanes = root.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);
          rootDidHavePassiveEffects = lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              var didError = 128 === (finishedWork.current.flags & 128);
              switch (rootDidHavePassiveEffects) {
                case 2:
                  var schedulerPriority = ImmediatePriority;
                  break;
                case 8:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case 32:
                  schedulerPriority = NormalPriority$1;
                  break;
                case 268435456:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority$1;
              }
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                schedulerPriority,
                didError
              );
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          isDevToolsPresent && root.memoizedUpdaters.clear();
          onCommitRoot();
          if (null !== recoverableErrors) {
            didError = ReactSharedInternals.T;
            schedulerPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(2);
            ReactSharedInternals.T = null;
            try {
              var onRecoverableError = root.onRecoverableError;
              for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
                var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                runWithFiberInDEV(
                  recoverableError.source,
                  onRecoverableError,
                  recoverableError.value,
                  errorInfo
                );
              }
            } finally {
              ReactSharedInternals.T = didError, setCurrentUpdatePriority(schedulerPriority);
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root);
          remainingLanes = root.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
          markCommitStopped();
        }
      }
      function makeErrorInfo(componentStack) {
        componentStack = { componentStack };
        Object.defineProperty(componentStack, "digest", {
          get: function() {
            console.error(
              'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
            );
          }
        });
        return componentStack;
      }
      function releaseRootPooledCache(root, remainingLanes) {
        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
        var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;
        renderPriority = ReactSharedInternals.T;
        var previousPriority = getCurrentUpdatePriority();
        try {
          setCurrentUpdatePriority(priority);
          ReactSharedInternals.T = null;
          priority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = NO_PENDING_EFFECTS;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Cannot flush passive effects while already rendering.");
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            priority
          );
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
          commitDoubleInvokeEffectsInDEV(root$jscomp$0);
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
          didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          var stateNode = root$jscomp$0.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
          return true;
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        isRunningInsertionEffect = false;
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else {
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              return;
            }
            if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                return;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
          console.error(
            "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
            error
          );
        }
      }
      function attachPingListener(root, wakeable, lanes) {
        var pingCache = root.pingCache;
        if (null === pingCache) {
          pingCache = root.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
      }
      function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
        root.warmLanes &= ~pingedLanes;
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
        );
        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(
              "Pinged unknown suspense boundary type. This is probably a bug in React."
            );
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
        if (0 !== (parentFiber.subtreeFlags & 67117056))
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
            isStrictModeFiber = isInStrictMode || isStrictModeFiber;
            22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
              fiber,
              doubleInvokeEffectsOnFiber,
              root,
              fiber,
              (fiber.mode & 64) === NoMode
            ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
              root,
              fiber,
              isStrictModeFiber
            ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
              fiber,
              doubleInvokeEffectsOnFiber,
              root,
              fiber
            ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
              fiber,
              recursivelyTraverseAndDoubleInvokeEffectsInDEV,
              root,
              fiber,
              isStrictModeFiber
            ));
            parentFiber = parentFiber.sibling;
          }
      }
      function doubleInvokeEffectsOnFiber(root, fiber) {
        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
        setIsStrictModeForDevtools(true);
        try {
          disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, false, 0);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      function commitDoubleInvokeEffectsInDEV(root) {
        var doubleInvokeEffects = true;
        root.current.mode & 24 || (doubleInvokeEffects = false);
        recursivelyTraverseAndDoubleInvokeEffectsInDEV(
          root,
          root.current,
          doubleInvokeEffects
        );
      }
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        if ((executionContext & RenderContext) === NoContext) {
          var tag = fiber.tag;
          if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
            tag = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (null !== didWarnStateUpdateForNotYetMountedComponent) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
              didWarnStateUpdateForNotYetMountedComponent.add(tag);
            } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
            runWithFiberInDEV(fiber, function() {
              console.error(
                "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
              );
            });
          }
        }
      }
      function restorePendingUpdaters(root, lanes) {
        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {
          addFiberToLanesMap(root, schedulingFiber, lanes);
        });
      }
      function scheduleCallback(priorityLevel, callback) {
        var actQueue = ReactSharedInternals.actQueue;
        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
          console.error(
            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
            getComponentNameFromFiber(fiber)
          );
        });
      }
      function resolveFunctionForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? type : family.current;
      }
      function resolveForwardRefForHotReloading(type) {
        if (null === resolveFamily) return type;
        var family = resolveFamily(type);
        return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        if (null === resolveFamily) return false;
        var prevType = fiber.elementType;
        element = element.type;
        var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
        switch (fiber.tag) {
          case 1:
            "function" === typeof element && (needsCompareFamilies = true);
            break;
          case 0:
            "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          case 11:
            $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          case 14:
          case 15:
            $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
            break;
          default:
            return false;
        }
        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
      }
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
        switch (tag) {
          case 0:
          case 15:
          case 1:
            candidateType = type;
            break;
          case 11:
            candidateType = type.render;
        }
        if (null === resolveFamily)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = false;
        type = false;
        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (1 === tag ? type = true : needsRender = true)));
        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = true);
        type && (fiber._debugNeedsRemount = true);
        if (type || needsRender)
          alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
        null === child || type || scheduleFibersWithFamiliesRecursively(
          child,
          updatedFamilies,
          staleFamilies
        );
        null !== sibling && scheduleFibersWithFamiliesRecursively(
          sibling,
          updatedFamilies,
          staleFamilies
        );
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
        this.actualDuration = -0;
        this.actualStartTime = -1.1;
        this.treeBaseDuration = this.selfBaseDuration = -0;
        this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
        this._debugNeedsRemount = false;
        this._debugHookTypes = null;
        hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
      }
      function shouldConstruct(Component2) {
        Component2 = Component2.prototype;
        return !(!Component2 || !Component2.isReactComponent);
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiber(
          current2.tag,
          pendingProps,
          current2.key,
          current2.mode
        ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
        workInProgress2.flags = current2.flags & 65011712;
        workInProgress2.childLanes = current2.childLanes;
        workInProgress2.lanes = current2.lanes;
        workInProgress2.child = current2.child;
        workInProgress2.memoizedProps = current2.memoizedProps;
        workInProgress2.memoizedState = current2.memoizedState;
        workInProgress2.updateQueue = current2.updateQueue;
        pendingProps = current2.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : {
          lanes: pendingProps.lanes,
          firstContext: pendingProps.firstContext,
          _debugThenableState: pendingProps._debugThenableState
        };
        workInProgress2.sibling = current2.sibling;
        workInProgress2.index = current2.index;
        workInProgress2.ref = current2.ref;
        workInProgress2.refCleanup = current2.refCleanup;
        workInProgress2.selfBaseDuration = current2.selfBaseDuration;
        workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        workInProgress2._debugInfo = current2._debugInfo;
        workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
        switch (workInProgress2.tag) {
          case 0:
          case 15:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case 1:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case 11:
            workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current2 = workInProgress2.alternate;
        null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext,
          _debugThenableState: renderLanes2._debugThenableState
        }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0, resolvedType = type;
        if ("function" === typeof type)
          shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
        else if ("string" === typeof type)
          supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(
                pendingProps.children,
                mode,
                lanes,
                key
              );
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                typeof type.id
              ), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            case REACT_SUSPENSE_TYPE:
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                }
              resolvedType = "";
              if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              fiberTag = owner ? "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null : null;
              fiberTag && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = Error(
                "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
              );
              resolvedType = null;
          }
        key = createFiber(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = resolvedType;
        key.lanes = lanes;
        key._debugOwner = owner;
        return key;
      }
      function createFiberFromElement(element, mode, lanes) {
        mode = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          element._owner,
          mode,
          lanes
        );
        mode._debugOwner = element._owner;
        mode._debugStack = element._debugStack;
        mode._debugTask = element._debugTask;
        return mode;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiber(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiber(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiber(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = noTimeout;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
        this.passiveEffectDuration = this.effectDuration = -0;
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        containerInfo = this.pendingUpdatersLaneMap = [];
        for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
        this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isDevToolsPresent && (tag |= 2);
        isStrictMode = createFiber(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        retainCache(tag);
        containerInfo.pooledCache = tag;
        retainCache(tag);
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerSync(element, container, parentComponent, callback) {
        updateContainerImpl(
          container.current,
          2,
          element,
          container,
          parentComponent,
          callback
        );
        return 2;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
          try {
            injectedHook.onScheduleFiberRoot(rendererID, container, element);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error(
              "React instrumentation encountered an error: %s",
              err
            ));
          }
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
          getComponentNameFromFiber(current) || "Unknown"
        ));
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && ("function" !== typeof callback && console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          callback
        ), container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function getLaneLabelMap() {
        for (var map = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
          var label = getLabelForLane(lane);
          map.set(lane, label);
          lane *= 2;
        }
        return map;
      }
      var exports3 = {};
      "use strict";
      var React6 = require_react(), Scheduler = require_scheduler(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;
      $$$config.cloneMutableInstance;
      var appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance;
      $$$config.cloneMutableTextInstance;
      var scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;
      $$$config.warnsIfNotActing;
      var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;
      $$$config.beforeActiveInstanceBlur;
      var preparePortalMount = $$$config.preparePortalMount;
      $$$config.prepareScopeUpdate;
      $$$config.getInstanceFromScope;
      var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;
      $$$config.trackSchedulerEvent;
      $$$config.resolveEventType;
      $$$config.resolveEventTimeStamp;
      var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;
      $$$config.requestPostPaintCallback;
      var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance;
      $$$config.suspendOnActiveViewTransition;
      var waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance;
      $$$config.cancelViewTransitionName;
      $$$config.cancelRootViewTransitionName;
      $$$config.restoreRootViewTransitionName;
      $$$config.cloneRootViewTransitionContainer;
      $$$config.removeRootViewTransitionClone;
      $$$config.measureClonedInstance;
      $$$config.hasInstanceChanged;
      $$$config.hasInstanceAffectedParent;
      $$$config.startViewTransition;
      $$$config.startGestureTransition;
      $$$config.stopGestureTransition;
      $$$config.getCurrentGestureOffset;
      $$$config.subscribeToGestureDirection;
      $$$config.createViewTransitionInstance;
      var clearContainer = $$$config.clearContainer;
      $$$config.createFragmentInstance;
      $$$config.updateFragmentInstanceFiber;
      $$$config.commitNewChildToFragmentInstance;
      $$$config.deleteChildFromFragmentInstance;
      var cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getNextHydratableSiblingAfterSingleton = $$$config.getNextHydratableSiblingAfterSingleton, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton = $$$config.getFirstHydratableChildWithinSingleton, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, isSingletonScope = $$$config.isSingletonScope, valueStack = [];
      var fiberStack = [];
      var index$jscomp$0 = -1, emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /["'&<>\n\t]|^\s|\s$/, current = null, isRendering = false, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date;
        getCurrentTime = function() {
          return localDate.now();
        };
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is, NoMode = 0, valueCursor = createCursor(null);
      var rendererCursorDEV = createCursor(null);
      var renderer2CursorDEV = createCursor(null);
      var rendererSigil = {};
      var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      }, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function() {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function() {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
      };
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
          componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillMountWarnings = []);
        var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
          UNSAFE_componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillMountWarnings = []);
        var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
          componentWillReceivePropsUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillReceivePropsWarnings = []);
        var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
          function(fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }
        ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
        var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
          componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillUpdateWarnings = []);
        var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
        if (0 < UNSAFE_componentWillMountUniqueNames.size) {
          var sortedNames = setToSortedString(
            UNSAFE_componentWillMountUniqueNames
          );
          console.error(
            "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
            sortedNames
          );
        }
        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
          UNSAFE_componentWillReceivePropsUniqueNames
        ), console.error(
          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
          UNSAFE_componentWillUpdateUniqueNames
        ), console.error(
          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
          componentWillReceivePropsUniqueNames
        ), console.warn(
          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      };
      var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = null;
        for (var node = fiber; null !== node; )
          node.mode & 8 && (strictRoot = node), node = node.return;
        null === strictRoot ? console.error(
          "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
        ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
      };
      ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray) {
          if (0 !== fiberArray.length) {
            var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            runWithFiberInDEV(firstFiber, function() {
              console.error(
                "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                sortedNames
              );
            });
          }
        });
      };
      ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = /* @__PURE__ */ new Map();
      };
      var SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), SuspenseyCommitException = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), SuspenseActionException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
      ), noopSuspenseyCommitThenable = {
        then: function() {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
      var didWarnUpdateInsideUpdate = false;
      var currentlyProcessingQueue = null;
      var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
      var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
      var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      HooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          mountHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(createDeps);
          return mountEffect(create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          mountHookTypesDev();
          checkDepsAreArrayDev(deps);
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          mountHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          mountHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          mountHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          mountHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          mountHookTypesDev();
          return mountId();
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          mountHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState);
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          mountHookTypesDev();
          return mountRefresh();
        }
      };
      HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          return mountEffect(create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return mountId();
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return mountActionState(action, initialState);
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return mountRefresh();
        }
      };
      HooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return updateActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return updateActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        }
      };
      HooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        use,
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          updateHookTypesDev();
          return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          updateHookTypesDev();
          return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return rerenderActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        },
        useHostTransitionStatus,
        useMemoCache,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        }
      };
      InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountEffect(create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          mountEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          mountHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountId();
        },
        useFormState: function(action, initialState) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useActionState: function(action, initialState) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState);
        },
        useOptimistic: function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          mountHookTypesDev();
          return mountRefresh();
        }
      };
      InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        }
      };
      InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          warnInvalidContextAccess();
          return readContext(context);
        },
        use: function(usable) {
          warnInvalidHookAccess();
          return use(usable);
        },
        useCallback: function(callback, deps) {
          currentHookNameInDev = "useCallback";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateCallback(callback, deps);
        },
        useContext: function(context) {
          currentHookNameInDev = "useContext";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return readContext(context);
        },
        useEffect: function(create, createDeps) {
          currentHookNameInDev = "useEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          updateEffectImpl(2048, Passive, create, createDeps);
        },
        useImperativeHandle: function(ref, create, deps) {
          currentHookNameInDev = "useImperativeHandle";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateImperativeHandle(ref, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          currentHookNameInDev = "useInsertionEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Insertion, create, deps);
        },
        useLayoutEffect: function(create, deps) {
          currentHookNameInDev = "useLayoutEffect";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateEffectImpl(4, Layout, create, deps);
        },
        useMemo: function(create, deps) {
          currentHookNameInDev = "useMemo";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create, deps);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useRef: function() {
          currentHookNameInDev = "useRef";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useState: function() {
          currentHookNameInDev = "useState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderReducer(basicStateReducer);
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        },
        useDebugValue: function() {
          currentHookNameInDev = "useDebugValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
        },
        useDeferredValue: function(value, initialValue) {
          currentHookNameInDev = "useDeferredValue";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderDeferredValue(value, initialValue);
        },
        useTransition: function() {
          currentHookNameInDev = "useTransition";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderTransition();
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          currentHookNameInDev = "useSyncExternalStore";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        },
        useId: function() {
          currentHookNameInDev = "useId";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        },
        useFormState: function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useActionState: function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        },
        useOptimistic: function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        },
        useMemoCache: function(size) {
          warnInvalidHookAccess();
          return useMemoCache(size);
        },
        useHostTransitionStatus,
        useCacheRefresh: function() {
          currentHookNameInDev = "useCacheRefresh";
          updateHookTypesDev();
          return updateWorkInProgressHook().memoizedState;
        }
      };
      var callComponent = {
        "react-stack-bottom-frame": function(Component2, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = true;
          try {
            return Component2(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
        "react-stack-bottom-frame": function(instance) {
          var wasRendering = isRendering;
          isRendering = true;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
        "react-stack-bottom-frame": function(finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
        "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
        "react-stack-bottom-frame": function(instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
        "react-stack-bottom-frame": function(current2, nearestMountedAncestor, instance) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
      }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
        "react-stack-bottom-frame": function(effect) {
          null != effect.resourceKind && console.error(
            "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
            effect.resourceKind
          );
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return effect.destroy = create;
        }
      }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
        "react-stack-bottom-frame": function(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
      }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
        "react-stack-bottom-frame": function(lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
      var didWarnAboutGenerators = didWarnAboutMaps = false;
      var ownerHasKeyUseWarning = {};
      var ownerHasFunctionTypeWarning = {};
      var ownerHasSymbolTypeWarning = {};
      warnForMissingKey = function(returnFiber, workInProgress2, child) {
        if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
          if ("object" !== typeof child._store)
            throw Error(
              "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
            );
          child._store.validated = 1;
          var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
          if (!ownerHasKeyUseWarning[componentKey]) {
            ownerHasKeyUseWarning[componentKey] = true;
            child = child._owner;
            returnFiber = returnFiber._debugOwner;
            var currentComponentErrorInfo = "";
            returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
            currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
            var childOwnerAppendix = "";
            null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
            runWithFiberInDEV(workInProgress2, function() {
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                currentComponentErrorInfo,
                childOwnerAppendix
              );
            });
          }
        }
      };
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      Object.freeze(fakeInternalInstance);
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst), update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
      }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ), didReceiveUpdate = false;
      var didWarnAboutBadClass = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutContextTypes = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutRevealOrder = {};
      var didWarnAboutTailOptions = {};
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        getOwner: function() {
          return current;
        }
      }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
      if ("function" === typeof Symbol && Symbol.for) {
        var symbolFor = Symbol.for;
        COMPONENT_TYPE = symbolFor("selector.component");
        HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
        ROLE_TYPE = symbolFor("selector.role");
        TEST_NAME_TYPE = symbolFor("selector.test_id");
        TEXT_TYPE = symbolFor("selector.text");
      }
      var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;
      var hasBadMapPolyfill = false;
      try {
        var nonExtensibleObject = Object.preventExtensions({});
        /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
        /* @__PURE__ */ new Set([nonExtensibleObject]);
      } catch (e) {
        hasBadMapPolyfill = true;
      }
      var didWarnAboutNestedUpdates = false;
      var didWarnAboutFindNodeInStrictMode = {};
      var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
      overrideHookState = function(fiber, id, path3, value) {
        id = findHook(fiber, id);
        null !== id && (path3 = copyWithSetImpl(id.memoizedState, path3, 0, value), id.memoizedState = path3, id.baseState = path3, fiber.memoizedProps = assign({}, fiber.memoizedProps), path3 = enqueueConcurrentRenderForLane(fiber, 2), null !== path3 && scheduleUpdateOnFiber(path3, fiber, 2));
      };
      overrideHookStateDeletePath = function(fiber, id, path3) {
        id = findHook(fiber, id);
        null !== id && (path3 = copyWithDeleteImpl(id.memoizedState, path3, 0), id.memoizedState = path3, id.baseState = path3, fiber.memoizedProps = assign({}, fiber.memoizedProps), path3 = enqueueConcurrentRenderForLane(fiber, 2), null !== path3 && scheduleUpdateOnFiber(path3, fiber, 2));
      };
      overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
        id = findHook(fiber, id);
        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
      };
      overrideProps = function(fiber, path3, value) {
        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path3, 0, value);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path3 && scheduleUpdateOnFiber(path3, fiber, 2);
      };
      overridePropsDeletePath = function(fiber, path3) {
        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path3, 0);
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        path3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== path3 && scheduleUpdateOnFiber(path3, fiber, 2);
      };
      overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(
          fiber.memoizedProps,
          oldPath,
          newPath
        );
        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        oldPath = enqueueConcurrentRenderForLane(fiber, 2);
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
      };
      scheduleUpdate = function(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
      };
      setErrorHandler = function(newShouldErrorImpl) {
        shouldErrorImpl = newShouldErrorImpl;
      };
      setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
      };
      exports3.attemptContinuousHydration = function(fiber) {
        if (13 === fiber.tag) {
          var root = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      };
      exports3.attemptHydrationAtCurrentPriority = function(fiber) {
        if (13 === fiber.tag) {
          var lane = requestUpdateLane(fiber);
          lane = getBumpedLaneForHydrationByLane(lane);
          var root = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root && scheduleUpdateOnFiber(root, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      };
      exports3.attemptSynchronousHydration = function(fiber) {
        switch (fiber.tag) {
          case 3:
            fiber = fiber.stateNode;
            if (fiber.current.memoizedState.isDehydrated) {
              var lanes = getHighestPriorityLanes(fiber.pendingLanes);
              if (0 !== lanes) {
                fiber.pendingLanes |= 2;
                for (fiber.entangledLanes |= 2; lanes; ) {
                  var lane = 1 << 31 - clz32(lanes);
                  fiber.entanglements[1] |= lane;
                  lanes &= ~lane;
                }
                ensureRootIsScheduled(fiber);
                (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
              }
            }
            break;
          case 13:
            lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);
        }
      };
      exports3.batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports3.createComponentSelector = function(component) {
        return { $$typeof: COMPONENT_TYPE, value: component };
      };
      exports3.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {
        return createFiberRoot(
          containerInfo,
          tag,
          false,
          null,
          hydrationCallbacks,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
      };
      exports3.createHasPseudoClassSelector = function(selectors) {
        return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
      };
      exports3.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        initialChildren = createFiberRoot(
          containerInfo,
          tag,
          true,
          initialChildren,
          hydrationCallbacks,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        containerInfo = initialChildren.current;
        tag = requestUpdateLane(containerInfo);
        tag = getBumpedLaneForHydrationByLane(tag);
        hydrationCallbacks = createUpdate(tag);
        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;
        enqueueUpdate(containerInfo, hydrationCallbacks, tag);
        callback = tag;
        initialChildren.current.lanes = callback;
        markRootUpdated$1(initialChildren, callback);
        ensureRootIsScheduled(initialChildren);
        return initialChildren;
      };
      exports3.createPortal = function(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e$6) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      };
      exports3.createRoleSelector = function(role) {
        return { $$typeof: ROLE_TYPE, value: role };
      };
      exports3.createTestNameSelector = function(id) {
        return { $$typeof: TEST_NAME_TYPE, value: id };
      };
      exports3.createTextSelector = function(text) {
        return { $$typeof: TEXT_TYPE, value: text };
      };
      exports3.defaultOnCaughtError = function(error) {
        var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
        "object" === typeof error && null !== error && "string" === typeof error.environmentName ? bindToConsole(
          "error",
          ["%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage],
          error.environmentName
        )() : console.error(
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
        );
      };
      exports3.defaultOnRecoverableError = function(error) {
        reportGlobalError(error);
      };
      exports3.defaultOnUncaughtError = function(error) {
        reportGlobalError(error);
        console.warn(
          "%s\n\n%s\n",
          componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
          "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
        );
      };
      exports3.deferredUpdates = function(fn) {
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;
        }
      };
      exports3.discreteUpdates = function(fn, a, b, c, d) {
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);
        }
      };
      exports3.findAllNodes = findAllNodes;
      exports3.findBoundingRects = function(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw Error("Test selector API is not supported by this renderer.");
        selectors = findAllNodes(hostRoot, selectors);
        hostRoot = [];
        for (var i = 0; i < selectors.length; i++)
          hostRoot.push(getBoundingRect(selectors[i]));
        for (selectors = hostRoot.length - 1; 0 < selectors; selectors--) {
          i = hostRoot[selectors];
          for (var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)
            if (selectors !== j) {
              var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
              if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                hostRoot.splice(selectors, 1);
                break;
              } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {
                otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);
                otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);
                hostRoot.splice(selectors, 1);
                break;
              } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {
                otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);
                otherRight < targetRight && (otherRect.width = targetRight - otherLeft);
                hostRoot.splice(selectors, 1);
                break;
              }
            }
        }
        return hostRoot;
      };
      exports3.findHostInstance = function(component) {
        var fiber = component._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof component.render)
            throw Error("Unable to find node on an unmounted component.");
          component = Object.keys(component).join(",");
          throw Error(
            "Argument appears to not be a ReactComponent. Keys: " + component
          );
        }
        component = findCurrentHostFiber(fiber);
        return null === component ? null : getPublicInstance(component.stateNode);
      };
      exports3.findHostInstanceWithNoPortals = function(fiber) {
        fiber = findCurrentFiberUsingSlowPath(fiber);
        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
        return null === fiber ? null : getPublicInstance(fiber.stateNode);
      };
      exports3.findHostInstanceWithWarning = function(component, methodName) {
        var fiber = component._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof component.render)
            throw Error("Unable to find node on an unmounted component.");
          component = Object.keys(component).join(",");
          throw Error(
            "Argument appears to not be a ReactComponent. Keys: " + component
          );
        }
        component = findCurrentHostFiber(fiber);
        if (null === component) return null;
        if (component.mode & 8) {
          var componentName2 = getComponentNameFromFiber(fiber) || "Component";
          didWarnAboutFindNodeInStrictMode[componentName2] || (didWarnAboutFindNodeInStrictMode[componentName2] = true, runWithFiberInDEV(component, function() {
            fiber.mode & 8 ? console.error(
              "%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
              methodName,
              methodName,
              componentName2
            ) : console.error(
              "%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
              methodName,
              methodName,
              componentName2
            );
          }));
        }
        return getPublicInstance(component.stateNode);
      };
      exports3.flushPassiveEffects = flushPendingEffects;
      exports3.flushSyncFromReconciler = function(fn) {
        var prevExecutionContext = executionContext;
        executionContext |= 1;
        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
        try {
          if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn)
            return fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, false);
        }
      };
      exports3.flushSyncWork = flushSyncWork;
      exports3.focusWithin = function(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw Error("Test selector API is not supported by this renderer.");
        hostRoot = findFiberRootForHostRoot(hostRoot);
        selectors = findPaths(hostRoot, selectors);
        selectors = Array.from(selectors);
        for (hostRoot = 0; hostRoot < selectors.length; ) {
          var fiber = selectors[hostRoot++], tag = fiber.tag;
          if (!isHiddenSubtree(fiber)) {
            if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode))
              return true;
            for (fiber = fiber.child; null !== fiber; )
              selectors.push(fiber), fiber = fiber.sibling;
          }
        }
        return false;
      };
      exports3.getFindAllNodesFailureDescription = function(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw Error("Test selector API is not supported by this renderer.");
        var maxSelectorIndex = 0, matchedNames = [];
        hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
        for (var index = 0; index < hostRoot.length; ) {
          var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];
          if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {
            if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length)
              for (fiber = fiber.child; null !== fiber; )
                hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;
          }
        }
        if (maxSelectorIndex < selectors.length) {
          for (hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)
            hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
          return "findAllNodes was able to match part of the selector:\n  " + (matchedNames.join(" > ") + "\n\nNo matching component was found for:\n  ") + hostRoot.join(" > ");
        }
        return null;
      };
      exports3.getPublicRootInstance = function(container) {
        container = container.current;
        if (!container.child) return null;
        switch (container.child.tag) {
          case 27:
          case 5:
            return getPublicInstance(container.child.stateNode);
          default:
            return container.child.stateNode;
        }
      };
      exports3.injectIntoDevTools = function() {
        var internals = {
          bundleType: 1,
          version: rendererVersion,
          rendererPackageName,
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: "19.1.0"
        };
        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        internals.getLaneLabelMap = getLaneLabelMap;
        internals.injectProfilingHooks = injectProfilingHooks;
        return injectInternals(internals);
      };
      exports3.isAlreadyRendering = function() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      };
      exports3.observeVisibleRects = function(hostRoot, selectors, callback, options) {
        function commitHook() {
          var nextInstanceRoots = findAllNodes(hostRoot, selectors);
          instanceRoots.forEach(function(target) {
            0 > nextInstanceRoots.indexOf(target) && unobserve(target);
          });
          nextInstanceRoots.forEach(function(target) {
            0 > instanceRoots.indexOf(target) && observe(target);
          });
        }
        if (!supportsTestSelectors)
          throw Error("Test selector API is not supported by this renderer.");
        var instanceRoots = findAllNodes(hostRoot, selectors);
        callback = setupIntersectionObserver(instanceRoots, callback, options);
        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;
        commitHooks.push(commitHook);
        return {
          disconnect: function() {
            var index = commitHooks.indexOf(commitHook);
            0 <= index && commitHooks.splice(index, 1);
            disconnect();
          }
        };
      };
      exports3.shouldError = function(fiber) {
        return shouldErrorImpl(fiber);
      };
      exports3.shouldSuspend = function(fiber) {
        return shouldSuspendImpl(fiber);
      };
      exports3.startHostTransition = function(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag)
          throw Error(
            "Expected the form instance to be a HostComponent. This is a bug in React."
          );
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          NotPendingTransition,
          null === action ? noop : function() {
            null === ReactSharedInternals.T && console.error(
              "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
            );
            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
            dispatchSetStateInternal(
              formFiber,
              resetStateQueue,
              {},
              requestUpdateLane(formFiber)
            );
            return action(formData);
          }
        );
      };
      exports3.updateContainer = function(element, container, parentComponent, callback) {
        var current2 = container.current, lane = requestUpdateLane(current2);
        updateContainerImpl(
          current2,
          lane,
          element,
          container,
          parentComponent,
          callback
        );
        return lane;
      };
      exports3.updateContainerSync = updateContainerSync;
      return exports3;
    }, module2.exports.default = module2.exports, Object.defineProperty(module2.exports, "__esModule", { value: true }));
  }
});

// node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS({
  "node_modules/react-reconciler/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_reconciler_production();
    } else {
      module2.exports = require_react_reconciler_development();
    }
  }
});

// node_modules/react-reconciler/cjs/react-reconciler-constants.production.js
var require_react_reconciler_constants_production = __commonJS({
  "node_modules/react-reconciler/cjs/react-reconciler-constants.production.js"(exports2) {
    "use strict";
    exports2.ConcurrentRoot = 1;
    exports2.ContinuousEventPriority = 8;
    exports2.DefaultEventPriority = 32;
    exports2.DiscreteEventPriority = 2;
    exports2.IdleEventPriority = 268435456;
    exports2.LegacyRoot = 0;
    exports2.NoEventPriority = 0;
  }
});

// node_modules/react-reconciler/cjs/react-reconciler-constants.development.js
var require_react_reconciler_constants_development = __commonJS({
  "node_modules/react-reconciler/cjs/react-reconciler-constants.development.js"(exports2) {
    "use strict";
    "production" !== process.env.NODE_ENV && (exports2.ConcurrentRoot = 1, exports2.ContinuousEventPriority = 8, exports2.DefaultEventPriority = 32, exports2.DiscreteEventPriority = 2, exports2.IdleEventPriority = 268435456, exports2.LegacyRoot = 0, exports2.NoEventPriority = 0);
  }
});

// node_modules/react-reconciler/constants.js
var require_constants = __commonJS({
  "node_modules/react-reconciler/constants.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_reconciler_constants_production();
    } else {
      module2.exports = require_react_reconciler_constants_development();
    }
  }
});

// src/index.ts
var import_node_crypto8 = require("node:crypto");
var fs = __toESM(require("node:fs"));
var import_node_tty = require("node:tty");
var import_node_worker_threads3 = require("node:worker_threads");

// src/globals.ts
globalThis.vicinae = {
  environ: {},
  preferences: {}
};

// src/worker.tsx
var import_node_worker_threads2 = require("node:worker_threads");
init_src();

// src/patch-require.ts
var import_node_module = __toESM(require("node:module"));
var requireOverrides = {
  react: () => require_react(),
  "react/jsx-runtime": () => require_jsx_runtime(),
  "@vicinae/api": () => (init_src(), __toCommonJS(src_exports)),
  "@raycast/api": () => (init_src2(), __toCommonJS(src_exports2))
};
var injectJsxGlobals = () => {
  const { jsx: jsx13, jsxs: jsxs5, Fragment: Fragment2 } = require_jsx_runtime();
  const safeJsx = (original) => (type, props, key) => original(type, props ?? {}, key);
  globalThis._jsx = safeJsx(jsx13);
  globalThis._jsxs = safeJsx(jsxs5);
  globalThis._jsxFragment = Fragment2;
};
var patchRequire = () => {
  injectJsxGlobals();
  const originalRequire = import_node_module.default.prototype.require;
  import_node_module.default.prototype.require = function(id) {
    return requireOverrides[id]?.() ?? originalRequire.call(this, id);
  };
};

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read2() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write2(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL2 = 4294967296;
function int64FromString2(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL2) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL2 | 0);
      lowBits = lowBits % TWO_PWR_32_DBL2;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate2(lowBits, highBits) : newBits2(lowBits, highBits);
}
function int64ToString2(lo, hi) {
  let bits = newBits2(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate2(bits.lo, bits.hi);
  }
  const result = uInt64ToString2(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString2(lo, hi) {
  ({ lo, hi } = toUnsigned2(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL2 * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros2(digitB) + decimalFrom1e7WithLeadingZeros2(digitA);
}
function toUnsigned2(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits2(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate2(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits2(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros2 = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write2(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read2() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt642 = /* @__PURE__ */ makeInt64Support2();
function makeInt64Support2() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String2(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String2(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String2(value);
      return int64FromString2(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String2(value);
      return int64FromString2(value);
    },
    dec(lo, hi) {
      return int64ToString2(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString2(lo, hi);
    }
  };
}
function assertInt64String2(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String2(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol2 = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding2() {
  if (globalThis[symbol2] == void 0) {
    const te = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol2] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol2];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType2;
(function(WireType3) {
  WireType3[WireType3["Varint"] = 0] = "Varint";
  WireType3[WireType3["Bit64"] = 1] = "Bit64";
  WireType3[WireType3["LengthDelimited"] = 2] = "LengthDelimited";
  WireType3[WireType3["StartGroup"] = 3] = "StartGroup";
  WireType3[WireType3["EndGroup"] = 4] = "EndGroup";
  WireType3[WireType3["Bit32"] = 5] = "Bit32";
})(WireType2 || (WireType2 = {}));
var FLOAT32_MAX2 = 34028234663852886e22;
var FLOAT32_MIN2 = -34028234663852886e22;
var UINT32_MAX2 = 4294967295;
var INT32_MAX2 = 2147483647;
var INT32_MIN2 = -2147483648;
var BinaryWriter2 = class {
  constructor(encodeUtf8 = getTextEncoding2().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt322(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt322(value);
    varint32write2(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat322(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt322(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt322(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt322(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write2(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt642.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt642.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt642.enc(value);
    varint64write2(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    const tc = protoInt642.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write2(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    const tc = protoInt642.uEnc(value);
    varint64write2(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader2 = class {
  constructor(buf, decodeUtf8 = getTextEncoding2().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read2;
    this.uint32 = varint32read2;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType2.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case WireType2.Bit64:
        this.pos += 4;
      case WireType2.Bit32:
        this.pos += 4;
        break;
      case WireType2.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType2.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType2.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt642.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt642.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt642.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt642.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt642.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
};
function assertInt322(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX2 || arg < INT32_MIN2)
    throw new Error("invalid int32: " + arg);
}
function assertUInt322(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX2 || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat322(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX2 || arg < FLOAT32_MIN2))
    throw new Error("invalid float32: " + arg);
}

// src/proto/common.ts
function createBaseAckResponse2() {
  return {};
}
var AckResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAckResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AckResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAckResponse2();
    return message;
  }
};
function createBaseErrorResponse2() {
  return { errorText: "" };
}
var ErrorResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.errorText !== "") {
      writer.uint32(10).string(message.errorText);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.errorText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { errorText: isSet13(object.errorText) ? globalThis.String(object.errorText) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.errorText !== "") {
      obj.errorText = message.errorText;
    }
    return obj;
  },
  create(base) {
    return ErrorResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseErrorResponse2();
    message.errorText = object.errorText ?? "";
    return message;
  }
};
function isSet13(value) {
  return value !== null && value !== void 0;
}

// src/proto/google/protobuf/struct.ts
function nullValueFromJSON2(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return 0 /* NULL_VALUE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function nullValueToJSON2(object) {
  switch (object) {
    case 0 /* NULL_VALUE */:
      return "NULL_VALUE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseStruct2() {
  return { fields: {} };
}
var Struct2 = {
  encode(message, writer = new BinaryWriter2()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        Struct_FieldsEntry2.encode({ key, value }, writer.uint32(10).fork()).join();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = Struct_FieldsEntry2.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isObject4(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return Struct2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct2();
    message.fields = Object.entries(object.fields ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    return message;
  },
  wrap(object) {
    const struct = createBaseStruct2();
    if (object !== void 0) {
      for (const key of Object.keys(object)) {
        struct.fields[key] = object[key];
      }
    }
    return struct;
  },
  unwrap(message) {
    const object = {};
    if (message.fields) {
      for (const key of Object.keys(message.fields)) {
        object[key] = message.fields[key];
      }
    }
    return object;
  }
};
function createBaseStruct_FieldsEntry2() {
  return { key: "", value: void 0 };
}
var Struct_FieldsEntry2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet14(object.key) ? globalThis.String(object.key) : "",
      value: isSet14(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Struct_FieldsEntry2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct_FieldsEntry2();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseValue2() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
var Value2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.nullValue !== void 0) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      Struct2.encode(Struct2.wrap(message.structValue), writer.uint32(42).fork()).join();
    }
    if (message.listValue !== void 0) {
      ListValue2.encode(ListValue2.wrap(message.listValue), writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.nullValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.numberValue = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.structValue = Struct2.unwrap(Struct2.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.listValue = ListValue2.unwrap(ListValue2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      nullValue: isSet14(object.nullValue) ? nullValueFromJSON2(object.nullValue) : void 0,
      numberValue: isSet14(object.numberValue) ? globalThis.Number(object.numberValue) : void 0,
      stringValue: isSet14(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
      boolValue: isSet14(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0,
      structValue: isObject4(object.structValue) ? object.structValue : void 0,
      listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.nullValue !== void 0) {
      obj.nullValue = nullValueToJSON2(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      obj.numberValue = message.numberValue;
    }
    if (message.stringValue !== void 0) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== void 0) {
      obj.boolValue = message.boolValue;
    }
    if (message.structValue !== void 0) {
      obj.structValue = message.structValue;
    }
    if (message.listValue !== void 0) {
      obj.listValue = message.listValue;
    }
    return obj;
  },
  create(base) {
    return Value2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValue2();
    message.nullValue = object.nullValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.stringValue = object.stringValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.structValue = object.structValue ?? void 0;
    message.listValue = object.listValue ?? void 0;
    return message;
  },
  wrap(value) {
    const result = createBaseValue2();
    if (value === null) {
      result.nullValue = 0 /* NULL_VALUE */;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (globalThis.Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new globalThis.Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },
  unwrap(message) {
    if (message.stringValue !== void 0) {
      return message.stringValue;
    } else if (message?.numberValue !== void 0) {
      return message.numberValue;
    } else if (message?.boolValue !== void 0) {
      return message.boolValue;
    } else if (message?.structValue !== void 0) {
      return message.structValue;
    } else if (message?.listValue !== void 0) {
      return message.listValue;
    } else if (message?.nullValue !== void 0) {
      return null;
    }
    return void 0;
  }
};
function createBaseListValue2() {
  return { values: [] };
}
var ListValue2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.values) {
      Value2.encode(Value2.wrap(v), writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListValue2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.values.push(Value2.unwrap(Value2.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return ListValue2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListValue2();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
  wrap(array) {
    const result = createBaseListValue2();
    result.values = array ?? [];
    return result;
  },
  unwrap(message) {
    if (message?.hasOwnProperty("values") && globalThis.Array.isArray(message.values)) {
      return message.values;
    } else {
      return message;
    }
  }
};
function isObject4(value) {
  return typeof value === "object" && value !== null;
}
function isSet14(value) {
  return value !== null && value !== void 0;
}

// src/proto/manager.ts
function commandModeFromJSON2(object) {
  switch (object) {
    case 0:
    case "View":
      return 0 /* View */;
    case 1:
    case "NoView":
      return 1 /* NoView */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function commandModeToJSON2(object) {
  switch (object) {
    case 0 /* View */:
      return "View";
    case 1 /* NoView */:
      return "NoView";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function commandEnvFromJSON(object) {
  switch (object) {
    case 0:
    case "Development":
      return 0 /* Development */;
    case 1:
    case "Production":
      return 1 /* Production */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function commandEnvToJSON(object) {
  switch (object) {
    case 0 /* Development */:
      return "Development";
    case 1 /* Production */:
      return "Production";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseRequestData2() {
  return { ping: void 0, load: void 0, unload: void 0 };
}
var RequestData3 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ping !== void 0) {
      ManagerPingRequestData.encode(message.ping, writer.uint32(10).fork()).join();
    }
    if (message.load !== void 0) {
      ManagerLoadCommand.encode(message.load, writer.uint32(18).fork()).join();
    }
    if (message.unload !== void 0) {
      ManagerUnloadCommand.encode(message.unload, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ping = ManagerPingRequestData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.load = ManagerLoadCommand.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.unload = ManagerUnloadCommand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ping: isSet15(object.ping) ? ManagerPingRequestData.fromJSON(object.ping) : void 0,
      load: isSet15(object.load) ? ManagerLoadCommand.fromJSON(object.load) : void 0,
      unload: isSet15(object.unload) ? ManagerUnloadCommand.fromJSON(object.unload) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ping !== void 0) {
      obj.ping = ManagerPingRequestData.toJSON(message.ping);
    }
    if (message.load !== void 0) {
      obj.load = ManagerLoadCommand.toJSON(message.load);
    }
    if (message.unload !== void 0) {
      obj.unload = ManagerUnloadCommand.toJSON(message.unload);
    }
    return obj;
  },
  create(base) {
    return RequestData3.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequestData2();
    message.ping = object.ping !== void 0 && object.ping !== null ? ManagerPingRequestData.fromPartial(object.ping) : void 0;
    message.load = object.load !== void 0 && object.load !== null ? ManagerLoadCommand.fromPartial(object.load) : void 0;
    message.unload = object.unload !== void 0 && object.unload !== null ? ManagerUnloadCommand.fromPartial(object.unload) : void 0;
    return message;
  }
};
function createBaseManagerPingRequestData() {
  return {};
}
var ManagerPingRequestData = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerPingRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ManagerPingRequestData.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseManagerPingRequestData();
    return message;
  }
};
function createBaseResponseData2() {
  return { ack: void 0, load: void 0 };
}
var ResponseData3 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ack !== void 0) {
      AckResponse2.encode(message.ack, writer.uint32(10).fork()).join();
    }
    if (message.load !== void 0) {
      ManagerLoadResponseData.encode(message.load, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponseData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ack = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.load = ManagerLoadResponseData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ack: isSet15(object.ack) ? AckResponse2.fromJSON(object.ack) : void 0,
      load: isSet15(object.load) ? ManagerLoadResponseData.fromJSON(object.load) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ack !== void 0) {
      obj.ack = AckResponse2.toJSON(message.ack);
    }
    if (message.load !== void 0) {
      obj.load = ManagerLoadResponseData.toJSON(message.load);
    }
    return obj;
  },
  create(base) {
    return ResponseData3.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponseData2();
    message.ack = object.ack !== void 0 && object.ack !== null ? AckResponse2.fromPartial(object.ack) : void 0;
    message.load = object.load !== void 0 && object.load !== null ? ManagerLoadResponseData.fromPartial(object.load) : void 0;
    return message;
  }
};
function createBaseManagerLoadCommand() {
  return {
    mode: 0,
    env: 0,
    vicinaePath: "",
    entrypoint: "",
    preferenceValues: {},
    argumentValues: {},
    isRaycast: false,
    commandName: "",
    extensionId: "",
    extensionName: "",
    ownerOrAuthorName: ""
  };
}
var ManagerLoadCommand = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.env !== 0) {
      writer.uint32(16).int32(message.env);
    }
    if (message.vicinaePath !== "") {
      writer.uint32(26).string(message.vicinaePath);
    }
    if (message.entrypoint !== "") {
      writer.uint32(34).string(message.entrypoint);
    }
    Object.entries(message.preferenceValues).forEach(([key, value]) => {
      if (value !== void 0) {
        ManagerLoadCommand_PreferenceValuesEntry.encode({ key, value }, writer.uint32(42).fork()).join();
      }
    });
    Object.entries(message.argumentValues).forEach(([key, value]) => {
      if (value !== void 0) {
        ManagerLoadCommand_ArgumentValuesEntry.encode({ key, value }, writer.uint32(50).fork()).join();
      }
    });
    if (message.isRaycast !== false) {
      writer.uint32(56).bool(message.isRaycast);
    }
    if (message.commandName !== "") {
      writer.uint32(66).string(message.commandName);
    }
    if (message.extensionId !== "") {
      writer.uint32(74).string(message.extensionId);
    }
    if (message.extensionName !== "") {
      writer.uint32(82).string(message.extensionName);
    }
    if (message.ownerOrAuthorName !== "") {
      writer.uint32(90).string(message.ownerOrAuthorName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerLoadCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.mode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.env = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.vicinaePath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.entrypoint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          const entry5 = ManagerLoadCommand_PreferenceValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.preferenceValues[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          const entry6 = ManagerLoadCommand_ArgumentValuesEntry.decode(reader, reader.uint32());
          if (entry6.value !== void 0) {
            message.argumentValues[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.isRaycast = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.commandName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.extensionId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.extensionName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.ownerOrAuthorName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mode: isSet15(object.mode) ? commandModeFromJSON2(object.mode) : 0,
      env: isSet15(object.env) ? commandEnvFromJSON(object.env) : 0,
      vicinaePath: isSet15(object.vicinaePath) ? globalThis.String(object.vicinaePath) : "",
      entrypoint: isSet15(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      preferenceValues: isObject5(object.preferenceValues) ? Object.entries(object.preferenceValues).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {},
      argumentValues: isObject5(object.argumentValues) ? Object.entries(object.argumentValues).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {},
      isRaycast: isSet15(object.isRaycast) ? globalThis.Boolean(object.isRaycast) : false,
      commandName: isSet15(object.commandName) ? globalThis.String(object.commandName) : "",
      extensionId: isSet15(object.extensionId) ? globalThis.String(object.extensionId) : "",
      extensionName: isSet15(object.extensionName) ? globalThis.String(object.extensionName) : "",
      ownerOrAuthorName: isSet15(object.ownerOrAuthorName) ? globalThis.String(object.ownerOrAuthorName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mode !== 0) {
      obj.mode = commandModeToJSON2(message.mode);
    }
    if (message.env !== 0) {
      obj.env = commandEnvToJSON(message.env);
    }
    if (message.vicinaePath !== "") {
      obj.vicinaePath = message.vicinaePath;
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.preferenceValues) {
      const entries = Object.entries(message.preferenceValues);
      if (entries.length > 0) {
        obj.preferenceValues = {};
        entries.forEach(([k, v]) => {
          obj.preferenceValues[k] = v;
        });
      }
    }
    if (message.argumentValues) {
      const entries = Object.entries(message.argumentValues);
      if (entries.length > 0) {
        obj.argumentValues = {};
        entries.forEach(([k, v]) => {
          obj.argumentValues[k] = v;
        });
      }
    }
    if (message.isRaycast !== false) {
      obj.isRaycast = message.isRaycast;
    }
    if (message.commandName !== "") {
      obj.commandName = message.commandName;
    }
    if (message.extensionId !== "") {
      obj.extensionId = message.extensionId;
    }
    if (message.extensionName !== "") {
      obj.extensionName = message.extensionName;
    }
    if (message.ownerOrAuthorName !== "") {
      obj.ownerOrAuthorName = message.ownerOrAuthorName;
    }
    return obj;
  },
  create(base) {
    return ManagerLoadCommand.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerLoadCommand();
    message.mode = object.mode ?? 0;
    message.env = object.env ?? 0;
    message.vicinaePath = object.vicinaePath ?? "";
    message.entrypoint = object.entrypoint ?? "";
    message.preferenceValues = Object.entries(object.preferenceValues ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    message.argumentValues = Object.entries(object.argumentValues ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    message.isRaycast = object.isRaycast ?? false;
    message.commandName = object.commandName ?? "";
    message.extensionId = object.extensionId ?? "";
    message.extensionName = object.extensionName ?? "";
    message.ownerOrAuthorName = object.ownerOrAuthorName ?? "";
    return message;
  }
};
function createBaseManagerLoadCommand_PreferenceValuesEntry() {
  return { key: "", value: void 0 };
}
var ManagerLoadCommand_PreferenceValuesEntry = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerLoadCommand_PreferenceValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet15(object.key) ? globalThis.String(object.key) : "",
      value: isSet15(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ManagerLoadCommand_PreferenceValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerLoadCommand_PreferenceValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseManagerLoadCommand_ArgumentValuesEntry() {
  return { key: "", value: void 0 };
}
var ManagerLoadCommand_ArgumentValuesEntry = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerLoadCommand_ArgumentValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet15(object.key) ? globalThis.String(object.key) : "",
      value: isSet15(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ManagerLoadCommand_ArgumentValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerLoadCommand_ArgumentValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseManagerUnloadCommand() {
  return { sessionId: "" };
}
var ManagerUnloadCommand = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerUnloadCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sessionId: isSet15(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },
  create(base) {
    return ManagerUnloadCommand.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerUnloadCommand();
    message.sessionId = object.sessionId ?? "";
    return message;
  }
};
function createBaseManagerLoadResponseData() {
  return { sessionId: "" };
}
var ManagerLoadResponseData = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerLoadResponseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sessionId: isSet15(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },
  create(base) {
    return ManagerLoadResponseData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerLoadResponseData();
    message.sessionId = object.sessionId ?? "";
    return message;
  }
};
function isObject5(value) {
  return typeof value === "object" && value !== null;
}
function isSet15(value) {
  return value !== null && value !== void 0;
}

// src/reconciler.ts
var import_react_reconciler = __toESM(require_react_reconciler());
var import_node_timers = require("node:timers");
var import_constants = __toESM(require_constants());
var import_react9 = __toESM(require_react());
init_src();
var ctx2 = {};
var emitDirty = (instance) => {
  let current = instance;
  while (current) {
    current.dirty = true;
    current = current.parent;
  }
};
function traceWrap(hostConfig) {
  let traceWrappedHostConfig = {};
  Object.keys(hostConfig).map((key) => {
    const func = hostConfig[key];
    traceWrappedHostConfig[key] = (...args) => {
      console.log(key);
      return func(...args);
    };
  });
  return traceWrappedHostConfig;
}
var processProps = (props) => {
  const sanitized = {};
  for (const [k, v] of Object.entries(props)) {
    if (import_react9.default.isValidElement(v)) {
      console.error(`React element in props is ignored for key ${k}`);
    } else if (k !== "children") {
      sanitized[k] = v;
    }
  }
  return sanitized;
};
var detachInstance = (instance) => {
  for (const handler of instance._handlers) bus.removeEventHandler(handler);
  for (const child of instance.children) {
    detachInstance(child);
  }
};
var createHostConfig = (hostCtx, callback) => {
  const hostConfig = {
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    createInstance(type, props, root, ctx3, handle) {
      let { children, key, ...rest } = props;
      const initialProps = rest;
      const handlers = [];
      for (const [k, v] of Object.entries(rest)) {
        if (typeof v === "function") {
          const { id } = bus.addEventHandler(v);
          initialProps[k] = id;
          handlers.push(id);
        } else {
          initialProps[k] = v;
        }
      }
      return {
        id: Symbol(type),
        type,
        props: processProps(initialProps),
        children: [],
        dirty: true,
        propsDirty: true,
        _handlers: handlers
      };
    },
    createTextInstance() {
      throw new Error(`createTextInstance is not supported`);
    },
    appendInitialChild(parent, child) {
      hostConfig.appendChild?.(parent, child);
    },
    finalizeInitialChildren(instance, type, props, root, ctx3) {
      return false;
    },
    /*
    		prepareUpdate(instance, type, oldProps, newProps, root, ctx) {
    			const changes = [];
    
    			for (const key in newProps) {
    				if (key === 'children') { continue ; }
    
    				const oldValue = oldProps[key];
    				const newValue = newProps[key];
    
    				if (typeof oldValue !== typeof newValue) {
    					changes.push(key, newValue);
    					continue ;
    				}
    
    				if (typeof newValue === 'object') {
    					if (!isDeepEqual(newValue, oldValue)) {
    						changes.push(key, newValue);
    					}
    					continue ;
    				}
    
    				if (oldValue !== newValue) {
    					changes.push(key, newValue);
    				}
    			}
    
    			return changes.length > 0 ? changes : null;
    		},
    		*/
    shouldSetTextContent() {
      return false;
    },
    getRootHostContext(root) {
      return ctx2;
    },
    getChildHostContext(parentHostContext, type, root) {
      return ctx2;
    },
    getPublicInstance(instance) {
      return instance;
    },
    prepareForCommit(container) {
      return null;
    },
    resetAfterCommit() {
      callback();
      return null;
    },
    preparePortalMount(container) {
    },
    scheduleTimeout: import_node_timers.setTimeout,
    cancelTimeout: (id) => (0, import_node_timers.clearTimeout)(id),
    noTimeout: -1,
    //supportsMicrotasks: false,
    scheduleMicrotask: queueMicrotask,
    isPrimaryRenderer: true,
    /*
    getCurrentEventPriority() {
    	return DefaultEventPriority;
    },
    */
    getInstanceFromNode() {
      return null;
    },
    beforeActiveInstanceBlur() {
    },
    afterActiveInstanceBlur() {
    },
    prepareScopeUpdate(scope, instance) {
    },
    getInstanceFromScope(scope) {
      return null;
    },
    // not sure what this one is really about, as it's undocumented
    detachDeletedInstance(instance) {
    },
    appendChild(parent, child) {
      const selfIdx = parent.children.indexOf(child);
      if (selfIdx != -1) {
        parent.children.splice(selfIdx, 1);
      }
      child.parent = parent;
      emitDirty(parent);
      parent.children.push(child);
    },
    appendChildToContainer(container, child) {
      hostConfig.appendChild?.(container, child);
    },
    insertBefore(parent, child, beforeChild) {
      const beforeIndex = parent.children.indexOf(beforeChild);
      const selfIdx = parent.children.indexOf(child);
      if (selfIdx != -1) {
        parent.children.splice(selfIdx, 1);
      }
      if (beforeIndex != -1) {
        parent.children.splice(beforeIndex, 0, child);
        child.parent = parent;
        emitDirty(parent);
      } else {
        throw new Error("Unreachable");
      }
    },
    insertInContainerBefore(container, child, beforeChild) {
      hostConfig.insertBefore?.(container, child, beforeChild);
    },
    removeChild(parent, child) {
      const idx = parent.children.indexOf(child);
      if (idx == -1) return;
      emitDirty(parent);
      parent.children.splice(idx, 1);
      delete child.parent;
      detachInstance(child);
    },
    removeChildFromContainer(container, child) {
      hostConfig.removeChild?.(container, child);
    },
    resetTextContent() {
    },
    commitTextUpdate() {
    },
    commitMount() {
    },
    commitUpdate(instance, type, prevProps, nextProps, handle) {
      const props = {};
      for (const [k, v] of Object.entries(nextProps)) {
        if (k == "children") continue;
        if (import_react9.default.isValidElement(v)) {
          console.warn(
            `Received react element as prop (key '${k}'), which is unsupported.`
          );
          continue;
        }
        if (typeof v === "function") {
          const old = prevProps[k];
          if (typeof old === "string") {
            bus.replaceEventHandler(old, v);
            props[k] = old;
            continue;
          }
          const { id } = bus.addEventHandler(v);
          instance._handlers.push(id);
          props[k] = id;
          continue;
        }
        props[k] = v;
      }
      emitDirty(instance.parent);
      instance.propsDirty = true;
      instance.props = props;
    },
    replaceContainerChildren() {
    },
    hideInstance() {
    },
    hideTextInstance() {
    },
    unhideInstance() {
    },
    unhideTextInstance() {
    },
    clearContainer(container) {
      container.children = [];
    },
    /** added for react 19 - we don't have to implement most of this */
    NotPendingTransition: null,
    HostTransitionContext: {},
    setCurrentUpdatePriority(priority) {
    },
    getCurrentUpdatePriority() {
      return import_constants.DefaultEventPriority;
    },
    resolveUpdatePriority() {
      return import_constants.DefaultEventPriority;
    },
    resetFormInstance(form) {
    },
    requestPostPaintCallback() {
    },
    shouldAttemptEagerTransition() {
      return false;
    },
    trackSchedulerEvent() {
    },
    resolveEventType() {
      return null;
    },
    resolveEventTimeStamp() {
      return Date.now();
    },
    maySuspendCommit() {
      return false;
    },
    preloadInstance(type, props) {
      return false;
    },
    startSuspendingCommit() {
    },
    suspendInstance(type, props) {
    },
    waitForCommitToBeReady() {
      return null;
    }
  };
  return hostConfig;
};
var serializeInstance = (instance) => {
  const obj = {
    props: instance.props,
    type: instance.type,
    dirty: instance.dirty,
    propsDirty: instance.propsDirty,
    children: instance.children.map(serializeInstance)
  };
  instance.dirty = false;
  instance.propsDirty = false;
  return obj;
};
var createContainer = () => {
  return {
    id: Symbol("root"),
    type: "root",
    dirty: true,
    propsDirty: false,
    props: {},
    children: [],
    _handlers: []
  };
};
var MAX_RENDER_PER_SECOND = 60;
var createRenderer = (config) => {
  const container = createContainer();
  let debounce = null;
  const debounceInterval = 1e3 / MAX_RENDER_PER_SECOND;
  let lastRender = performance.now();
  const renderImpl = () => {
    if (!debounce) {
      debounce = (0, import_node_timers.setTimeout)(() => {
        debounce = null;
        const start = performance.now();
        const root = serializeInstance(container);
        const views = root.children.map((child) => ({
          root: child.children.at(-1)
        }));
        config.onUpdate?.(views);
        const end = performance.now();
        lastRender = end;
      }, debounceInterval);
    }
  };
  const hostConfig = createHostConfig({}, renderImpl);
  const reconciler = (0, import_react_reconciler.default)(
    process.env.RECONCILER_TRACE === "1" ? traceWrap(hostConfig) : hostConfig
  );
  return {
    render(element) {
      if (!container._root) {
        container._root = reconciler.createContainer(
          container,
          0,
          null,
          false,
          null,
          "",
          (error) => {
            throw error;
          },
          (error) => {
            throw error;
          },
          (error) => {
            throw error;
          },
          () => {
          },
          null
        );
      }
      reconciler.updateContainer(element, container._root, null, renderImpl);
    }
  };
};

// src/loaders/load-view-command.tsx
var import_react10 = __toESM(require_react());
var React5 = __toESM(require_react());
init_src();
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var ErrorBoundary = class extends React5.Component {
  constructor(props) {
    super(props);
    this.state = { error: "" };
  }
  componentDidCatch(error) {
    this.setState({ error: `${error.name}: ${error.message}` });
  }
  render() {
    const { error } = this.state;
    if (error) {
      bus.emitCrash(error);
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children: this.props.children });
  }
};
var App = ({
  component: Component2,
  launchProps
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(ErrorBoundary, { children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_react10.Suspense, { fallback: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, {}), children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(NavigationProvider, { root: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Component2, { ...launchProps }) }) }) });
};
async function load_view_command_default(data) {
  const module2 = await import(data.entrypoint);
  const Component2 = module2.default.default;
  const sendRender = (views) => {
    bus.request("ui.render", { json: JSON.stringify({ views }) });
  };
  const renderer = createRenderer({
    onInitialRender: sendRender,
    onUpdate: sendRender
  });
  renderer.render(
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
      App,
      {
        launchProps: { arguments: data.argumentValues },
        component: Component2
      }
    )
  );
}

// src/loaders/load-no-view-command.ts
var load_no_view_command_default = async (data) => {
  const module2 = await import(data.entrypoint);
  const entrypoint = module2.default.default;
  if (typeof entrypoint !== "function") {
    throw new Error(
      `no-view command does not export a function as its default export`
    );
  }
  await entrypoint({ arguments: data.argumentValues });
};

// src/worker.tsx
var loadEnviron = (data) => {
  const g = globalThis;
  Object.assign(g.vicinae.environ, {
    theme: "dark",
    textSize: "medium",
    appearance: "dark",
    canAccess: (_) => false,
    isDevelopment: process.env.NODE_ENV === "development",
    commandName: data.commandName,
    commandMode: data.mode === 0 /* View */ ? "view" : "no-view",
    supportPath: data.supportPath,
    assetsPath: data.assetPath,
    raycastVersion: "1.0.0",
    // provided for compatibility only, not meaningful
    launchType: "userInitiated" /* UserInitiated */,
    extensionName: data.extensionName,
    ownerOrAuthorName: data.ownerOrAuthorName,
    vicinaeVersion: {
      tag: process.env.VICINAE_VERSION ?? "unknown",
      commit: process.env.VICINAE_COMMIT ?? "unknown"
    },
    isRaycast: data.isRaycast
  });
  g.vicinae.preferences = data.preferenceValues;
};
var loaders = {
  [0 /* View */]: load_view_command_default,
  [1 /* NoView */]: load_no_view_command_default,
  [-1 /* UNRECOGNIZED */]: () => {
    throw new Error("Unsupported command type");
  }
};
var main = async () => {
  if (!import_node_worker_threads2.parentPort) {
    console.error(
      `Unable to get workerData. Is this code running inside a NodeJS worker? Manually invoking this runtime is not supported.`
    );
    return;
  }
  patchRequire();
  bus.onLaunch(async (data) => {
    loadEnviron(data);
    process.noDeprecation = process.env.NODE_ENV === "production";
    await loaders[data.mode](data);
    bus.emit("exit", {});
  });
};

// src/proto/application.ts
function createBaseOpenApplicationRequest2() {
  return { target: "", appId: void 0 };
}
var OpenApplicationRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.appId !== void 0) {
      writer.uint32(18).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOpenApplicationRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.target = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      target: isSet16(object.target) ? globalThis.String(object.target) : "",
      appId: isSet16(object.appId) ? globalThis.String(object.appId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.appId !== void 0) {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return OpenApplicationRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOpenApplicationRequest2();
    message.target = object.target ?? "";
    message.appId = object.appId ?? void 0;
    return message;
  }
};
function createBaseRunInTerminalRequest2() {
  return { cmdline: [], appId: void 0, workingDirectory: void 0, title: void 0, hold: false };
}
var RunInTerminalRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.cmdline) {
      writer.uint32(10).string(v);
    }
    if (message.appId !== void 0) {
      writer.uint32(18).string(message.appId);
    }
    if (message.workingDirectory !== void 0) {
      writer.uint32(26).string(message.workingDirectory);
    }
    if (message.title !== void 0) {
      writer.uint32(34).string(message.title);
    }
    if (message.hold !== false) {
      writer.uint32(40).bool(message.hold);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRunInTerminalRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cmdline.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.workingDirectory = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.hold = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cmdline: globalThis.Array.isArray(object?.cmdline) ? object.cmdline.map((e) => globalThis.String(e)) : [],
      appId: isSet16(object.appId) ? globalThis.String(object.appId) : void 0,
      workingDirectory: isSet16(object.workingDirectory) ? globalThis.String(object.workingDirectory) : void 0,
      title: isSet16(object.title) ? globalThis.String(object.title) : void 0,
      hold: isSet16(object.hold) ? globalThis.Boolean(object.hold) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cmdline?.length) {
      obj.cmdline = message.cmdline;
    }
    if (message.appId !== void 0) {
      obj.appId = message.appId;
    }
    if (message.workingDirectory !== void 0) {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.title !== void 0) {
      obj.title = message.title;
    }
    if (message.hold !== false) {
      obj.hold = message.hold;
    }
    return obj;
  },
  create(base) {
    return RunInTerminalRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRunInTerminalRequest2();
    message.cmdline = object.cmdline?.map((e) => e) || [];
    message.appId = object.appId ?? void 0;
    message.workingDirectory = object.workingDirectory ?? void 0;
    message.title = object.title ?? void 0;
    message.hold = object.hold ?? false;
    return message;
  }
};
function createBaseListApplicationRequest2() {
  return { target: void 0 };
}
var ListApplicationRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.target !== void 0) {
      writer.uint32(10).string(message.target);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListApplicationRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { target: isSet16(object.target) ? globalThis.String(object.target) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.target !== void 0) {
      obj.target = message.target;
    }
    return obj;
  },
  create(base) {
    return ListApplicationRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListApplicationRequest2();
    message.target = object.target ?? void 0;
    return message;
  }
};
function createBaseListApplicationResponse2() {
  return { apps: [] };
}
var ListApplicationResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.apps) {
      Application2.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListApplicationResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.apps.push(Application2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => Application2.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => Application2.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ListApplicationResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListApplicationResponse2();
    message.apps = object.apps?.map((e) => Application2.fromPartial(e)) || [];
    return message;
  }
};
function createBaseGetDefaultApplicationRequest2() {
  return { target: "" };
}
var GetDefaultApplicationRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDefaultApplicationRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { target: isSet16(object.target) ? globalThis.String(object.target) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },
  create(base) {
    return GetDefaultApplicationRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDefaultApplicationRequest2();
    message.target = object.target ?? "";
    return message;
  }
};
function createBaseGetDefaultApplicationResponse2() {
  return { app: void 0 };
}
var GetDefaultApplicationResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.app !== void 0) {
      Application2.encode(message.app, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetDefaultApplicationResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.app = Application2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { app: isSet16(object.app) ? Application2.fromJSON(object.app) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.app !== void 0) {
      obj.app = Application2.toJSON(message.app);
    }
    return obj;
  },
  create(base) {
    return GetDefaultApplicationResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetDefaultApplicationResponse2();
    message.app = object.app !== void 0 && object.app !== null ? Application2.fromPartial(object.app) : void 0;
    return message;
  }
};
function createBaseRequest10() {
  return { list: void 0, open: void 0, getDefault: void 0, runInTerminal: void 0 };
}
var Request10 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.list !== void 0) {
      ListApplicationRequest2.encode(message.list, writer.uint32(10).fork()).join();
    }
    if (message.open !== void 0) {
      OpenApplicationRequest2.encode(message.open, writer.uint32(18).fork()).join();
    }
    if (message.getDefault !== void 0) {
      GetDefaultApplicationRequest2.encode(message.getDefault, writer.uint32(26).fork()).join();
    }
    if (message.runInTerminal !== void 0) {
      RunInTerminalRequest2.encode(message.runInTerminal, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest10();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.list = ListApplicationRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.open = OpenApplicationRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.getDefault = GetDefaultApplicationRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.runInTerminal = RunInTerminalRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      list: isSet16(object.list) ? ListApplicationRequest2.fromJSON(object.list) : void 0,
      open: isSet16(object.open) ? OpenApplicationRequest2.fromJSON(object.open) : void 0,
      getDefault: isSet16(object.getDefault) ? GetDefaultApplicationRequest2.fromJSON(object.getDefault) : void 0,
      runInTerminal: isSet16(object.runInTerminal) ? RunInTerminalRequest2.fromJSON(object.runInTerminal) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.list !== void 0) {
      obj.list = ListApplicationRequest2.toJSON(message.list);
    }
    if (message.open !== void 0) {
      obj.open = OpenApplicationRequest2.toJSON(message.open);
    }
    if (message.getDefault !== void 0) {
      obj.getDefault = GetDefaultApplicationRequest2.toJSON(message.getDefault);
    }
    if (message.runInTerminal !== void 0) {
      obj.runInTerminal = RunInTerminalRequest2.toJSON(message.runInTerminal);
    }
    return obj;
  },
  create(base) {
    return Request10.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest10();
    message.list = object.list !== void 0 && object.list !== null ? ListApplicationRequest2.fromPartial(object.list) : void 0;
    message.open = object.open !== void 0 && object.open !== null ? OpenApplicationRequest2.fromPartial(object.open) : void 0;
    message.getDefault = object.getDefault !== void 0 && object.getDefault !== null ? GetDefaultApplicationRequest2.fromPartial(object.getDefault) : void 0;
    message.runInTerminal = object.runInTerminal !== void 0 && object.runInTerminal !== null ? RunInTerminalRequest2.fromPartial(object.runInTerminal) : void 0;
    return message;
  }
};
function createBaseResponse10() {
  return { list: void 0, open: void 0, getDefault: void 0, runInTerminal: void 0 };
}
var Response10 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.list !== void 0) {
      ListApplicationResponse2.encode(message.list, writer.uint32(10).fork()).join();
    }
    if (message.open !== void 0) {
      AckResponse2.encode(message.open, writer.uint32(18).fork()).join();
    }
    if (message.getDefault !== void 0) {
      GetDefaultApplicationResponse2.encode(message.getDefault, writer.uint32(26).fork()).join();
    }
    if (message.runInTerminal !== void 0) {
      AckResponse2.encode(message.runInTerminal, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse10();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.list = ListApplicationResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.open = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.getDefault = GetDefaultApplicationResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.runInTerminal = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      list: isSet16(object.list) ? ListApplicationResponse2.fromJSON(object.list) : void 0,
      open: isSet16(object.open) ? AckResponse2.fromJSON(object.open) : void 0,
      getDefault: isSet16(object.getDefault) ? GetDefaultApplicationResponse2.fromJSON(object.getDefault) : void 0,
      runInTerminal: isSet16(object.runInTerminal) ? AckResponse2.fromJSON(object.runInTerminal) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.list !== void 0) {
      obj.list = ListApplicationResponse2.toJSON(message.list);
    }
    if (message.open !== void 0) {
      obj.open = AckResponse2.toJSON(message.open);
    }
    if (message.getDefault !== void 0) {
      obj.getDefault = GetDefaultApplicationResponse2.toJSON(message.getDefault);
    }
    if (message.runInTerminal !== void 0) {
      obj.runInTerminal = AckResponse2.toJSON(message.runInTerminal);
    }
    return obj;
  },
  create(base) {
    return Response10.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse10();
    message.list = object.list !== void 0 && object.list !== null ? ListApplicationResponse2.fromPartial(object.list) : void 0;
    message.open = object.open !== void 0 && object.open !== null ? AckResponse2.fromPartial(object.open) : void 0;
    message.getDefault = object.getDefault !== void 0 && object.getDefault !== null ? GetDefaultApplicationResponse2.fromPartial(object.getDefault) : void 0;
    message.runInTerminal = object.runInTerminal !== void 0 && object.runInTerminal !== null ? AckResponse2.fromPartial(object.runInTerminal) : void 0;
    return message;
  }
};
function createBaseApplication2() {
  return { id: "", name: "", icon: "", path: "" };
}
var Application2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.icon !== "") {
      writer.uint32(26).string(message.icon);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseApplication2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.icon = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet16(object.id) ? globalThis.String(object.id) : "",
      name: isSet16(object.name) ? globalThis.String(object.name) : "",
      icon: isSet16(object.icon) ? globalThis.String(object.icon) : "",
      path: isSet16(object.path) ? globalThis.String(object.path) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return Application2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseApplication2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.icon = object.icon ?? "";
    message.path = object.path ?? "";
    return message;
  }
};
function isSet16(value) {
  return value !== null && value !== void 0;
}

// src/proto/clipboard.ts
function createBaseClipboardHtmlContent2() {
  return { html: "", text: "" };
}
var ClipboardHtmlContent2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.html !== "") {
      writer.uint32(10).string(message.html);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClipboardHtmlContent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.html = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      html: isSet17(object.html) ? globalThis.String(object.html) : "",
      text: isSet17(object.text) ? globalThis.String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.html !== "") {
      obj.html = message.html;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return ClipboardHtmlContent2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClipboardHtmlContent2();
    message.html = object.html ?? "";
    message.text = object.text ?? "";
    return message;
  }
};
function createBaseClipboardPathContent2() {
  return { path: "" };
}
var ClipboardPathContent2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClipboardPathContent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { path: isSet17(object.path) ? globalThis.String(object.path) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return ClipboardPathContent2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClipboardPathContent2();
    message.path = object.path ?? "";
    return message;
  }
};
function createBaseClipboardOptions2() {
  return { concealed: false };
}
var ClipboardOptions2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.concealed !== false) {
      writer.uint32(8).bool(message.concealed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClipboardOptions2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.concealed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { concealed: isSet17(object.concealed) ? globalThis.Boolean(object.concealed) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.concealed !== false) {
      obj.concealed = message.concealed;
    }
    return obj;
  },
  create(base) {
    return ClipboardOptions2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClipboardOptions2();
    message.concealed = object.concealed ?? false;
    return message;
  }
};
function createBaseClearRequest3() {
  return {};
}
var ClearRequest3 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearRequest3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ClearRequest3.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseClearRequest3();
    return message;
  }
};
function createBaseClearResponse3() {
  return {};
}
var ClearResponse3 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearResponse3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ClearResponse3.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseClearResponse3();
    return message;
  }
};
function createBaseReadContentRequest2() {
  return {};
}
var ReadContentRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReadContentRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ReadContentRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseReadContentRequest2();
    return message;
  }
};
function createBaseReadContentResponse2() {
  return { content: void 0 };
}
var ReadContentResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.content !== void 0) {
      ClipboardReadContent2.encode(message.content, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReadContentResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.content = ClipboardReadContent2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { content: isSet17(object.content) ? ClipboardReadContent2.fromJSON(object.content) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.content !== void 0) {
      obj.content = ClipboardReadContent2.toJSON(message.content);
    }
    return obj;
  },
  create(base) {
    return ReadContentResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseReadContentResponse2();
    message.content = object.content !== void 0 && object.content !== null ? ClipboardReadContent2.fromPartial(object.content) : void 0;
    return message;
  }
};
function createBaseCopyToClipboardRequest2() {
  return { content: void 0, options: void 0 };
}
var CopyToClipboardRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.content !== void 0) {
      ClipboardContent2.encode(message.content, writer.uint32(10).fork()).join();
    }
    if (message.options !== void 0) {
      ClipboardOptions2.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCopyToClipboardRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.content = ClipboardContent2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.options = ClipboardOptions2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      content: isSet17(object.content) ? ClipboardContent2.fromJSON(object.content) : void 0,
      options: isSet17(object.options) ? ClipboardOptions2.fromJSON(object.options) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.content !== void 0) {
      obj.content = ClipboardContent2.toJSON(message.content);
    }
    if (message.options !== void 0) {
      obj.options = ClipboardOptions2.toJSON(message.options);
    }
    return obj;
  },
  create(base) {
    return CopyToClipboardRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCopyToClipboardRequest2();
    message.content = object.content !== void 0 && object.content !== null ? ClipboardContent2.fromPartial(object.content) : void 0;
    message.options = object.options !== void 0 && object.options !== null ? ClipboardOptions2.fromPartial(object.options) : void 0;
    return message;
  }
};
function createBasePasteToClipboardRequest2() {
  return { content: void 0 };
}
var PasteToClipboardRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.content !== void 0) {
      ClipboardContent2.encode(message.content, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePasteToClipboardRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.content = ClipboardContent2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { content: isSet17(object.content) ? ClipboardContent2.fromJSON(object.content) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.content !== void 0) {
      obj.content = ClipboardContent2.toJSON(message.content);
    }
    return obj;
  },
  create(base) {
    return PasteToClipboardRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePasteToClipboardRequest2();
    message.content = object.content !== void 0 && object.content !== null ? ClipboardContent2.fromPartial(object.content) : void 0;
    return message;
  }
};
function createBaseClipboardContent2() {
  return { text: void 0, html: void 0, path: void 0 };
}
var ClipboardContent2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== void 0) {
      writer.uint32(10).string(message.text);
    }
    if (message.html !== void 0) {
      ClipboardHtmlContent2.encode(message.html, writer.uint32(18).fork()).join();
    }
    if (message.path !== void 0) {
      ClipboardPathContent2.encode(message.path, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClipboardContent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.html = ClipboardHtmlContent2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.path = ClipboardPathContent2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet17(object.text) ? globalThis.String(object.text) : void 0,
      html: isSet17(object.html) ? ClipboardHtmlContent2.fromJSON(object.html) : void 0,
      path: isSet17(object.path) ? ClipboardPathContent2.fromJSON(object.path) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== void 0) {
      obj.text = message.text;
    }
    if (message.html !== void 0) {
      obj.html = ClipboardHtmlContent2.toJSON(message.html);
    }
    if (message.path !== void 0) {
      obj.path = ClipboardPathContent2.toJSON(message.path);
    }
    return obj;
  },
  create(base) {
    return ClipboardContent2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClipboardContent2();
    message.text = object.text ?? void 0;
    message.html = object.html !== void 0 && object.html !== null ? ClipboardHtmlContent2.fromPartial(object.html) : void 0;
    message.path = object.path !== void 0 && object.path !== null ? ClipboardPathContent2.fromPartial(object.path) : void 0;
    return message;
  }
};
function createBaseClipboardReadContent2() {
  return { text: "", file: void 0, html: void 0 };
}
var ClipboardReadContent2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.file !== void 0) {
      writer.uint32(18).string(message.file);
    }
    if (message.html !== void 0) {
      writer.uint32(26).string(message.html);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClipboardReadContent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.file = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.html = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet17(object.text) ? globalThis.String(object.text) : "",
      file: isSet17(object.file) ? globalThis.String(object.file) : void 0,
      html: isSet17(object.html) ? globalThis.String(object.html) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.file !== void 0) {
      obj.file = message.file;
    }
    if (message.html !== void 0) {
      obj.html = message.html;
    }
    return obj;
  },
  create(base) {
    return ClipboardReadContent2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClipboardReadContent2();
    message.text = object.text ?? "";
    message.file = object.file ?? void 0;
    message.html = object.html ?? void 0;
    return message;
  }
};
function createBaseCopyToClipboardResponse2() {
  return {};
}
var CopyToClipboardResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCopyToClipboardResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return CopyToClipboardResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseCopyToClipboardResponse2();
    return message;
  }
};
function createBasePasteToClipboardResponse2() {
  return {};
}
var PasteToClipboardResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePasteToClipboardResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return PasteToClipboardResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBasePasteToClipboardResponse2();
    return message;
  }
};
function createBaseRequest11() {
  return { copy: void 0, paste: void 0, readContent: void 0, clear: void 0 };
}
var Request11 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.copy !== void 0) {
      CopyToClipboardRequest2.encode(message.copy, writer.uint32(10).fork()).join();
    }
    if (message.paste !== void 0) {
      PasteToClipboardRequest2.encode(message.paste, writer.uint32(18).fork()).join();
    }
    if (message.readContent !== void 0) {
      ReadContentRequest2.encode(message.readContent, writer.uint32(26).fork()).join();
    }
    if (message.clear !== void 0) {
      ClearRequest3.encode(message.clear, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest11();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.copy = CopyToClipboardRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.paste = PasteToClipboardRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.readContent = ReadContentRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.clear = ClearRequest3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      copy: isSet17(object.copy) ? CopyToClipboardRequest2.fromJSON(object.copy) : void 0,
      paste: isSet17(object.paste) ? PasteToClipboardRequest2.fromJSON(object.paste) : void 0,
      readContent: isSet17(object.readContent) ? ReadContentRequest2.fromJSON(object.readContent) : void 0,
      clear: isSet17(object.clear) ? ClearRequest3.fromJSON(object.clear) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.copy !== void 0) {
      obj.copy = CopyToClipboardRequest2.toJSON(message.copy);
    }
    if (message.paste !== void 0) {
      obj.paste = PasteToClipboardRequest2.toJSON(message.paste);
    }
    if (message.readContent !== void 0) {
      obj.readContent = ReadContentRequest2.toJSON(message.readContent);
    }
    if (message.clear !== void 0) {
      obj.clear = ClearRequest3.toJSON(message.clear);
    }
    return obj;
  },
  create(base) {
    return Request11.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest11();
    message.copy = object.copy !== void 0 && object.copy !== null ? CopyToClipboardRequest2.fromPartial(object.copy) : void 0;
    message.paste = object.paste !== void 0 && object.paste !== null ? PasteToClipboardRequest2.fromPartial(object.paste) : void 0;
    message.readContent = object.readContent !== void 0 && object.readContent !== null ? ReadContentRequest2.fromPartial(object.readContent) : void 0;
    message.clear = object.clear !== void 0 && object.clear !== null ? ClearRequest3.fromPartial(object.clear) : void 0;
    return message;
  }
};
function createBaseResponse11() {
  return { copy: void 0, paste: void 0, readContent: void 0, clear: void 0 };
}
var Response11 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.copy !== void 0) {
      CopyToClipboardResponse2.encode(message.copy, writer.uint32(10).fork()).join();
    }
    if (message.paste !== void 0) {
      PasteToClipboardResponse2.encode(message.paste, writer.uint32(18).fork()).join();
    }
    if (message.readContent !== void 0) {
      ReadContentResponse2.encode(message.readContent, writer.uint32(26).fork()).join();
    }
    if (message.clear !== void 0) {
      ClearResponse3.encode(message.clear, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse11();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.copy = CopyToClipboardResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.paste = PasteToClipboardResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.readContent = ReadContentResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.clear = ClearResponse3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      copy: isSet17(object.copy) ? CopyToClipboardResponse2.fromJSON(object.copy) : void 0,
      paste: isSet17(object.paste) ? PasteToClipboardResponse2.fromJSON(object.paste) : void 0,
      readContent: isSet17(object.readContent) ? ReadContentResponse2.fromJSON(object.readContent) : void 0,
      clear: isSet17(object.clear) ? ClearResponse3.fromJSON(object.clear) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.copy !== void 0) {
      obj.copy = CopyToClipboardResponse2.toJSON(message.copy);
    }
    if (message.paste !== void 0) {
      obj.paste = PasteToClipboardResponse2.toJSON(message.paste);
    }
    if (message.readContent !== void 0) {
      obj.readContent = ReadContentResponse2.toJSON(message.readContent);
    }
    if (message.clear !== void 0) {
      obj.clear = ClearResponse3.toJSON(message.clear);
    }
    return obj;
  },
  create(base) {
    return Response11.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse11();
    message.copy = object.copy !== void 0 && object.copy !== null ? CopyToClipboardResponse2.fromPartial(object.copy) : void 0;
    message.paste = object.paste !== void 0 && object.paste !== null ? PasteToClipboardResponse2.fromPartial(object.paste) : void 0;
    message.readContent = object.readContent !== void 0 && object.readContent !== null ? ReadContentResponse2.fromPartial(object.readContent) : void 0;
    message.clear = object.clear !== void 0 && object.clear !== null ? ClearResponse3.fromPartial(object.clear) : void 0;
    return message;
  }
};
function isSet17(value) {
  return value !== null && value !== void 0;
}

// src/proto/command.ts
function createBaseUpdateCommandMetadataRequest2() {
  return { subtitle: void 0 };
}
var UpdateCommandMetadataRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.subtitle !== void 0) {
      writer.uint32(10).string(message.subtitle);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommandMetadataRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.subtitle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { subtitle: isSet18(object.subtitle) ? globalThis.String(object.subtitle) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.subtitle !== void 0) {
      obj.subtitle = message.subtitle;
    }
    return obj;
  },
  create(base) {
    return UpdateCommandMetadataRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateCommandMetadataRequest2();
    message.subtitle = object.subtitle ?? void 0;
    return message;
  }
};
function createBaseRequest12() {
  return { updateCommandMetadata: void 0 };
}
var Request12 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.updateCommandMetadata !== void 0) {
      UpdateCommandMetadataRequest2.encode(message.updateCommandMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest12();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.updateCommandMetadata = UpdateCommandMetadataRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      updateCommandMetadata: isSet18(object.updateCommandMetadata) ? UpdateCommandMetadataRequest2.fromJSON(object.updateCommandMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.updateCommandMetadata !== void 0) {
      obj.updateCommandMetadata = UpdateCommandMetadataRequest2.toJSON(message.updateCommandMetadata);
    }
    return obj;
  },
  create(base) {
    return Request12.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest12();
    message.updateCommandMetadata = object.updateCommandMetadata !== void 0 && object.updateCommandMetadata !== null ? UpdateCommandMetadataRequest2.fromPartial(object.updateCommandMetadata) : void 0;
    return message;
  }
};
function createBaseResponse12() {
  return { updateCommandMetadata: void 0 };
}
var Response12 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.updateCommandMetadata !== void 0) {
      AckResponse2.encode(message.updateCommandMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse12();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.updateCommandMetadata = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      updateCommandMetadata: isSet18(object.updateCommandMetadata) ? AckResponse2.fromJSON(object.updateCommandMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.updateCommandMetadata !== void 0) {
      obj.updateCommandMetadata = AckResponse2.toJSON(message.updateCommandMetadata);
    }
    return obj;
  },
  create(base) {
    return Response12.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse12();
    message.updateCommandMetadata = object.updateCommandMetadata !== void 0 && object.updateCommandMetadata !== null ? AckResponse2.fromPartial(object.updateCommandMetadata) : void 0;
    return message;
  }
};
function isSet18(value) {
  return value !== null && value !== void 0;
}

// src/proto/file-search.ts
function createBaseSearchRequest2() {
  return { query: "" };
}
var SearchRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { query: isSet19(object.query) ? globalThis.String(object.query) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },
  create(base) {
    return SearchRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSearchRequest2();
    message.query = object.query ?? "";
    return message;
  }
};
function createBaseFileInfo2() {
  return { path: "", mimeType: "" };
}
var FileInfo2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileInfo2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet19(object.path) ? globalThis.String(object.path) : "",
      mimeType: isSet19(object.mimeType) ? globalThis.String(object.mimeType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },
  create(base) {
    return FileInfo2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileInfo2();
    message.path = object.path ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  }
};
function createBaseSearchResponse2() {
  return { files: [] };
}
var SearchResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.files) {
      FileInfo2.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.files.push(FileInfo2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => FileInfo2.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileInfo2.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SearchResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSearchResponse2();
    message.files = object.files?.map((e) => FileInfo2.fromPartial(e)) || [];
    return message;
  }
};
function createBaseRequest13() {
  return { search: void 0 };
}
var Request13 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.search !== void 0) {
      SearchRequest2.encode(message.search, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest13();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.search = SearchRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { search: isSet19(object.search) ? SearchRequest2.fromJSON(object.search) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.search !== void 0) {
      obj.search = SearchRequest2.toJSON(message.search);
    }
    return obj;
  },
  create(base) {
    return Request13.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest13();
    message.search = object.search !== void 0 && object.search !== null ? SearchRequest2.fromPartial(object.search) : void 0;
    return message;
  }
};
function createBaseResponse13() {
  return { search: void 0 };
}
var Response13 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.search !== void 0) {
      SearchResponse2.encode(message.search, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse13();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.search = SearchResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { search: isSet19(object.search) ? SearchResponse2.fromJSON(object.search) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.search !== void 0) {
      obj.search = SearchResponse2.toJSON(message.search);
    }
    return obj;
  },
  create(base) {
    return Response13.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse13();
    message.search = object.search !== void 0 && object.search !== null ? SearchResponse2.fromPartial(object.search) : void 0;
    return message;
  }
};
function isSet19(value) {
  return value !== null && value !== void 0;
}

// src/proto/ui.ts
function toastStyleFromJSON2(object) {
  switch (object) {
    case 0:
    case "Success":
      return 0 /* Success */;
    case 1:
    case "Info":
      return 1 /* Info */;
    case 2:
    case "Warning":
      return 2 /* Warning */;
    case 3:
    case "Error":
      return 3 /* Error */;
    case 4:
    case "Dynamic":
      return 4 /* Dynamic */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function toastStyleToJSON2(object) {
  switch (object) {
    case 0 /* Success */:
      return "Success";
    case 1 /* Info */:
      return "Info";
    case 2 /* Warning */:
      return "Warning";
    case 3 /* Error */:
      return "Error";
    case 4 /* Dynamic */:
      return "Dynamic";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function popToRootTypeFromJSON2(object) {
  switch (object) {
    case 0:
    case "PopToRootDefault":
      return 0 /* PopToRootDefault */;
    case 1:
    case "PopToRootImmediate":
      return 1 /* PopToRootImmediate */;
    case 2:
    case "PopToRootSuspended":
      return 2 /* PopToRootSuspended */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function popToRootTypeToJSON2(object) {
  switch (object) {
    case 0 /* PopToRootDefault */:
      return "PopToRootDefault";
    case 1 /* PopToRootImmediate */:
      return "PopToRootImmediate";
    case 2 /* PopToRootSuspended */:
      return "PopToRootSuspended";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function confirmAlertActionStyleFromJSON2(object) {
  switch (object) {
    case 0:
    case "Default":
      return 0 /* Default */;
    case 1:
    case "Destructive":
      return 1 /* Destructive */;
    case 2:
    case "Cancel":
      return 2 /* Cancel */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function confirmAlertActionStyleToJSON2(object) {
  switch (object) {
    case 0 /* Default */:
      return "Default";
    case 1 /* Destructive */:
      return "Destructive";
    case 2 /* Cancel */:
      return "Cancel";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function imageMaskFromJSON2(object) {
  switch (object) {
    case 0:
    case "None":
      return 0 /* None */;
    case 1:
    case "Circle":
      return 1 /* Circle */;
    case 2:
    case "RoundedRectangle":
      return 2 /* RoundedRectangle */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function imageMaskToJSON2(object) {
  switch (object) {
    case 0 /* None */:
      return "None";
    case 1 /* Circle */:
      return "Circle";
    case 2 /* RoundedRectangle */:
      return "RoundedRectangle";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseShowToastRequest2() {
  return { id: "", title: "", style: 0 };
}
var ShowToastRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.style !== 0) {
      writer.uint32(24).int32(message.style);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowToastRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.style = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet20(object.id) ? globalThis.String(object.id) : "",
      title: isSet20(object.title) ? globalThis.String(object.title) : "",
      style: isSet20(object.style) ? toastStyleFromJSON2(object.style) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.style !== 0) {
      obj.style = toastStyleToJSON2(message.style);
    }
    return obj;
  },
  create(base) {
    return ShowToastRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseShowToastRequest2();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.style = object.style ?? 0;
    return message;
  }
};
function createBaseHideToastRequest2() {
  return { id: "" };
}
var HideToastRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHideToastRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet20(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return HideToastRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseHideToastRequest2();
    message.id = object.id ?? "";
    return message;
  }
};
function createBaseUpdateToastRequest2() {
  return { id: "", title: "" };
}
var UpdateToastRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateToastRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet20(object.id) ? globalThis.String(object.id) : "",
      title: isSet20(object.title) ? globalThis.String(object.title) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },
  create(base) {
    return UpdateToastRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateToastRequest2();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    return message;
  }
};
function createBasePushViewRequest2() {
  return {};
}
var PushViewRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePushViewRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return PushViewRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBasePushViewRequest2();
    return message;
  }
};
function createBasePopViewRequest2() {
  return {};
}
var PopViewRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePopViewRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return PopViewRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBasePopViewRequest2();
    return message;
  }
};
function createBaseCloseMainWindowRequest2() {
  return { clearRootSearch: false, popToRoot: 0 };
}
var CloseMainWindowRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.clearRootSearch !== false) {
      writer.uint32(8).bool(message.clearRootSearch);
    }
    if (message.popToRoot !== 0) {
      writer.uint32(16).int32(message.popToRoot);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCloseMainWindowRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.clearRootSearch = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.popToRoot = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      clearRootSearch: isSet20(object.clearRootSearch) ? globalThis.Boolean(object.clearRootSearch) : false,
      popToRoot: isSet20(object.popToRoot) ? popToRootTypeFromJSON2(object.popToRoot) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clearRootSearch !== false) {
      obj.clearRootSearch = message.clearRootSearch;
    }
    if (message.popToRoot !== 0) {
      obj.popToRoot = popToRootTypeToJSON2(message.popToRoot);
    }
    return obj;
  },
  create(base) {
    return CloseMainWindowRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCloseMainWindowRequest2();
    message.clearRootSearch = object.clearRootSearch ?? false;
    message.popToRoot = object.popToRoot ?? 0;
    return message;
  }
};
function createBaseClearSearchBarRequest2() {
  return {};
}
var ClearSearchBarRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearSearchBarRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ClearSearchBarRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseClearSearchBarRequest2();
    return message;
  }
};
function createBaseSetSearchTextRequest2() {
  return { text: "" };
}
var SetSearchTextRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetSearchTextRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { text: isSet20(object.text) ? globalThis.String(object.text) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return SetSearchTextRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetSearchTextRequest2();
    message.text = object.text ?? "";
    return message;
  }
};
function createBaseGetSelectedTextRequest2() {
  return {};
}
var GetSelectedTextRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetSelectedTextRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetSelectedTextRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetSelectedTextRequest2();
    return message;
  }
};
function createBaseGetSelectedTextResponse2() {
  return { text: "" };
}
var GetSelectedTextResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetSelectedTextResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { text: isSet20(object.text) ? globalThis.String(object.text) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return GetSelectedTextResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetSelectedTextResponse2();
    message.text = object.text ?? "";
    return message;
  }
};
function createBaseShowHudRequest2() {
  return { text: "", clearRootSearch: false, popToRoot: 0 };
}
var ShowHudRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.clearRootSearch !== false) {
      writer.uint32(16).bool(message.clearRootSearch);
    }
    if (message.popToRoot !== 0) {
      writer.uint32(24).int32(message.popToRoot);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShowHudRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.clearRootSearch = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.popToRoot = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      text: isSet20(object.text) ? globalThis.String(object.text) : "",
      clearRootSearch: isSet20(object.clearRootSearch) ? globalThis.Boolean(object.clearRootSearch) : false,
      popToRoot: isSet20(object.popToRoot) ? popToRootTypeFromJSON2(object.popToRoot) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.clearRootSearch !== false) {
      obj.clearRootSearch = message.clearRootSearch;
    }
    if (message.popToRoot !== 0) {
      obj.popToRoot = popToRootTypeToJSON2(message.popToRoot);
    }
    return obj;
  },
  create(base) {
    return ShowHudRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseShowHudRequest2();
    message.text = object.text ?? "";
    message.clearRootSearch = object.clearRootSearch ?? false;
    message.popToRoot = object.popToRoot ?? 0;
    return message;
  }
};
function createBaseRenderRequest2() {
  return { json: "" };
}
var RenderRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.json !== "") {
      writer.uint32(10).string(message.json);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRenderRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.json = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet20(object.json) ? globalThis.String(object.json) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== "") {
      obj.json = message.json;
    }
    return obj;
  },
  create(base) {
    return RenderRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRenderRequest2();
    message.json = object.json ?? "";
    return message;
  }
};
function createBaseConfirmAlertRequest2() {
  return {
    title: "",
    description: "",
    icon: void 0,
    dismissAction: void 0,
    primaryAction: void 0,
    rememberUserChoice: false
  };
}
var ConfirmAlertRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.icon !== void 0) {
      Image5.encode(message.icon, writer.uint32(26).fork()).join();
    }
    if (message.dismissAction !== void 0) {
      ConfirmAlertAction2.encode(message.dismissAction, writer.uint32(34).fork()).join();
    }
    if (message.primaryAction !== void 0) {
      ConfirmAlertAction2.encode(message.primaryAction, writer.uint32(42).fork()).join();
    }
    if (message.rememberUserChoice !== false) {
      writer.uint32(48).bool(message.rememberUserChoice);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfirmAlertRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.icon = Image5.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.dismissAction = ConfirmAlertAction2.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.primaryAction = ConfirmAlertAction2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.rememberUserChoice = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet20(object.title) ? globalThis.String(object.title) : "",
      description: isSet20(object.description) ? globalThis.String(object.description) : "",
      icon: isSet20(object.icon) ? Image5.fromJSON(object.icon) : void 0,
      dismissAction: isSet20(object.dismissAction) ? ConfirmAlertAction2.fromJSON(object.dismissAction) : void 0,
      primaryAction: isSet20(object.primaryAction) ? ConfirmAlertAction2.fromJSON(object.primaryAction) : void 0,
      rememberUserChoice: isSet20(object.rememberUserChoice) ? globalThis.Boolean(object.rememberUserChoice) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.icon !== void 0) {
      obj.icon = Image5.toJSON(message.icon);
    }
    if (message.dismissAction !== void 0) {
      obj.dismissAction = ConfirmAlertAction2.toJSON(message.dismissAction);
    }
    if (message.primaryAction !== void 0) {
      obj.primaryAction = ConfirmAlertAction2.toJSON(message.primaryAction);
    }
    if (message.rememberUserChoice !== false) {
      obj.rememberUserChoice = message.rememberUserChoice;
    }
    return obj;
  },
  create(base) {
    return ConfirmAlertRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfirmAlertRequest2();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.icon = object.icon !== void 0 && object.icon !== null ? Image5.fromPartial(object.icon) : void 0;
    message.dismissAction = object.dismissAction !== void 0 && object.dismissAction !== null ? ConfirmAlertAction2.fromPartial(object.dismissAction) : void 0;
    message.primaryAction = object.primaryAction !== void 0 && object.primaryAction !== null ? ConfirmAlertAction2.fromPartial(object.primaryAction) : void 0;
    message.rememberUserChoice = object.rememberUserChoice ?? false;
    return message;
  }
};
function createBaseConfirmAlertResponse2() {
  return { confirmed: false };
}
var ConfirmAlertResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.confirmed !== false) {
      writer.uint32(8).bool(message.confirmed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfirmAlertResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.confirmed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { confirmed: isSet20(object.confirmed) ? globalThis.Boolean(object.confirmed) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.confirmed !== false) {
      obj.confirmed = message.confirmed;
    }
    return obj;
  },
  create(base) {
    return ConfirmAlertResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfirmAlertResponse2();
    message.confirmed = object.confirmed ?? false;
    return message;
  }
};
function createBaseConfirmAlertAction2() {
  return { title: "", style: 0 };
}
var ConfirmAlertAction2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.style !== 0) {
      writer.uint32(16).int32(message.style);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfirmAlertAction2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.style = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      title: isSet20(object.title) ? globalThis.String(object.title) : "",
      style: isSet20(object.style) ? confirmAlertActionStyleFromJSON2(object.style) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.style !== 0) {
      obj.style = confirmAlertActionStyleToJSON2(message.style);
    }
    return obj;
  },
  create(base) {
    return ConfirmAlertAction2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseConfirmAlertAction2();
    message.title = object.title ?? "";
    message.style = object.style ?? 0;
    return message;
  }
};
function createBasePopToRootRequest2() {
  return { clearSearchBar: false };
}
var PopToRootRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.clearSearchBar !== false) {
      writer.uint32(8).bool(message.clearSearchBar);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePopToRootRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.clearSearchBar = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { clearSearchBar: isSet20(object.clearSearchBar) ? globalThis.Boolean(object.clearSearchBar) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.clearSearchBar !== false) {
      obj.clearSearchBar = message.clearSearchBar;
    }
    return obj;
  },
  create(base) {
    return PopToRootRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePopToRootRequest2();
    message.clearSearchBar = object.clearSearchBar ?? false;
    return message;
  }
};
function createBaseRequest14() {
  return {
    render: void 0,
    showToast: void 0,
    hideToast: void 0,
    updateToast: void 0,
    pushView: void 0,
    popView: void 0,
    clearSearch: void 0,
    closeMainWindow: void 0,
    showHud: void 0,
    setSearchText: void 0,
    confirmAlert: void 0,
    getSelectedText: void 0,
    popToRoot: void 0
  };
}
var Request14 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.render !== void 0) {
      RenderRequest2.encode(message.render, writer.uint32(10).fork()).join();
    }
    if (message.showToast !== void 0) {
      ShowToastRequest2.encode(message.showToast, writer.uint32(18).fork()).join();
    }
    if (message.hideToast !== void 0) {
      HideToastRequest2.encode(message.hideToast, writer.uint32(26).fork()).join();
    }
    if (message.updateToast !== void 0) {
      UpdateToastRequest2.encode(message.updateToast, writer.uint32(34).fork()).join();
    }
    if (message.pushView !== void 0) {
      PushViewRequest2.encode(message.pushView, writer.uint32(42).fork()).join();
    }
    if (message.popView !== void 0) {
      PopViewRequest2.encode(message.popView, writer.uint32(50).fork()).join();
    }
    if (message.clearSearch !== void 0) {
      ClearSearchBarRequest2.encode(message.clearSearch, writer.uint32(58).fork()).join();
    }
    if (message.closeMainWindow !== void 0) {
      CloseMainWindowRequest2.encode(message.closeMainWindow, writer.uint32(66).fork()).join();
    }
    if (message.showHud !== void 0) {
      ShowHudRequest2.encode(message.showHud, writer.uint32(74).fork()).join();
    }
    if (message.setSearchText !== void 0) {
      SetSearchTextRequest2.encode(message.setSearchText, writer.uint32(82).fork()).join();
    }
    if (message.confirmAlert !== void 0) {
      ConfirmAlertRequest2.encode(message.confirmAlert, writer.uint32(90).fork()).join();
    }
    if (message.getSelectedText !== void 0) {
      GetSelectedTextRequest2.encode(message.getSelectedText, writer.uint32(98).fork()).join();
    }
    if (message.popToRoot !== void 0) {
      PopToRootRequest2.encode(message.popToRoot, writer.uint32(106).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest14();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.render = RenderRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.showToast = ShowToastRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.hideToast = HideToastRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.updateToast = UpdateToastRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.pushView = PushViewRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.popView = PopViewRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.clearSearch = ClearSearchBarRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.closeMainWindow = CloseMainWindowRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.showHud = ShowHudRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.setSearchText = SetSearchTextRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.confirmAlert = ConfirmAlertRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.getSelectedText = GetSelectedTextRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.popToRoot = PopToRootRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      render: isSet20(object.render) ? RenderRequest2.fromJSON(object.render) : void 0,
      showToast: isSet20(object.showToast) ? ShowToastRequest2.fromJSON(object.showToast) : void 0,
      hideToast: isSet20(object.hideToast) ? HideToastRequest2.fromJSON(object.hideToast) : void 0,
      updateToast: isSet20(object.updateToast) ? UpdateToastRequest2.fromJSON(object.updateToast) : void 0,
      pushView: isSet20(object.pushView) ? PushViewRequest2.fromJSON(object.pushView) : void 0,
      popView: isSet20(object.popView) ? PopViewRequest2.fromJSON(object.popView) : void 0,
      clearSearch: isSet20(object.clearSearch) ? ClearSearchBarRequest2.fromJSON(object.clearSearch) : void 0,
      closeMainWindow: isSet20(object.closeMainWindow) ? CloseMainWindowRequest2.fromJSON(object.closeMainWindow) : void 0,
      showHud: isSet20(object.showHud) ? ShowHudRequest2.fromJSON(object.showHud) : void 0,
      setSearchText: isSet20(object.setSearchText) ? SetSearchTextRequest2.fromJSON(object.setSearchText) : void 0,
      confirmAlert: isSet20(object.confirmAlert) ? ConfirmAlertRequest2.fromJSON(object.confirmAlert) : void 0,
      getSelectedText: isSet20(object.getSelectedText) ? GetSelectedTextRequest2.fromJSON(object.getSelectedText) : void 0,
      popToRoot: isSet20(object.popToRoot) ? PopToRootRequest2.fromJSON(object.popToRoot) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.render !== void 0) {
      obj.render = RenderRequest2.toJSON(message.render);
    }
    if (message.showToast !== void 0) {
      obj.showToast = ShowToastRequest2.toJSON(message.showToast);
    }
    if (message.hideToast !== void 0) {
      obj.hideToast = HideToastRequest2.toJSON(message.hideToast);
    }
    if (message.updateToast !== void 0) {
      obj.updateToast = UpdateToastRequest2.toJSON(message.updateToast);
    }
    if (message.pushView !== void 0) {
      obj.pushView = PushViewRequest2.toJSON(message.pushView);
    }
    if (message.popView !== void 0) {
      obj.popView = PopViewRequest2.toJSON(message.popView);
    }
    if (message.clearSearch !== void 0) {
      obj.clearSearch = ClearSearchBarRequest2.toJSON(message.clearSearch);
    }
    if (message.closeMainWindow !== void 0) {
      obj.closeMainWindow = CloseMainWindowRequest2.toJSON(message.closeMainWindow);
    }
    if (message.showHud !== void 0) {
      obj.showHud = ShowHudRequest2.toJSON(message.showHud);
    }
    if (message.setSearchText !== void 0) {
      obj.setSearchText = SetSearchTextRequest2.toJSON(message.setSearchText);
    }
    if (message.confirmAlert !== void 0) {
      obj.confirmAlert = ConfirmAlertRequest2.toJSON(message.confirmAlert);
    }
    if (message.getSelectedText !== void 0) {
      obj.getSelectedText = GetSelectedTextRequest2.toJSON(message.getSelectedText);
    }
    if (message.popToRoot !== void 0) {
      obj.popToRoot = PopToRootRequest2.toJSON(message.popToRoot);
    }
    return obj;
  },
  create(base) {
    return Request14.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest14();
    message.render = object.render !== void 0 && object.render !== null ? RenderRequest2.fromPartial(object.render) : void 0;
    message.showToast = object.showToast !== void 0 && object.showToast !== null ? ShowToastRequest2.fromPartial(object.showToast) : void 0;
    message.hideToast = object.hideToast !== void 0 && object.hideToast !== null ? HideToastRequest2.fromPartial(object.hideToast) : void 0;
    message.updateToast = object.updateToast !== void 0 && object.updateToast !== null ? UpdateToastRequest2.fromPartial(object.updateToast) : void 0;
    message.pushView = object.pushView !== void 0 && object.pushView !== null ? PushViewRequest2.fromPartial(object.pushView) : void 0;
    message.popView = object.popView !== void 0 && object.popView !== null ? PopViewRequest2.fromPartial(object.popView) : void 0;
    message.clearSearch = object.clearSearch !== void 0 && object.clearSearch !== null ? ClearSearchBarRequest2.fromPartial(object.clearSearch) : void 0;
    message.closeMainWindow = object.closeMainWindow !== void 0 && object.closeMainWindow !== null ? CloseMainWindowRequest2.fromPartial(object.closeMainWindow) : void 0;
    message.showHud = object.showHud !== void 0 && object.showHud !== null ? ShowHudRequest2.fromPartial(object.showHud) : void 0;
    message.setSearchText = object.setSearchText !== void 0 && object.setSearchText !== null ? SetSearchTextRequest2.fromPartial(object.setSearchText) : void 0;
    message.confirmAlert = object.confirmAlert !== void 0 && object.confirmAlert !== null ? ConfirmAlertRequest2.fromPartial(object.confirmAlert) : void 0;
    message.getSelectedText = object.getSelectedText !== void 0 && object.getSelectedText !== null ? GetSelectedTextRequest2.fromPartial(object.getSelectedText) : void 0;
    message.popToRoot = object.popToRoot !== void 0 && object.popToRoot !== null ? PopToRootRequest2.fromPartial(object.popToRoot) : void 0;
    return message;
  }
};
function createBaseResponse14() {
  return {
    render: void 0,
    showToast: void 0,
    hideToast: void 0,
    updateToast: void 0,
    pushView: void 0,
    popView: void 0,
    clearSearch: void 0,
    closeMainWindow: void 0,
    showHud: void 0,
    setSearchText: void 0,
    confirmAlert: void 0,
    getSelectedText: void 0,
    popToRoot: void 0
  };
}
var Response14 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.render !== void 0) {
      AckResponse2.encode(message.render, writer.uint32(10).fork()).join();
    }
    if (message.showToast !== void 0) {
      AckResponse2.encode(message.showToast, writer.uint32(18).fork()).join();
    }
    if (message.hideToast !== void 0) {
      AckResponse2.encode(message.hideToast, writer.uint32(26).fork()).join();
    }
    if (message.updateToast !== void 0) {
      AckResponse2.encode(message.updateToast, writer.uint32(34).fork()).join();
    }
    if (message.pushView !== void 0) {
      AckResponse2.encode(message.pushView, writer.uint32(42).fork()).join();
    }
    if (message.popView !== void 0) {
      AckResponse2.encode(message.popView, writer.uint32(50).fork()).join();
    }
    if (message.clearSearch !== void 0) {
      AckResponse2.encode(message.clearSearch, writer.uint32(58).fork()).join();
    }
    if (message.closeMainWindow !== void 0) {
      AckResponse2.encode(message.closeMainWindow, writer.uint32(66).fork()).join();
    }
    if (message.showHud !== void 0) {
      AckResponse2.encode(message.showHud, writer.uint32(74).fork()).join();
    }
    if (message.setSearchText !== void 0) {
      AckResponse2.encode(message.setSearchText, writer.uint32(82).fork()).join();
    }
    if (message.confirmAlert !== void 0) {
      ConfirmAlertResponse2.encode(message.confirmAlert, writer.uint32(90).fork()).join();
    }
    if (message.getSelectedText !== void 0) {
      GetSelectedTextResponse2.encode(message.getSelectedText, writer.uint32(98).fork()).join();
    }
    if (message.popToRoot !== void 0) {
      AckResponse2.encode(message.popToRoot, writer.uint32(106).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse14();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.render = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.showToast = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.hideToast = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.updateToast = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.pushView = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.popView = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.clearSearch = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.closeMainWindow = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.showHud = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.setSearchText = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.confirmAlert = ConfirmAlertResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.getSelectedText = GetSelectedTextResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.popToRoot = AckResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      render: isSet20(object.render) ? AckResponse2.fromJSON(object.render) : void 0,
      showToast: isSet20(object.showToast) ? AckResponse2.fromJSON(object.showToast) : void 0,
      hideToast: isSet20(object.hideToast) ? AckResponse2.fromJSON(object.hideToast) : void 0,
      updateToast: isSet20(object.updateToast) ? AckResponse2.fromJSON(object.updateToast) : void 0,
      pushView: isSet20(object.pushView) ? AckResponse2.fromJSON(object.pushView) : void 0,
      popView: isSet20(object.popView) ? AckResponse2.fromJSON(object.popView) : void 0,
      clearSearch: isSet20(object.clearSearch) ? AckResponse2.fromJSON(object.clearSearch) : void 0,
      closeMainWindow: isSet20(object.closeMainWindow) ? AckResponse2.fromJSON(object.closeMainWindow) : void 0,
      showHud: isSet20(object.showHud) ? AckResponse2.fromJSON(object.showHud) : void 0,
      setSearchText: isSet20(object.setSearchText) ? AckResponse2.fromJSON(object.setSearchText) : void 0,
      confirmAlert: isSet20(object.confirmAlert) ? ConfirmAlertResponse2.fromJSON(object.confirmAlert) : void 0,
      getSelectedText: isSet20(object.getSelectedText) ? GetSelectedTextResponse2.fromJSON(object.getSelectedText) : void 0,
      popToRoot: isSet20(object.popToRoot) ? AckResponse2.fromJSON(object.popToRoot) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.render !== void 0) {
      obj.render = AckResponse2.toJSON(message.render);
    }
    if (message.showToast !== void 0) {
      obj.showToast = AckResponse2.toJSON(message.showToast);
    }
    if (message.hideToast !== void 0) {
      obj.hideToast = AckResponse2.toJSON(message.hideToast);
    }
    if (message.updateToast !== void 0) {
      obj.updateToast = AckResponse2.toJSON(message.updateToast);
    }
    if (message.pushView !== void 0) {
      obj.pushView = AckResponse2.toJSON(message.pushView);
    }
    if (message.popView !== void 0) {
      obj.popView = AckResponse2.toJSON(message.popView);
    }
    if (message.clearSearch !== void 0) {
      obj.clearSearch = AckResponse2.toJSON(message.clearSearch);
    }
    if (message.closeMainWindow !== void 0) {
      obj.closeMainWindow = AckResponse2.toJSON(message.closeMainWindow);
    }
    if (message.showHud !== void 0) {
      obj.showHud = AckResponse2.toJSON(message.showHud);
    }
    if (message.setSearchText !== void 0) {
      obj.setSearchText = AckResponse2.toJSON(message.setSearchText);
    }
    if (message.confirmAlert !== void 0) {
      obj.confirmAlert = ConfirmAlertResponse2.toJSON(message.confirmAlert);
    }
    if (message.getSelectedText !== void 0) {
      obj.getSelectedText = GetSelectedTextResponse2.toJSON(message.getSelectedText);
    }
    if (message.popToRoot !== void 0) {
      obj.popToRoot = AckResponse2.toJSON(message.popToRoot);
    }
    return obj;
  },
  create(base) {
    return Response14.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse14();
    message.render = object.render !== void 0 && object.render !== null ? AckResponse2.fromPartial(object.render) : void 0;
    message.showToast = object.showToast !== void 0 && object.showToast !== null ? AckResponse2.fromPartial(object.showToast) : void 0;
    message.hideToast = object.hideToast !== void 0 && object.hideToast !== null ? AckResponse2.fromPartial(object.hideToast) : void 0;
    message.updateToast = object.updateToast !== void 0 && object.updateToast !== null ? AckResponse2.fromPartial(object.updateToast) : void 0;
    message.pushView = object.pushView !== void 0 && object.pushView !== null ? AckResponse2.fromPartial(object.pushView) : void 0;
    message.popView = object.popView !== void 0 && object.popView !== null ? AckResponse2.fromPartial(object.popView) : void 0;
    message.clearSearch = object.clearSearch !== void 0 && object.clearSearch !== null ? AckResponse2.fromPartial(object.clearSearch) : void 0;
    message.closeMainWindow = object.closeMainWindow !== void 0 && object.closeMainWindow !== null ? AckResponse2.fromPartial(object.closeMainWindow) : void 0;
    message.showHud = object.showHud !== void 0 && object.showHud !== null ? AckResponse2.fromPartial(object.showHud) : void 0;
    message.setSearchText = object.setSearchText !== void 0 && object.setSearchText !== null ? AckResponse2.fromPartial(object.setSearchText) : void 0;
    message.confirmAlert = object.confirmAlert !== void 0 && object.confirmAlert !== null ? ConfirmAlertResponse2.fromPartial(object.confirmAlert) : void 0;
    message.getSelectedText = object.getSelectedText !== void 0 && object.getSelectedText !== null ? GetSelectedTextResponse2.fromPartial(object.getSelectedText) : void 0;
    message.popToRoot = object.popToRoot !== void 0 && object.popToRoot !== null ? AckResponse2.fromPartial(object.popToRoot) : void 0;
    return message;
  }
};
function createBaseThemedImageSource2() {
  return { light: "", dark: "" };
}
var ThemedImageSource2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.light !== "") {
      writer.uint32(10).string(message.light);
    }
    if (message.dark !== "") {
      writer.uint32(18).string(message.dark);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseThemedImageSource2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.light = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dark = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      light: isSet20(object.light) ? globalThis.String(object.light) : "",
      dark: isSet20(object.dark) ? globalThis.String(object.dark) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.light !== "") {
      obj.light = message.light;
    }
    if (message.dark !== "") {
      obj.dark = message.dark;
    }
    return obj;
  },
  create(base) {
    return ThemedImageSource2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseThemedImageSource2();
    message.light = object.light ?? "";
    message.dark = object.dark ?? "";
    return message;
  }
};
function createBaseImageSource2() {
  return { raw: void 0, themed: void 0 };
}
var ImageSource2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.raw !== void 0) {
      writer.uint32(10).string(message.raw);
    }
    if (message.themed !== void 0) {
      ThemedImageSource2.encode(message.themed, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageSource2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.raw = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.themed = ThemedImageSource2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      raw: isSet20(object.raw) ? globalThis.String(object.raw) : void 0,
      themed: isSet20(object.themed) ? ThemedImageSource2.fromJSON(object.themed) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.raw !== void 0) {
      obj.raw = message.raw;
    }
    if (message.themed !== void 0) {
      obj.themed = ThemedImageSource2.toJSON(message.themed);
    }
    return obj;
  },
  create(base) {
    return ImageSource2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageSource2();
    message.raw = object.raw ?? void 0;
    message.themed = object.themed !== void 0 && object.themed !== null ? ThemedImageSource2.fromPartial(object.themed) : void 0;
    return message;
  }
};
function createBaseDynamicColor2() {
  return { light: "", dark: "", adjustContrast: void 0 };
}
var DynamicColor2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.light !== "") {
      writer.uint32(10).string(message.light);
    }
    if (message.dark !== "") {
      writer.uint32(18).string(message.dark);
    }
    if (message.adjustContrast !== void 0) {
      writer.uint32(24).bool(message.adjustContrast);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDynamicColor2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.light = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dark = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.adjustContrast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      light: isSet20(object.light) ? globalThis.String(object.light) : "",
      dark: isSet20(object.dark) ? globalThis.String(object.dark) : "",
      adjustContrast: isSet20(object.adjustContrast) ? globalThis.Boolean(object.adjustContrast) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.light !== "") {
      obj.light = message.light;
    }
    if (message.dark !== "") {
      obj.dark = message.dark;
    }
    if (message.adjustContrast !== void 0) {
      obj.adjustContrast = message.adjustContrast;
    }
    return obj;
  },
  create(base) {
    return DynamicColor2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDynamicColor2();
    message.light = object.light ?? "";
    message.dark = object.dark ?? "";
    message.adjustContrast = object.adjustContrast ?? void 0;
    return message;
  }
};
function createBaseColorLike2() {
  return { raw: void 0, dynamic: void 0 };
}
var ColorLike4 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.raw !== void 0) {
      writer.uint32(10).string(message.raw);
    }
    if (message.dynamic !== void 0) {
      DynamicColor2.encode(message.dynamic, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseColorLike2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.raw = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dynamic = DynamicColor2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      raw: isSet20(object.raw) ? globalThis.String(object.raw) : void 0,
      dynamic: isSet20(object.dynamic) ? DynamicColor2.fromJSON(object.dynamic) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.raw !== void 0) {
      obj.raw = message.raw;
    }
    if (message.dynamic !== void 0) {
      obj.dynamic = DynamicColor2.toJSON(message.dynamic);
    }
    return obj;
  },
  create(base) {
    return ColorLike4.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseColorLike2();
    message.raw = object.raw ?? void 0;
    message.dynamic = object.dynamic !== void 0 && object.dynamic !== null ? DynamicColor2.fromPartial(object.dynamic) : void 0;
    return message;
  }
};
function createBaseImage2() {
  return { source: void 0, fallback: void 0, mask: void 0, tintColor: void 0 };
}
var Image5 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.source !== void 0) {
      ImageSource2.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.fallback !== void 0) {
      ImageSource2.encode(message.fallback, writer.uint32(18).fork()).join();
    }
    if (message.mask !== void 0) {
      writer.uint32(24).int32(message.mask);
    }
    if (message.tintColor !== void 0) {
      ColorLike4.encode(message.tintColor, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImage2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.source = ImageSource2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.fallback = ImageSource2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.mask = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.tintColor = ColorLike4.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      source: isSet20(object.source) ? ImageSource2.fromJSON(object.source) : void 0,
      fallback: isSet20(object.fallback) ? ImageSource2.fromJSON(object.fallback) : void 0,
      mask: isSet20(object.mask) ? imageMaskFromJSON2(object.mask) : void 0,
      tintColor: isSet20(object.tintColor) ? ColorLike4.fromJSON(object.tintColor) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.source !== void 0) {
      obj.source = ImageSource2.toJSON(message.source);
    }
    if (message.fallback !== void 0) {
      obj.fallback = ImageSource2.toJSON(message.fallback);
    }
    if (message.mask !== void 0) {
      obj.mask = imageMaskToJSON2(message.mask);
    }
    if (message.tintColor !== void 0) {
      obj.tintColor = ColorLike4.toJSON(message.tintColor);
    }
    return obj;
  },
  create(base) {
    return Image5.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImage2();
    message.source = object.source !== void 0 && object.source !== null ? ImageSource2.fromPartial(object.source) : void 0;
    message.fallback = object.fallback !== void 0 && object.fallback !== null ? ImageSource2.fromPartial(object.fallback) : void 0;
    message.mask = object.mask ?? void 0;
    message.tintColor = object.tintColor !== void 0 && object.tintColor !== null ? ColorLike4.fromPartial(object.tintColor) : void 0;
    return message;
  }
};
function isSet20(value) {
  return value !== null && value !== void 0;
}

// src/proto/oauth.ts
function createBasePKCEClientOptions2() {
  return { id: void 0, name: "", description: "", icon: void 0 };
}
var PKCEClientOptions2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== void 0) {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.icon !== void 0) {
      Image5.encode(message.icon, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePKCEClientOptions2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.icon = Image5.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet21(object.id) ? globalThis.String(object.id) : void 0,
      name: isSet21(object.name) ? globalThis.String(object.name) : "",
      description: isSet21(object.description) ? globalThis.String(object.description) : "",
      icon: isSet21(object.icon) ? Image5.fromJSON(object.icon) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== void 0) {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.icon !== void 0) {
      obj.icon = Image5.toJSON(message.icon);
    }
    return obj;
  },
  create(base) {
    return PKCEClientOptions2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePKCEClientOptions2();
    message.id = object.id ?? void 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.icon = object.icon !== void 0 && object.icon !== null ? Image5.fromPartial(object.icon) : void 0;
    return message;
  }
};
function createBaseAuthorizeRequest2() {
  return { client: void 0, url: "" };
}
var AuthorizeRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.client !== void 0) {
      PKCEClientOptions2.encode(message.client, writer.uint32(10).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthorizeRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.client = PKCEClientOptions2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      client: isSet21(object.client) ? PKCEClientOptions2.fromJSON(object.client) : void 0,
      url: isSet21(object.url) ? globalThis.String(object.url) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.client !== void 0) {
      obj.client = PKCEClientOptions2.toJSON(message.client);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return AuthorizeRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuthorizeRequest2();
    message.client = object.client !== void 0 && object.client !== null ? PKCEClientOptions2.fromPartial(object.client) : void 0;
    message.url = object.url ?? "";
    return message;
  }
};
function createBaseTokenSet2() {
  return {
    accessToken: "",
    refreshToken: void 0,
    idToken: void 0,
    expiresIn: void 0,
    scope: void 0,
    updatedAt: 0
  };
}
var TokenSet2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== void 0) {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.idToken !== void 0) {
      writer.uint32(26).string(message.idToken);
    }
    if (message.expiresIn !== void 0) {
      writer.uint32(32).uint32(message.expiresIn);
    }
    if (message.scope !== void 0) {
      writer.uint32(42).string(message.scope);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(48).uint64(message.updatedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTokenSet2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.idToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.expiresIn = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.scope = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.updatedAt = longToNumber2(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      accessToken: isSet21(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet21(object.refreshToken) ? globalThis.String(object.refreshToken) : void 0,
      idToken: isSet21(object.idToken) ? globalThis.String(object.idToken) : void 0,
      expiresIn: isSet21(object.expiresIn) ? globalThis.Number(object.expiresIn) : void 0,
      scope: isSet21(object.scope) ? globalThis.String(object.scope) : void 0,
      updatedAt: isSet21(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== void 0) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.idToken !== void 0) {
      obj.idToken = message.idToken;
    }
    if (message.expiresIn !== void 0) {
      obj.expiresIn = Math.round(message.expiresIn);
    }
    if (message.scope !== void 0) {
      obj.scope = message.scope;
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },
  create(base) {
    return TokenSet2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTokenSet2();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? void 0;
    message.idToken = object.idToken ?? void 0;
    message.expiresIn = object.expiresIn ?? void 0;
    message.scope = object.scope ?? void 0;
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  }
};
function createBaseGetTokensRequest2() {
  return { providerId: void 0 };
}
var GetTokensRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.providerId !== void 0) {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTokensRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { providerId: isSet21(object.providerId) ? globalThis.String(object.providerId) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.providerId !== void 0) {
      obj.providerId = message.providerId;
    }
    return obj;
  },
  create(base) {
    return GetTokensRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetTokensRequest2();
    message.providerId = object.providerId ?? void 0;
    return message;
  }
};
function createBaseGetTokensResponse2() {
  return { tokenSet: void 0 };
}
var GetTokensResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.tokenSet !== void 0) {
      TokenSet2.encode(message.tokenSet, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetTokensResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tokenSet = TokenSet2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { tokenSet: isSet21(object.tokenSet) ? TokenSet2.fromJSON(object.tokenSet) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenSet !== void 0) {
      obj.tokenSet = TokenSet2.toJSON(message.tokenSet);
    }
    return obj;
  },
  create(base) {
    return GetTokensResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetTokensResponse2();
    message.tokenSet = object.tokenSet !== void 0 && object.tokenSet !== null ? TokenSet2.fromPartial(object.tokenSet) : void 0;
    return message;
  }
};
function createBaseSetTokensRequest2() {
  return {
    providerId: void 0,
    accessToken: "",
    refreshToken: void 0,
    idToken: void 0,
    expiresIn: void 0,
    scope: void 0
  };
}
var SetTokensRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.providerId !== void 0) {
      writer.uint32(10).string(message.providerId);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== void 0) {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.idToken !== void 0) {
      writer.uint32(34).string(message.idToken);
    }
    if (message.expiresIn !== void 0) {
      writer.uint32(40).uint32(message.expiresIn);
    }
    if (message.scope !== void 0) {
      writer.uint32(50).string(message.scope);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetTokensRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.providerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.idToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.expiresIn = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.scope = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      providerId: isSet21(object.providerId) ? globalThis.String(object.providerId) : void 0,
      accessToken: isSet21(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet21(object.refreshToken) ? globalThis.String(object.refreshToken) : void 0,
      idToken: isSet21(object.idToken) ? globalThis.String(object.idToken) : void 0,
      expiresIn: isSet21(object.expiresIn) ? globalThis.Number(object.expiresIn) : void 0,
      scope: isSet21(object.scope) ? globalThis.String(object.scope) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.providerId !== void 0) {
      obj.providerId = message.providerId;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== void 0) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.idToken !== void 0) {
      obj.idToken = message.idToken;
    }
    if (message.expiresIn !== void 0) {
      obj.expiresIn = Math.round(message.expiresIn);
    }
    if (message.scope !== void 0) {
      obj.scope = message.scope;
    }
    return obj;
  },
  create(base) {
    return SetTokensRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetTokensRequest2();
    message.providerId = object.providerId ?? void 0;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? void 0;
    message.idToken = object.idToken ?? void 0;
    message.expiresIn = object.expiresIn ?? void 0;
    message.scope = object.scope ?? void 0;
    return message;
  }
};
function createBaseSetTokensResponse2() {
  return {};
}
var SetTokensResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetTokensResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return SetTokensResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseSetTokensResponse2();
    return message;
  }
};
function createBaseRemoveTokensRequest2() {
  return { providerId: void 0 };
}
var RemoveTokensRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.providerId !== void 0) {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveTokensRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { providerId: isSet21(object.providerId) ? globalThis.String(object.providerId) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.providerId !== void 0) {
      obj.providerId = message.providerId;
    }
    return obj;
  },
  create(base) {
    return RemoveTokensRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoveTokensRequest2();
    message.providerId = object.providerId ?? void 0;
    return message;
  }
};
function createBaseRemoveTokensResponse2() {
  return {};
}
var RemoveTokensResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveTokensResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return RemoveTokensResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseRemoveTokensResponse2();
    return message;
  }
};
function createBaseAuthorizeResponse2() {
  return { code: "" };
}
var AuthorizeResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthorizeResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { code: isSet21(object.code) ? globalThis.String(object.code) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },
  create(base) {
    return AuthorizeResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuthorizeResponse2();
    message.code = object.code ?? "";
    return message;
  }
};
function createBaseRequest15() {
  return { authorize: void 0, getTokens: void 0, setTokens: void 0, removeTokens: void 0 };
}
var Request15 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.authorize !== void 0) {
      AuthorizeRequest2.encode(message.authorize, writer.uint32(10).fork()).join();
    }
    if (message.getTokens !== void 0) {
      GetTokensRequest2.encode(message.getTokens, writer.uint32(18).fork()).join();
    }
    if (message.setTokens !== void 0) {
      SetTokensRequest2.encode(message.setTokens, writer.uint32(26).fork()).join();
    }
    if (message.removeTokens !== void 0) {
      RemoveTokensRequest2.encode(message.removeTokens, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest15();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.authorize = AuthorizeRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.getTokens = GetTokensRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.setTokens = SetTokensRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.removeTokens = RemoveTokensRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorize: isSet21(object.authorize) ? AuthorizeRequest2.fromJSON(object.authorize) : void 0,
      getTokens: isSet21(object.getTokens) ? GetTokensRequest2.fromJSON(object.getTokens) : void 0,
      setTokens: isSet21(object.setTokens) ? SetTokensRequest2.fromJSON(object.setTokens) : void 0,
      removeTokens: isSet21(object.removeTokens) ? RemoveTokensRequest2.fromJSON(object.removeTokens) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.authorize !== void 0) {
      obj.authorize = AuthorizeRequest2.toJSON(message.authorize);
    }
    if (message.getTokens !== void 0) {
      obj.getTokens = GetTokensRequest2.toJSON(message.getTokens);
    }
    if (message.setTokens !== void 0) {
      obj.setTokens = SetTokensRequest2.toJSON(message.setTokens);
    }
    if (message.removeTokens !== void 0) {
      obj.removeTokens = RemoveTokensRequest2.toJSON(message.removeTokens);
    }
    return obj;
  },
  create(base) {
    return Request15.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest15();
    message.authorize = object.authorize !== void 0 && object.authorize !== null ? AuthorizeRequest2.fromPartial(object.authorize) : void 0;
    message.getTokens = object.getTokens !== void 0 && object.getTokens !== null ? GetTokensRequest2.fromPartial(object.getTokens) : void 0;
    message.setTokens = object.setTokens !== void 0 && object.setTokens !== null ? SetTokensRequest2.fromPartial(object.setTokens) : void 0;
    message.removeTokens = object.removeTokens !== void 0 && object.removeTokens !== null ? RemoveTokensRequest2.fromPartial(object.removeTokens) : void 0;
    return message;
  }
};
function createBaseResponse15() {
  return { authorize: void 0, getTokens: void 0, setTokens: void 0, removeTokens: void 0 };
}
var Response15 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.authorize !== void 0) {
      AuthorizeResponse2.encode(message.authorize, writer.uint32(10).fork()).join();
    }
    if (message.getTokens !== void 0) {
      GetTokensResponse2.encode(message.getTokens, writer.uint32(18).fork()).join();
    }
    if (message.setTokens !== void 0) {
      SetTokensResponse2.encode(message.setTokens, writer.uint32(26).fork()).join();
    }
    if (message.removeTokens !== void 0) {
      RemoveTokensResponse2.encode(message.removeTokens, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse15();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.authorize = AuthorizeResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.getTokens = GetTokensResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.setTokens = SetTokensResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.removeTokens = RemoveTokensResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      authorize: isSet21(object.authorize) ? AuthorizeResponse2.fromJSON(object.authorize) : void 0,
      getTokens: isSet21(object.getTokens) ? GetTokensResponse2.fromJSON(object.getTokens) : void 0,
      setTokens: isSet21(object.setTokens) ? SetTokensResponse2.fromJSON(object.setTokens) : void 0,
      removeTokens: isSet21(object.removeTokens) ? RemoveTokensResponse2.fromJSON(object.removeTokens) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.authorize !== void 0) {
      obj.authorize = AuthorizeResponse2.toJSON(message.authorize);
    }
    if (message.getTokens !== void 0) {
      obj.getTokens = GetTokensResponse2.toJSON(message.getTokens);
    }
    if (message.setTokens !== void 0) {
      obj.setTokens = SetTokensResponse2.toJSON(message.setTokens);
    }
    if (message.removeTokens !== void 0) {
      obj.removeTokens = RemoveTokensResponse2.toJSON(message.removeTokens);
    }
    return obj;
  },
  create(base) {
    return Response15.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse15();
    message.authorize = object.authorize !== void 0 && object.authorize !== null ? AuthorizeResponse2.fromPartial(object.authorize) : void 0;
    message.getTokens = object.getTokens !== void 0 && object.getTokens !== null ? GetTokensResponse2.fromPartial(object.getTokens) : void 0;
    message.setTokens = object.setTokens !== void 0 && object.setTokens !== null ? SetTokensResponse2.fromPartial(object.setTokens) : void 0;
    message.removeTokens = object.removeTokens !== void 0 && object.removeTokens !== null ? RemoveTokensResponse2.fromPartial(object.removeTokens) : void 0;
    return message;
  }
};
function longToNumber2(int64) {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}
function isSet21(value) {
  return value !== null && value !== void 0;
}

// src/proto/storage.ts
function createBaseClearRequest4() {
  return {};
}
var ClearRequest4 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearRequest4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ClearRequest4.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseClearRequest4();
    return message;
  }
};
function createBaseGetRequest2() {
  return { key: "" };
}
var GetRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet22(object.key) ? globalThis.String(object.key) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },
  create(base) {
    return GetRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetRequest2();
    message.key = object.key ?? "";
    return message;
  }
};
function createBaseGetResponse2() {
  return { value: void 0 };
}
var GetResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet22(object?.value) ? object.value : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return GetResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetResponse2();
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseSetResponse2() {
  return {};
}
var SetResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return SetResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseSetResponse2();
    return message;
  }
};
function createBaseSetRequest2() {
  return { key: "", value: void 0 };
}
var SetRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet22(object.key) ? globalThis.String(object.key) : "",
      value: isSet22(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return SetRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetRequest2();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseRemoveRequest2() {
  return { key: "" };
}
var RemoveRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet22(object.key) ? globalThis.String(object.key) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },
  create(base) {
    return RemoveRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRemoveRequest2();
    message.key = object.key ?? "";
    return message;
  }
};
function createBaseRemoveResponse2() {
  return {};
}
var RemoveResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoveResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return RemoveResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseRemoveResponse2();
    return message;
  }
};
function createBaseClearResponse4() {
  return {};
}
var ClearResponse4 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClearResponse4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ClearResponse4.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseClearResponse4();
    return message;
  }
};
function createBaseListRequest2() {
  return {};
}
var ListRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ListRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseListRequest2();
    return message;
  }
};
function createBaseListResponse2() {
  return { values: {} };
}
var ListResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    Object.entries(message.values).forEach(([key, value]) => {
      if (value !== void 0) {
        ListResponse_ValuesEntry2.encode({ key, value }, writer.uint32(10).fork()).join();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = ListResponse_ValuesEntry2.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      values: isObject6(object.values) ? Object.entries(object.values).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return ListResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListResponse2();
    message.values = Object.entries(object.values ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    return message;
  }
};
function createBaseListResponse_ValuesEntry2() {
  return { key: "", value: void 0 };
}
var ListResponse_ValuesEntry2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListResponse_ValuesEntry2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet22(object.key) ? globalThis.String(object.key) : "",
      value: isSet22(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ListResponse_ValuesEntry2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListResponse_ValuesEntry2();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseRequest16() {
  return { get: void 0, set: void 0, remove: void 0, clear: void 0, list: void 0 };
}
var Request16 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.get !== void 0) {
      GetRequest2.encode(message.get, writer.uint32(10).fork()).join();
    }
    if (message.set !== void 0) {
      SetRequest2.encode(message.set, writer.uint32(18).fork()).join();
    }
    if (message.remove !== void 0) {
      RemoveRequest2.encode(message.remove, writer.uint32(26).fork()).join();
    }
    if (message.clear !== void 0) {
      ClearRequest4.encode(message.clear, writer.uint32(34).fork()).join();
    }
    if (message.list !== void 0) {
      ListRequest2.encode(message.list, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.get = GetRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.set = SetRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.remove = RemoveRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.clear = ClearRequest4.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.list = ListRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      get: isSet22(object.get) ? GetRequest2.fromJSON(object.get) : void 0,
      set: isSet22(object.set) ? SetRequest2.fromJSON(object.set) : void 0,
      remove: isSet22(object.remove) ? RemoveRequest2.fromJSON(object.remove) : void 0,
      clear: isSet22(object.clear) ? ClearRequest4.fromJSON(object.clear) : void 0,
      list: isSet22(object.list) ? ListRequest2.fromJSON(object.list) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.get !== void 0) {
      obj.get = GetRequest2.toJSON(message.get);
    }
    if (message.set !== void 0) {
      obj.set = SetRequest2.toJSON(message.set);
    }
    if (message.remove !== void 0) {
      obj.remove = RemoveRequest2.toJSON(message.remove);
    }
    if (message.clear !== void 0) {
      obj.clear = ClearRequest4.toJSON(message.clear);
    }
    if (message.list !== void 0) {
      obj.list = ListRequest2.toJSON(message.list);
    }
    return obj;
  },
  create(base) {
    return Request16.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest16();
    message.get = object.get !== void 0 && object.get !== null ? GetRequest2.fromPartial(object.get) : void 0;
    message.set = object.set !== void 0 && object.set !== null ? SetRequest2.fromPartial(object.set) : void 0;
    message.remove = object.remove !== void 0 && object.remove !== null ? RemoveRequest2.fromPartial(object.remove) : void 0;
    message.clear = object.clear !== void 0 && object.clear !== null ? ClearRequest4.fromPartial(object.clear) : void 0;
    message.list = object.list !== void 0 && object.list !== null ? ListRequest2.fromPartial(object.list) : void 0;
    return message;
  }
};
function createBaseResponse16() {
  return { get: void 0, set: void 0, remove: void 0, clear: void 0, list: void 0 };
}
var Response16 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.get !== void 0) {
      GetResponse2.encode(message.get, writer.uint32(10).fork()).join();
    }
    if (message.set !== void 0) {
      SetResponse2.encode(message.set, writer.uint32(18).fork()).join();
    }
    if (message.remove !== void 0) {
      RemoveResponse2.encode(message.remove, writer.uint32(26).fork()).join();
    }
    if (message.clear !== void 0) {
      ClearResponse4.encode(message.clear, writer.uint32(34).fork()).join();
    }
    if (message.list !== void 0) {
      ListResponse2.encode(message.list, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.get = GetResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.set = SetResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.remove = RemoveResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.clear = ClearResponse4.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.list = ListResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      get: isSet22(object.get) ? GetResponse2.fromJSON(object.get) : void 0,
      set: isSet22(object.set) ? SetResponse2.fromJSON(object.set) : void 0,
      remove: isSet22(object.remove) ? RemoveResponse2.fromJSON(object.remove) : void 0,
      clear: isSet22(object.clear) ? ClearResponse4.fromJSON(object.clear) : void 0,
      list: isSet22(object.list) ? ListResponse2.fromJSON(object.list) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.get !== void 0) {
      obj.get = GetResponse2.toJSON(message.get);
    }
    if (message.set !== void 0) {
      obj.set = SetResponse2.toJSON(message.set);
    }
    if (message.remove !== void 0) {
      obj.remove = RemoveResponse2.toJSON(message.remove);
    }
    if (message.clear !== void 0) {
      obj.clear = ClearResponse4.toJSON(message.clear);
    }
    if (message.list !== void 0) {
      obj.list = ListResponse2.toJSON(message.list);
    }
    return obj;
  },
  create(base) {
    return Response16.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse16();
    message.get = object.get !== void 0 && object.get !== null ? GetResponse2.fromPartial(object.get) : void 0;
    message.set = object.set !== void 0 && object.set !== null ? SetResponse2.fromPartial(object.set) : void 0;
    message.remove = object.remove !== void 0 && object.remove !== null ? RemoveResponse2.fromPartial(object.remove) : void 0;
    message.clear = object.clear !== void 0 && object.clear !== null ? ClearResponse4.fromPartial(object.clear) : void 0;
    message.list = object.list !== void 0 && object.list !== null ? ListResponse2.fromPartial(object.list) : void 0;
    return message;
  }
};
function isObject6(value) {
  return typeof value === "object" && value !== null;
}
function isSet22(value) {
  return value !== null && value !== void 0;
}

// src/proto/wm.ts
function createBaseWindow2() {
  return {
    id: "",
    title: "",
    workspaceId: "",
    active: false,
    fullscreen: false,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    app: void 0
  };
}
var Window2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.workspaceId !== "") {
      writer.uint32(26).string(message.workspaceId);
    }
    if (message.active !== false) {
      writer.uint32(32).bool(message.active);
    }
    if (message.fullscreen !== false) {
      writer.uint32(40).bool(message.fullscreen);
    }
    if (message.x !== 0) {
      writer.uint32(48).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(56).int32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(72).int32(message.height);
    }
    if (message.app !== void 0) {
      Application2.encode(message.app, writer.uint32(82).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWindow2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.workspaceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.active = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.fullscreen = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.x = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.y = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.height = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.app = Application2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet23(object.id) ? globalThis.String(object.id) : "",
      title: isSet23(object.title) ? globalThis.String(object.title) : "",
      workspaceId: isSet23(object.workspaceId) ? globalThis.String(object.workspaceId) : "",
      active: isSet23(object.active) ? globalThis.Boolean(object.active) : false,
      fullscreen: isSet23(object.fullscreen) ? globalThis.Boolean(object.fullscreen) : false,
      x: isSet23(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet23(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet23(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet23(object.height) ? globalThis.Number(object.height) : 0,
      app: isSet23(object.app) ? Application2.fromJSON(object.app) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.workspaceId !== "") {
      obj.workspaceId = message.workspaceId;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.fullscreen !== false) {
      obj.fullscreen = message.fullscreen;
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.app !== void 0) {
      obj.app = Application2.toJSON(message.app);
    }
    return obj;
  },
  create(base) {
    return Window2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWindow2();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.workspaceId = object.workspaceId ?? "";
    message.active = object.active ?? false;
    message.fullscreen = object.fullscreen ?? false;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.app = object.app !== void 0 && object.app !== null ? Application2.fromPartial(object.app) : void 0;
    return message;
  }
};
function createBaseScreen2() {
  return { name: "", model: "", make: "", serial: void 0, x: 0, y: 0, width: 0, height: 0 };
}
var Screen2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.make !== "") {
      writer.uint32(26).string(message.make);
    }
    if (message.serial !== void 0) {
      writer.uint32(34).string(message.serial);
    }
    if (message.x !== 0) {
      writer.uint32(40).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(48).int32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(56).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(64).int32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScreen2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.model = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.make = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.serial = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.x = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.y = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.width = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet23(object.name) ? globalThis.String(object.name) : "",
      model: isSet23(object.model) ? globalThis.String(object.model) : "",
      make: isSet23(object.make) ? globalThis.String(object.make) : "",
      serial: isSet23(object.serial) ? globalThis.String(object.serial) : void 0,
      x: isSet23(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet23(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet23(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet23(object.height) ? globalThis.Number(object.height) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.make !== "") {
      obj.make = message.make;
    }
    if (message.serial !== void 0) {
      obj.serial = message.serial;
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },
  create(base) {
    return Screen2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseScreen2();
    message.name = object.name ?? "";
    message.model = object.model ?? "";
    message.make = object.make ?? "";
    message.serial = object.serial ?? void 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  }
};
function createBaseWorkspace2() {
  return { id: "", name: "", active: false, fullscreen: false, monitor: "" };
}
var Workspace2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.active !== false) {
      writer.uint32(24).bool(message.active);
    }
    if (message.fullscreen !== false) {
      writer.uint32(32).bool(message.fullscreen);
    }
    if (message.monitor !== "") {
      writer.uint32(42).string(message.monitor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWorkspace2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.active = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.fullscreen = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.monitor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet23(object.id) ? globalThis.String(object.id) : "",
      name: isSet23(object.name) ? globalThis.String(object.name) : "",
      active: isSet23(object.active) ? globalThis.Boolean(object.active) : false,
      fullscreen: isSet23(object.fullscreen) ? globalThis.Boolean(object.fullscreen) : false,
      monitor: isSet23(object.monitor) ? globalThis.String(object.monitor) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.fullscreen !== false) {
      obj.fullscreen = message.fullscreen;
    }
    if (message.monitor !== "") {
      obj.monitor = message.monitor;
    }
    return obj;
  },
  create(base) {
    return Workspace2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWorkspace2();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.active = object.active ?? false;
    message.fullscreen = object.fullscreen ?? false;
    message.monitor = object.monitor ?? "";
    return message;
  }
};
function createBasePingRequest2() {
  return {};
}
var PingRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePingRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return PingRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBasePingRequest2();
    return message;
  }
};
function createBasePingResponse2() {
  return { ok: false };
}
var PingResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePingResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.ok = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { ok: isSet23(object.ok) ? globalThis.Boolean(object.ok) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    return obj;
  },
  create(base) {
    return PingResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePingResponse2();
    message.ok = object.ok ?? false;
    return message;
  }
};
function createBaseFocusWindowRequest2() {
  return { id: "" };
}
var FocusWindowRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFocusWindowRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet23(object.id) ? globalThis.String(object.id) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },
  create(base) {
    return FocusWindowRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFocusWindowRequest2();
    message.id = object.id ?? "";
    return message;
  }
};
function createBaseFocusWindowResponse2() {
  return { ok: false };
}
var FocusWindowResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFocusWindowResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.ok = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { ok: isSet23(object.ok) ? globalThis.Boolean(object.ok) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    return obj;
  },
  create(base) {
    return FocusWindowResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFocusWindowResponse2();
    message.ok = object.ok ?? false;
    return message;
  }
};
function createBaseGetActiveWindowRequest2() {
  return {};
}
var GetActiveWindowRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActiveWindowRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetActiveWindowRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetActiveWindowRequest2();
    return message;
  }
};
function createBaseGetActiveWindowResponse2() {
  return { window: void 0 };
}
var GetActiveWindowResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.window !== void 0) {
      Window2.encode(message.window, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActiveWindowResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.window = Window2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { window: isSet23(object.window) ? Window2.fromJSON(object.window) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.window !== void 0) {
      obj.window = Window2.toJSON(message.window);
    }
    return obj;
  },
  create(base) {
    return GetActiveWindowResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetActiveWindowResponse2();
    message.window = object.window !== void 0 && object.window !== null ? Window2.fromPartial(object.window) : void 0;
    return message;
  }
};
function createBaseGetWorkspacesRequest2() {
  return {};
}
var GetWorkspacesRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWorkspacesRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetWorkspacesRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetWorkspacesRequest2();
    return message;
  }
};
function createBaseGetWorkspacesResponse2() {
  return { workspaces: [] };
}
var GetWorkspacesResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.workspaces) {
      Workspace2.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWorkspacesResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.workspaces.push(Workspace2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      workspaces: globalThis.Array.isArray(object?.workspaces) ? object.workspaces.map((e) => Workspace2.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.workspaces?.length) {
      obj.workspaces = message.workspaces.map((e) => Workspace2.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWorkspacesResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWorkspacesResponse2();
    message.workspaces = object.workspaces?.map((e) => Workspace2.fromPartial(e)) || [];
    return message;
  }
};
function createBaseGetActiveWorkspaceRequest2() {
  return {};
}
var GetActiveWorkspaceRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActiveWorkspaceRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetActiveWorkspaceRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetActiveWorkspaceRequest2();
    return message;
  }
};
function createBaseGetActiveWorkspaceResponse2() {
  return { workspace: void 0 };
}
var GetActiveWorkspaceResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.workspace !== void 0) {
      Workspace2.encode(message.workspace, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetActiveWorkspaceResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.workspace = Workspace2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { workspace: isSet23(object.workspace) ? Workspace2.fromJSON(object.workspace) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.workspace !== void 0) {
      obj.workspace = Workspace2.toJSON(message.workspace);
    }
    return obj;
  },
  create(base) {
    return GetActiveWorkspaceResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetActiveWorkspaceResponse2();
    message.workspace = object.workspace !== void 0 && object.workspace !== null ? Workspace2.fromPartial(object.workspace) : void 0;
    return message;
  }
};
function createBaseGetScreensRequest2() {
  return {};
}
var GetScreensRequest2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetScreensRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetScreensRequest2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseGetScreensRequest2();
    return message;
  }
};
function createBaseGetScreensResponse2() {
  return { screens: [] };
}
var GetScreensResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.screens) {
      Screen2.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetScreensResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.screens.push(Screen2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      screens: globalThis.Array.isArray(object?.screens) ? object.screens.map((e) => Screen2.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.screens?.length) {
      obj.screens = message.screens.map((e) => Screen2.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetScreensResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetScreensResponse2();
    message.screens = object.screens?.map((e) => Screen2.fromPartial(e)) || [];
    return message;
  }
};
function createBaseGetWindowsRequest2() {
  return { workspaceId: void 0 };
}
var GetWindowsRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.workspaceId !== void 0) {
      writer.uint32(10).string(message.workspaceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWindowsRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.workspaceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { workspaceId: isSet23(object.workspaceId) ? globalThis.String(object.workspaceId) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.workspaceId !== void 0) {
      obj.workspaceId = message.workspaceId;
    }
    return obj;
  },
  create(base) {
    return GetWindowsRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWindowsRequest2();
    message.workspaceId = object.workspaceId ?? void 0;
    return message;
  }
};
function createBaseGetWindowsResponse2() {
  return { windows: [] };
}
var GetWindowsResponse2 = {
  encode(message, writer = new BinaryWriter2()) {
    for (const v of message.windows) {
      Window2.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetWindowsResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.windows.push(Window2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      windows: globalThis.Array.isArray(object?.windows) ? object.windows.map((e) => Window2.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => Window2.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GetWindowsResponse2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetWindowsResponse2();
    message.windows = object.windows?.map((e) => Window2.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSetWindowBoundsRequest2() {
  return { id: "", workspaceId: void 0 };
}
var SetWindowBoundsRequest2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.workspaceId !== void 0) {
      writer.uint32(26).string(message.workspaceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetWindowBoundsRequest2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.workspaceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet23(object.id) ? globalThis.String(object.id) : "",
      workspaceId: isSet23(object.workspaceId) ? globalThis.String(object.workspaceId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.workspaceId !== void 0) {
      obj.workspaceId = message.workspaceId;
    }
    return obj;
  },
  create(base) {
    return SetWindowBoundsRequest2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSetWindowBoundsRequest2();
    message.id = object.id ?? "";
    message.workspaceId = object.workspaceId ?? void 0;
    return message;
  }
};
function createBaseSetWindowBoundsResponse2() {
  return {};
}
var SetWindowBoundsResponse2 = {
  encode(_, writer = new BinaryWriter2()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetWindowBoundsResponse2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return SetWindowBoundsResponse2.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseSetWindowBoundsResponse2();
    return message;
  }
};
function createBaseRequest17() {
  return {
    ping: void 0,
    getActiveWindow: void 0,
    getActiveWorkspace: void 0,
    getWindows: void 0,
    getScreens: void 0,
    getWorkspaces: void 0,
    setWindowBounds: void 0,
    focusWindow: void 0
  };
}
var Request17 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ping !== void 0) {
      PingRequest2.encode(message.ping, writer.uint32(10).fork()).join();
    }
    if (message.getActiveWindow !== void 0) {
      GetActiveWindowRequest2.encode(message.getActiveWindow, writer.uint32(18).fork()).join();
    }
    if (message.getActiveWorkspace !== void 0) {
      GetActiveWorkspaceRequest2.encode(message.getActiveWorkspace, writer.uint32(26).fork()).join();
    }
    if (message.getWindows !== void 0) {
      GetWindowsRequest2.encode(message.getWindows, writer.uint32(34).fork()).join();
    }
    if (message.getScreens !== void 0) {
      GetScreensRequest2.encode(message.getScreens, writer.uint32(42).fork()).join();
    }
    if (message.getWorkspaces !== void 0) {
      GetWorkspacesRequest2.encode(message.getWorkspaces, writer.uint32(50).fork()).join();
    }
    if (message.setWindowBounds !== void 0) {
      SetWindowBoundsRequest2.encode(message.setWindowBounds, writer.uint32(58).fork()).join();
    }
    if (message.focusWindow !== void 0) {
      FocusWindowRequest2.encode(message.focusWindow, writer.uint32(66).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest17();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ping = PingRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.getActiveWindow = GetActiveWindowRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.getActiveWorkspace = GetActiveWorkspaceRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.getWindows = GetWindowsRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.getScreens = GetScreensRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.getWorkspaces = GetWorkspacesRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.setWindowBounds = SetWindowBoundsRequest2.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.focusWindow = FocusWindowRequest2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ping: isSet23(object.ping) ? PingRequest2.fromJSON(object.ping) : void 0,
      getActiveWindow: isSet23(object.getActiveWindow) ? GetActiveWindowRequest2.fromJSON(object.getActiveWindow) : void 0,
      getActiveWorkspace: isSet23(object.getActiveWorkspace) ? GetActiveWorkspaceRequest2.fromJSON(object.getActiveWorkspace) : void 0,
      getWindows: isSet23(object.getWindows) ? GetWindowsRequest2.fromJSON(object.getWindows) : void 0,
      getScreens: isSet23(object.getScreens) ? GetScreensRequest2.fromJSON(object.getScreens) : void 0,
      getWorkspaces: isSet23(object.getWorkspaces) ? GetWorkspacesRequest2.fromJSON(object.getWorkspaces) : void 0,
      setWindowBounds: isSet23(object.setWindowBounds) ? SetWindowBoundsRequest2.fromJSON(object.setWindowBounds) : void 0,
      focusWindow: isSet23(object.focusWindow) ? FocusWindowRequest2.fromJSON(object.focusWindow) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ping !== void 0) {
      obj.ping = PingRequest2.toJSON(message.ping);
    }
    if (message.getActiveWindow !== void 0) {
      obj.getActiveWindow = GetActiveWindowRequest2.toJSON(message.getActiveWindow);
    }
    if (message.getActiveWorkspace !== void 0) {
      obj.getActiveWorkspace = GetActiveWorkspaceRequest2.toJSON(message.getActiveWorkspace);
    }
    if (message.getWindows !== void 0) {
      obj.getWindows = GetWindowsRequest2.toJSON(message.getWindows);
    }
    if (message.getScreens !== void 0) {
      obj.getScreens = GetScreensRequest2.toJSON(message.getScreens);
    }
    if (message.getWorkspaces !== void 0) {
      obj.getWorkspaces = GetWorkspacesRequest2.toJSON(message.getWorkspaces);
    }
    if (message.setWindowBounds !== void 0) {
      obj.setWindowBounds = SetWindowBoundsRequest2.toJSON(message.setWindowBounds);
    }
    if (message.focusWindow !== void 0) {
      obj.focusWindow = FocusWindowRequest2.toJSON(message.focusWindow);
    }
    return obj;
  },
  create(base) {
    return Request17.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest17();
    message.ping = object.ping !== void 0 && object.ping !== null ? PingRequest2.fromPartial(object.ping) : void 0;
    message.getActiveWindow = object.getActiveWindow !== void 0 && object.getActiveWindow !== null ? GetActiveWindowRequest2.fromPartial(object.getActiveWindow) : void 0;
    message.getActiveWorkspace = object.getActiveWorkspace !== void 0 && object.getActiveWorkspace !== null ? GetActiveWorkspaceRequest2.fromPartial(object.getActiveWorkspace) : void 0;
    message.getWindows = object.getWindows !== void 0 && object.getWindows !== null ? GetWindowsRequest2.fromPartial(object.getWindows) : void 0;
    message.getScreens = object.getScreens !== void 0 && object.getScreens !== null ? GetScreensRequest2.fromPartial(object.getScreens) : void 0;
    message.getWorkspaces = object.getWorkspaces !== void 0 && object.getWorkspaces !== null ? GetWorkspacesRequest2.fromPartial(object.getWorkspaces) : void 0;
    message.setWindowBounds = object.setWindowBounds !== void 0 && object.setWindowBounds !== null ? SetWindowBoundsRequest2.fromPartial(object.setWindowBounds) : void 0;
    message.focusWindow = object.focusWindow !== void 0 && object.focusWindow !== null ? FocusWindowRequest2.fromPartial(object.focusWindow) : void 0;
    return message;
  }
};
function createBaseResponse17() {
  return {
    ping: void 0,
    getActiveWindow: void 0,
    getActiveWorkspace: void 0,
    getWindows: void 0,
    getScreens: void 0,
    getWorkspaces: void 0,
    setWindowBounds: void 0,
    focusWindow: void 0
  };
}
var Response17 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ping !== void 0) {
      PingResponse2.encode(message.ping, writer.uint32(10).fork()).join();
    }
    if (message.getActiveWindow !== void 0) {
      GetActiveWindowResponse2.encode(message.getActiveWindow, writer.uint32(18).fork()).join();
    }
    if (message.getActiveWorkspace !== void 0) {
      GetActiveWorkspaceResponse2.encode(message.getActiveWorkspace, writer.uint32(26).fork()).join();
    }
    if (message.getWindows !== void 0) {
      GetWindowsResponse2.encode(message.getWindows, writer.uint32(34).fork()).join();
    }
    if (message.getScreens !== void 0) {
      GetScreensResponse2.encode(message.getScreens, writer.uint32(42).fork()).join();
    }
    if (message.getWorkspaces !== void 0) {
      GetWorkspacesResponse2.encode(message.getWorkspaces, writer.uint32(50).fork()).join();
    }
    if (message.setWindowBounds !== void 0) {
      SetWindowBoundsResponse2.encode(message.setWindowBounds, writer.uint32(58).fork()).join();
    }
    if (message.focusWindow !== void 0) {
      FocusWindowResponse2.encode(message.focusWindow, writer.uint32(66).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse17();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ping = PingResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.getActiveWindow = GetActiveWindowResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.getActiveWorkspace = GetActiveWorkspaceResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.getWindows = GetWindowsResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.getScreens = GetScreensResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.getWorkspaces = GetWorkspacesResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.setWindowBounds = SetWindowBoundsResponse2.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.focusWindow = FocusWindowResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ping: isSet23(object.ping) ? PingResponse2.fromJSON(object.ping) : void 0,
      getActiveWindow: isSet23(object.getActiveWindow) ? GetActiveWindowResponse2.fromJSON(object.getActiveWindow) : void 0,
      getActiveWorkspace: isSet23(object.getActiveWorkspace) ? GetActiveWorkspaceResponse2.fromJSON(object.getActiveWorkspace) : void 0,
      getWindows: isSet23(object.getWindows) ? GetWindowsResponse2.fromJSON(object.getWindows) : void 0,
      getScreens: isSet23(object.getScreens) ? GetScreensResponse2.fromJSON(object.getScreens) : void 0,
      getWorkspaces: isSet23(object.getWorkspaces) ? GetWorkspacesResponse2.fromJSON(object.getWorkspaces) : void 0,
      setWindowBounds: isSet23(object.setWindowBounds) ? SetWindowBoundsResponse2.fromJSON(object.setWindowBounds) : void 0,
      focusWindow: isSet23(object.focusWindow) ? FocusWindowResponse2.fromJSON(object.focusWindow) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ping !== void 0) {
      obj.ping = PingResponse2.toJSON(message.ping);
    }
    if (message.getActiveWindow !== void 0) {
      obj.getActiveWindow = GetActiveWindowResponse2.toJSON(message.getActiveWindow);
    }
    if (message.getActiveWorkspace !== void 0) {
      obj.getActiveWorkspace = GetActiveWorkspaceResponse2.toJSON(message.getActiveWorkspace);
    }
    if (message.getWindows !== void 0) {
      obj.getWindows = GetWindowsResponse2.toJSON(message.getWindows);
    }
    if (message.getScreens !== void 0) {
      obj.getScreens = GetScreensResponse2.toJSON(message.getScreens);
    }
    if (message.getWorkspaces !== void 0) {
      obj.getWorkspaces = GetWorkspacesResponse2.toJSON(message.getWorkspaces);
    }
    if (message.setWindowBounds !== void 0) {
      obj.setWindowBounds = SetWindowBoundsResponse2.toJSON(message.setWindowBounds);
    }
    if (message.focusWindow !== void 0) {
      obj.focusWindow = FocusWindowResponse2.toJSON(message.focusWindow);
    }
    return obj;
  },
  create(base) {
    return Response17.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse17();
    message.ping = object.ping !== void 0 && object.ping !== null ? PingResponse2.fromPartial(object.ping) : void 0;
    message.getActiveWindow = object.getActiveWindow !== void 0 && object.getActiveWindow !== null ? GetActiveWindowResponse2.fromPartial(object.getActiveWindow) : void 0;
    message.getActiveWorkspace = object.getActiveWorkspace !== void 0 && object.getActiveWorkspace !== null ? GetActiveWorkspaceResponse2.fromPartial(object.getActiveWorkspace) : void 0;
    message.getWindows = object.getWindows !== void 0 && object.getWindows !== null ? GetWindowsResponse2.fromPartial(object.getWindows) : void 0;
    message.getScreens = object.getScreens !== void 0 && object.getScreens !== null ? GetScreensResponse2.fromPartial(object.getScreens) : void 0;
    message.getWorkspaces = object.getWorkspaces !== void 0 && object.getWorkspaces !== null ? GetWorkspacesResponse2.fromPartial(object.getWorkspaces) : void 0;
    message.setWindowBounds = object.setWindowBounds !== void 0 && object.setWindowBounds !== null ? SetWindowBoundsResponse2.fromPartial(object.setWindowBounds) : void 0;
    message.focusWindow = object.focusWindow !== void 0 && object.focusWindow !== null ? FocusWindowResponse2.fromPartial(object.focusWindow) : void 0;
    return message;
  }
};
function isSet23(value) {
  return value !== null && value !== void 0;
}

// src/proto/extension.ts
function createBaseRequest18() {
  return { requestId: "", data: void 0 };
}
var Request18 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.data !== void 0) {
      RequestData4.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequest18();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = RequestData4.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet24(object.requestId) ? globalThis.String(object.requestId) : "",
      data: isSet24(object.data) ? RequestData4.fromJSON(object.data) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.data !== void 0) {
      obj.data = RequestData4.toJSON(message.data);
    }
    return obj;
  },
  create(base) {
    return Request18.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequest18();
    message.requestId = object.requestId ?? "";
    message.data = object.data !== void 0 && object.data !== null ? RequestData4.fromPartial(object.data) : void 0;
    return message;
  }
};
function createBaseRequestData3() {
  return {
    ui: void 0,
    app: void 0,
    clipboard: void 0,
    storage: void 0,
    oauth: void 0,
    fileSearch: void 0,
    wm: void 0,
    command: void 0
  };
}
var RequestData4 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ui !== void 0) {
      Request14.encode(message.ui, writer.uint32(10).fork()).join();
    }
    if (message.app !== void 0) {
      Request10.encode(message.app, writer.uint32(18).fork()).join();
    }
    if (message.clipboard !== void 0) {
      Request11.encode(message.clipboard, writer.uint32(26).fork()).join();
    }
    if (message.storage !== void 0) {
      Request16.encode(message.storage, writer.uint32(34).fork()).join();
    }
    if (message.oauth !== void 0) {
      Request15.encode(message.oauth, writer.uint32(42).fork()).join();
    }
    if (message.fileSearch !== void 0) {
      Request13.encode(message.fileSearch, writer.uint32(50).fork()).join();
    }
    if (message.wm !== void 0) {
      Request17.encode(message.wm, writer.uint32(58).fork()).join();
    }
    if (message.command !== void 0) {
      Request12.encode(message.command, writer.uint32(66).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRequestData3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ui = Request14.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.app = Request10.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.clipboard = Request11.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.storage = Request16.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.oauth = Request15.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.fileSearch = Request13.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.wm = Request17.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.command = Request12.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ui: isSet24(object.ui) ? Request14.fromJSON(object.ui) : void 0,
      app: isSet24(object.app) ? Request10.fromJSON(object.app) : void 0,
      clipboard: isSet24(object.clipboard) ? Request11.fromJSON(object.clipboard) : void 0,
      storage: isSet24(object.storage) ? Request16.fromJSON(object.storage) : void 0,
      oauth: isSet24(object.oauth) ? Request15.fromJSON(object.oauth) : void 0,
      fileSearch: isSet24(object.fileSearch) ? Request13.fromJSON(object.fileSearch) : void 0,
      wm: isSet24(object.wm) ? Request17.fromJSON(object.wm) : void 0,
      command: isSet24(object.command) ? Request12.fromJSON(object.command) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ui !== void 0) {
      obj.ui = Request14.toJSON(message.ui);
    }
    if (message.app !== void 0) {
      obj.app = Request10.toJSON(message.app);
    }
    if (message.clipboard !== void 0) {
      obj.clipboard = Request11.toJSON(message.clipboard);
    }
    if (message.storage !== void 0) {
      obj.storage = Request16.toJSON(message.storage);
    }
    if (message.oauth !== void 0) {
      obj.oauth = Request15.toJSON(message.oauth);
    }
    if (message.fileSearch !== void 0) {
      obj.fileSearch = Request13.toJSON(message.fileSearch);
    }
    if (message.wm !== void 0) {
      obj.wm = Request17.toJSON(message.wm);
    }
    if (message.command !== void 0) {
      obj.command = Request12.toJSON(message.command);
    }
    return obj;
  },
  create(base) {
    return RequestData4.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRequestData3();
    message.ui = object.ui !== void 0 && object.ui !== null ? Request14.fromPartial(object.ui) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? Request10.fromPartial(object.app) : void 0;
    message.clipboard = object.clipboard !== void 0 && object.clipboard !== null ? Request11.fromPartial(object.clipboard) : void 0;
    message.storage = object.storage !== void 0 && object.storage !== null ? Request16.fromPartial(object.storage) : void 0;
    message.oauth = object.oauth !== void 0 && object.oauth !== null ? Request15.fromPartial(object.oauth) : void 0;
    message.fileSearch = object.fileSearch !== void 0 && object.fileSearch !== null ? Request13.fromPartial(object.fileSearch) : void 0;
    message.wm = object.wm !== void 0 && object.wm !== null ? Request17.fromPartial(object.wm) : void 0;
    message.command = object.command !== void 0 && object.command !== null ? Request12.fromPartial(object.command) : void 0;
    return message;
  }
};
function createBaseResponse18() {
  return { requestId: "", data: void 0, error: void 0 };
}
var Response18 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.data !== void 0) {
      ResponseData4.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== void 0) {
      ErrorResponse2.encode(message.error, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponse18();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = ResponseData4.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.error = ErrorResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet24(object.requestId) ? globalThis.String(object.requestId) : "",
      data: isSet24(object.data) ? ResponseData4.fromJSON(object.data) : void 0,
      error: isSet24(object.error) ? ErrorResponse2.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.data !== void 0) {
      obj.data = ResponseData4.toJSON(message.data);
    }
    if (message.error !== void 0) {
      obj.error = ErrorResponse2.toJSON(message.error);
    }
    return obj;
  },
  create(base) {
    return Response18.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponse18();
    message.requestId = object.requestId ?? "";
    message.data = object.data !== void 0 && object.data !== null ? ResponseData4.fromPartial(object.data) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? ErrorResponse2.fromPartial(object.error) : void 0;
    return message;
  }
};
function createBaseResponseData3() {
  return {
    ui: void 0,
    app: void 0,
    clipboard: void 0,
    storage: void 0,
    oauth: void 0,
    fileSearch: void 0,
    wm: void 0,
    command: void 0
  };
}
var ResponseData4 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.ui !== void 0) {
      Response14.encode(message.ui, writer.uint32(10).fork()).join();
    }
    if (message.app !== void 0) {
      Response10.encode(message.app, writer.uint32(18).fork()).join();
    }
    if (message.clipboard !== void 0) {
      Response11.encode(message.clipboard, writer.uint32(26).fork()).join();
    }
    if (message.storage !== void 0) {
      Response16.encode(message.storage, writer.uint32(34).fork()).join();
    }
    if (message.oauth !== void 0) {
      Response15.encode(message.oauth, writer.uint32(42).fork()).join();
    }
    if (message.fileSearch !== void 0) {
      Response13.encode(message.fileSearch, writer.uint32(50).fork()).join();
    }
    if (message.wm !== void 0) {
      Response17.encode(message.wm, writer.uint32(58).fork()).join();
    }
    if (message.command !== void 0) {
      Response12.encode(message.command, writer.uint32(66).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResponseData3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ui = Response14.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.app = Response10.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.clipboard = Response11.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.storage = Response16.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.oauth = Response15.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.fileSearch = Response13.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.wm = Response17.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.command = Response12.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ui: isSet24(object.ui) ? Response14.fromJSON(object.ui) : void 0,
      app: isSet24(object.app) ? Response10.fromJSON(object.app) : void 0,
      clipboard: isSet24(object.clipboard) ? Response11.fromJSON(object.clipboard) : void 0,
      storage: isSet24(object.storage) ? Response16.fromJSON(object.storage) : void 0,
      oauth: isSet24(object.oauth) ? Response15.fromJSON(object.oauth) : void 0,
      fileSearch: isSet24(object.fileSearch) ? Response13.fromJSON(object.fileSearch) : void 0,
      wm: isSet24(object.wm) ? Response17.fromJSON(object.wm) : void 0,
      command: isSet24(object.command) ? Response12.fromJSON(object.command) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ui !== void 0) {
      obj.ui = Response14.toJSON(message.ui);
    }
    if (message.app !== void 0) {
      obj.app = Response10.toJSON(message.app);
    }
    if (message.clipboard !== void 0) {
      obj.clipboard = Response11.toJSON(message.clipboard);
    }
    if (message.storage !== void 0) {
      obj.storage = Response16.toJSON(message.storage);
    }
    if (message.oauth !== void 0) {
      obj.oauth = Response15.toJSON(message.oauth);
    }
    if (message.fileSearch !== void 0) {
      obj.fileSearch = Response13.toJSON(message.fileSearch);
    }
    if (message.wm !== void 0) {
      obj.wm = Response17.toJSON(message.wm);
    }
    if (message.command !== void 0) {
      obj.command = Response12.toJSON(message.command);
    }
    return obj;
  },
  create(base) {
    return ResponseData4.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResponseData3();
    message.ui = object.ui !== void 0 && object.ui !== null ? Response14.fromPartial(object.ui) : void 0;
    message.app = object.app !== void 0 && object.app !== null ? Response10.fromPartial(object.app) : void 0;
    message.clipboard = object.clipboard !== void 0 && object.clipboard !== null ? Response11.fromPartial(object.clipboard) : void 0;
    message.storage = object.storage !== void 0 && object.storage !== null ? Response16.fromPartial(object.storage) : void 0;
    message.oauth = object.oauth !== void 0 && object.oauth !== null ? Response15.fromPartial(object.oauth) : void 0;
    message.fileSearch = object.fileSearch !== void 0 && object.fileSearch !== null ? Response13.fromPartial(object.fileSearch) : void 0;
    message.wm = object.wm !== void 0 && object.wm !== null ? Response17.fromPartial(object.wm) : void 0;
    message.command = object.command !== void 0 && object.command !== null ? Response12.fromPartial(object.command) : void 0;
    return message;
  }
};
function createBaseEvent2() {
  return { id: "", generic: void 0, crash: void 0, launch: void 0 };
}
var Event2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.generic !== void 0) {
      GenericEventData2.encode(message.generic, writer.uint32(18).fork()).join();
    }
    if (message.crash !== void 0) {
      CrashEventData2.encode(message.crash, writer.uint32(26).fork()).join();
    }
    if (message.launch !== void 0) {
      LaunchEventData2.encode(message.launch, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEvent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.generic = GenericEventData2.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.crash = CrashEventData2.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.launch = LaunchEventData2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet24(object.id) ? globalThis.String(object.id) : "",
      generic: isSet24(object.generic) ? GenericEventData2.fromJSON(object.generic) : void 0,
      crash: isSet24(object.crash) ? CrashEventData2.fromJSON(object.crash) : void 0,
      launch: isSet24(object.launch) ? LaunchEventData2.fromJSON(object.launch) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.generic !== void 0) {
      obj.generic = GenericEventData2.toJSON(message.generic);
    }
    if (message.crash !== void 0) {
      obj.crash = CrashEventData2.toJSON(message.crash);
    }
    if (message.launch !== void 0) {
      obj.launch = LaunchEventData2.toJSON(message.launch);
    }
    return obj;
  },
  create(base) {
    return Event2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEvent2();
    message.id = object.id ?? "";
    message.generic = object.generic !== void 0 && object.generic !== null ? GenericEventData2.fromPartial(object.generic) : void 0;
    message.crash = object.crash !== void 0 && object.crash !== null ? CrashEventData2.fromPartial(object.crash) : void 0;
    message.launch = object.launch !== void 0 && object.launch !== null ? LaunchEventData2.fromPartial(object.launch) : void 0;
    return message;
  }
};
function createBaseCrashEventData2() {
  return { text: "" };
}
var CrashEventData2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCrashEventData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { text: isSet24(object.text) ? globalThis.String(object.text) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return CrashEventData2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCrashEventData2();
    message.text = object.text ?? "";
    return message;
  }
};
function createBaseGenericEventData2() {
  return { json: "" };
}
var GenericEventData2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.json !== "") {
      writer.uint32(10).string(message.json);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericEventData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.json = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { json: isSet24(object.json) ? globalThis.String(object.json) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.json !== "") {
      obj.json = message.json;
    }
    return obj;
  },
  create(base) {
    return GenericEventData2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGenericEventData2();
    message.json = object.json ?? "";
    return message;
  }
};
function createBaseLaunchEventData2() {
  return {
    extensionName: "",
    commandName: "",
    mode: 0,
    entrypoint: "",
    assetPath: "",
    supportPath: "",
    preferenceValues: {},
    argumentValues: {},
    isRaycast: false,
    ownerOrAuthorName: ""
  };
}
var LaunchEventData2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.extensionName !== "") {
      writer.uint32(10).string(message.extensionName);
    }
    if (message.commandName !== "") {
      writer.uint32(18).string(message.commandName);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.entrypoint !== "") {
      writer.uint32(34).string(message.entrypoint);
    }
    if (message.assetPath !== "") {
      writer.uint32(42).string(message.assetPath);
    }
    if (message.supportPath !== "") {
      writer.uint32(50).string(message.supportPath);
    }
    Object.entries(message.preferenceValues).forEach(([key, value]) => {
      if (value !== void 0) {
        LaunchEventData_PreferenceValuesEntry2.encode({ key, value }, writer.uint32(58).fork()).join();
      }
    });
    Object.entries(message.argumentValues).forEach(([key, value]) => {
      if (value !== void 0) {
        LaunchEventData_ArgumentValuesEntry2.encode({ key, value }, writer.uint32(66).fork()).join();
      }
    });
    if (message.isRaycast !== false) {
      writer.uint32(72).bool(message.isRaycast);
    }
    if (message.ownerOrAuthorName !== "") {
      writer.uint32(82).string(message.ownerOrAuthorName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchEventData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.extensionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.commandName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.mode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.entrypoint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.assetPath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.supportPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          const entry7 = LaunchEventData_PreferenceValuesEntry2.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.preferenceValues[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          const entry8 = LaunchEventData_ArgumentValuesEntry2.decode(reader, reader.uint32());
          if (entry8.value !== void 0) {
            message.argumentValues[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.isRaycast = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.ownerOrAuthorName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      extensionName: isSet24(object.extensionName) ? globalThis.String(object.extensionName) : "",
      commandName: isSet24(object.commandName) ? globalThis.String(object.commandName) : "",
      mode: isSet24(object.mode) ? commandModeFromJSON2(object.mode) : 0,
      entrypoint: isSet24(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      assetPath: isSet24(object.assetPath) ? globalThis.String(object.assetPath) : "",
      supportPath: isSet24(object.supportPath) ? globalThis.String(object.supportPath) : "",
      preferenceValues: isObject7(object.preferenceValues) ? Object.entries(object.preferenceValues).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {},
      argumentValues: isObject7(object.argumentValues) ? Object.entries(object.argumentValues).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {},
      isRaycast: isSet24(object.isRaycast) ? globalThis.Boolean(object.isRaycast) : false,
      ownerOrAuthorName: isSet24(object.ownerOrAuthorName) ? globalThis.String(object.ownerOrAuthorName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.extensionName !== "") {
      obj.extensionName = message.extensionName;
    }
    if (message.commandName !== "") {
      obj.commandName = message.commandName;
    }
    if (message.mode !== 0) {
      obj.mode = commandModeToJSON2(message.mode);
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.assetPath !== "") {
      obj.assetPath = message.assetPath;
    }
    if (message.supportPath !== "") {
      obj.supportPath = message.supportPath;
    }
    if (message.preferenceValues) {
      const entries = Object.entries(message.preferenceValues);
      if (entries.length > 0) {
        obj.preferenceValues = {};
        entries.forEach(([k, v]) => {
          obj.preferenceValues[k] = v;
        });
      }
    }
    if (message.argumentValues) {
      const entries = Object.entries(message.argumentValues);
      if (entries.length > 0) {
        obj.argumentValues = {};
        entries.forEach(([k, v]) => {
          obj.argumentValues[k] = v;
        });
      }
    }
    if (message.isRaycast !== false) {
      obj.isRaycast = message.isRaycast;
    }
    if (message.ownerOrAuthorName !== "") {
      obj.ownerOrAuthorName = message.ownerOrAuthorName;
    }
    return obj;
  },
  create(base) {
    return LaunchEventData2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLaunchEventData2();
    message.extensionName = object.extensionName ?? "";
    message.commandName = object.commandName ?? "";
    message.mode = object.mode ?? 0;
    message.entrypoint = object.entrypoint ?? "";
    message.assetPath = object.assetPath ?? "";
    message.supportPath = object.supportPath ?? "";
    message.preferenceValues = Object.entries(object.preferenceValues ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    message.argumentValues = Object.entries(object.argumentValues ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    message.isRaycast = object.isRaycast ?? false;
    message.ownerOrAuthorName = object.ownerOrAuthorName ?? "";
    return message;
  }
};
function createBaseLaunchEventData_PreferenceValuesEntry2() {
  return { key: "", value: void 0 };
}
var LaunchEventData_PreferenceValuesEntry2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchEventData_PreferenceValuesEntry2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet24(object.key) ? globalThis.String(object.key) : "",
      value: isSet24(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return LaunchEventData_PreferenceValuesEntry2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLaunchEventData_PreferenceValuesEntry2();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseLaunchEventData_ArgumentValuesEntry2() {
  return { key: "", value: void 0 };
}
var LaunchEventData_ArgumentValuesEntry2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value2.encode(Value2.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchEventData_ArgumentValuesEntry2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value2.unwrap(Value2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet24(object.key) ? globalThis.String(object.key) : "",
      value: isSet24(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return LaunchEventData_ArgumentValuesEntry2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLaunchEventData_ArgumentValuesEntry2();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function isObject7(value) {
  return typeof value === "object" && value !== null;
}
function isSet24(value) {
  return value !== null && value !== void 0;
}

// src/proto/ipc.ts
function createBaseIpcMessage() {
  return {
    extensionRequest: void 0,
    extensionResponse: void 0,
    extensionEvent: void 0,
    managerRequest: void 0,
    managerResponse: void 0
  };
}
var IpcMessage = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.extensionRequest !== void 0) {
      QualifiedExtensionRequest.encode(message.extensionRequest, writer.uint32(10).fork()).join();
    }
    if (message.extensionResponse !== void 0) {
      QualifiedExtensionResponse.encode(message.extensionResponse, writer.uint32(18).fork()).join();
    }
    if (message.extensionEvent !== void 0) {
      QualifiedExtensionEvent.encode(message.extensionEvent, writer.uint32(26).fork()).join();
    }
    if (message.managerRequest !== void 0) {
      ManagerRequest.encode(message.managerRequest, writer.uint32(34).fork()).join();
    }
    if (message.managerResponse !== void 0) {
      ManagerResponse.encode(message.managerResponse, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIpcMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.extensionRequest = QualifiedExtensionRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extensionResponse = QualifiedExtensionResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.extensionEvent = QualifiedExtensionEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.managerRequest = ManagerRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.managerResponse = ManagerResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      extensionRequest: isSet25(object.extensionRequest) ? QualifiedExtensionRequest.fromJSON(object.extensionRequest) : void 0,
      extensionResponse: isSet25(object.extensionResponse) ? QualifiedExtensionResponse.fromJSON(object.extensionResponse) : void 0,
      extensionEvent: isSet25(object.extensionEvent) ? QualifiedExtensionEvent.fromJSON(object.extensionEvent) : void 0,
      managerRequest: isSet25(object.managerRequest) ? ManagerRequest.fromJSON(object.managerRequest) : void 0,
      managerResponse: isSet25(object.managerResponse) ? ManagerResponse.fromJSON(object.managerResponse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.extensionRequest !== void 0) {
      obj.extensionRequest = QualifiedExtensionRequest.toJSON(message.extensionRequest);
    }
    if (message.extensionResponse !== void 0) {
      obj.extensionResponse = QualifiedExtensionResponse.toJSON(message.extensionResponse);
    }
    if (message.extensionEvent !== void 0) {
      obj.extensionEvent = QualifiedExtensionEvent.toJSON(message.extensionEvent);
    }
    if (message.managerRequest !== void 0) {
      obj.managerRequest = ManagerRequest.toJSON(message.managerRequest);
    }
    if (message.managerResponse !== void 0) {
      obj.managerResponse = ManagerResponse.toJSON(message.managerResponse);
    }
    return obj;
  },
  create(base) {
    return IpcMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseIpcMessage();
    message.extensionRequest = object.extensionRequest !== void 0 && object.extensionRequest !== null ? QualifiedExtensionRequest.fromPartial(object.extensionRequest) : void 0;
    message.extensionResponse = object.extensionResponse !== void 0 && object.extensionResponse !== null ? QualifiedExtensionResponse.fromPartial(object.extensionResponse) : void 0;
    message.extensionEvent = object.extensionEvent !== void 0 && object.extensionEvent !== null ? QualifiedExtensionEvent.fromPartial(object.extensionEvent) : void 0;
    message.managerRequest = object.managerRequest !== void 0 && object.managerRequest !== null ? ManagerRequest.fromPartial(object.managerRequest) : void 0;
    message.managerResponse = object.managerResponse !== void 0 && object.managerResponse !== null ? ManagerResponse.fromPartial(object.managerResponse) : void 0;
    return message;
  }
};
function createBaseManagerRequest() {
  return { requestId: "", payload: void 0 };
}
var ManagerRequest = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.payload !== void 0) {
      RequestData3.encode(message.payload, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.payload = RequestData3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet25(object.requestId) ? globalThis.String(object.requestId) : "",
      payload: isSet25(object.payload) ? RequestData3.fromJSON(object.payload) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.payload !== void 0) {
      obj.payload = RequestData3.toJSON(message.payload);
    }
    return obj;
  },
  create(base) {
    return ManagerRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerRequest();
    message.requestId = object.requestId ?? "";
    message.payload = object.payload !== void 0 && object.payload !== null ? RequestData3.fromPartial(object.payload) : void 0;
    return message;
  }
};
function createBaseManagerResponse() {
  return { requestId: "", value: void 0, error: void 0 };
}
var ManagerResponse = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.value !== void 0) {
      ResponseData3.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.error !== void 0) {
      ErrorResponse2.encode(message.error, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseManagerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = ResponseData3.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.error = ErrorResponse2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      requestId: isSet25(object.requestId) ? globalThis.String(object.requestId) : "",
      value: isSet25(object.value) ? ResponseData3.fromJSON(object.value) : void 0,
      error: isSet25(object.error) ? ErrorResponse2.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.value !== void 0) {
      obj.value = ResponseData3.toJSON(message.value);
    }
    if (message.error !== void 0) {
      obj.error = ErrorResponse2.toJSON(message.error);
    }
    return obj;
  },
  create(base) {
    return ManagerResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseManagerResponse();
    message.requestId = object.requestId ?? "";
    message.value = object.value !== void 0 && object.value !== null ? ResponseData3.fromPartial(object.value) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? ErrorResponse2.fromPartial(object.error) : void 0;
    return message;
  }
};
function createBaseQualifiedExtensionRequest() {
  return { sessionId: "", request: void 0 };
}
var QualifiedExtensionRequest = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.request !== void 0) {
      Request18.encode(message.request, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQualifiedExtensionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.request = Request18.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sessionId: isSet25(object.sessionId) ? globalThis.String(object.sessionId) : "",
      request: isSet25(object.request) ? Request18.fromJSON(object.request) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.request !== void 0) {
      obj.request = Request18.toJSON(message.request);
    }
    return obj;
  },
  create(base) {
    return QualifiedExtensionRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQualifiedExtensionRequest();
    message.sessionId = object.sessionId ?? "";
    message.request = object.request !== void 0 && object.request !== null ? Request18.fromPartial(object.request) : void 0;
    return message;
  }
};
function createBaseQualifiedExtensionResponse() {
  return { sessionId: "", response: void 0 };
}
var QualifiedExtensionResponse = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.response !== void 0) {
      Response18.encode(message.response, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQualifiedExtensionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.response = Response18.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sessionId: isSet25(object.sessionId) ? globalThis.String(object.sessionId) : "",
      response: isSet25(object.response) ? Response18.fromJSON(object.response) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.response !== void 0) {
      obj.response = Response18.toJSON(message.response);
    }
    return obj;
  },
  create(base) {
    return QualifiedExtensionResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQualifiedExtensionResponse();
    message.sessionId = object.sessionId ?? "";
    message.response = object.response !== void 0 && object.response !== null ? Response18.fromPartial(object.response) : void 0;
    return message;
  }
};
function createBaseQualifiedExtensionEvent() {
  return { sessionId: "", event: void 0 };
}
var QualifiedExtensionEvent = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.event !== void 0) {
      Event2.encode(message.event, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQualifiedExtensionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.event = Event2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sessionId: isSet25(object.sessionId) ? globalThis.String(object.sessionId) : "",
      event: isSet25(object.event) ? Event2.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.event !== void 0) {
      obj.event = Event2.toJSON(message.event);
    }
    return obj;
  },
  create(base) {
    return QualifiedExtensionEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQualifiedExtensionEvent();
    message.sessionId = object.sessionId ?? "";
    message.event = object.event !== void 0 && object.event !== null ? Event2.fromPartial(object.event) : void 0;
    return message;
  }
};
function createBaseExtensionMessage2() {
  return { request: void 0, response: void 0, event: void 0 };
}
var ExtensionMessage2 = {
  encode(message, writer = new BinaryWriter2()) {
    if (message.request !== void 0) {
      Request18.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.response !== void 0) {
      Response18.encode(message.response, writer.uint32(18).fork()).join();
    }
    if (message.event !== void 0) {
      Event2.encode(message.event, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader2 ? input : new BinaryReader2(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionMessage2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.request = Request18.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.response = Response18.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.event = Event2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      request: isSet25(object.request) ? Request18.fromJSON(object.request) : void 0,
      response: isSet25(object.response) ? Response18.fromJSON(object.response) : void 0,
      event: isSet25(object.event) ? Event2.fromJSON(object.event) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.request !== void 0) {
      obj.request = Request18.toJSON(message.request);
    }
    if (message.response !== void 0) {
      obj.response = Response18.toJSON(message.response);
    }
    if (message.event !== void 0) {
      obj.event = Event2.toJSON(message.event);
    }
    return obj;
  },
  create(base) {
    return ExtensionMessage2.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseExtensionMessage2();
    message.request = object.request !== void 0 && object.request !== null ? Request18.fromPartial(object.request) : void 0;
    message.response = object.response !== void 0 && object.response !== null ? Response18.fromPartial(object.response) : void 0;
    message.event = object.event !== void 0 && object.event !== null ? Event2.fromPartial(object.event) : void 0;
    return message;
  }
};
function isSet25(value) {
  return value !== null && value !== void 0;
}

// src/index.ts
var path2 = __toESM(require("node:path"));
var fsp = __toESM(require("node:fs/promises"));
var WORKER_GRACE_PERIOD_MS = 1e4;
var WORKER_MAX_HEAP_SIZE_MB = 1e3;
var Vicinae = class {
  constructor() {
    this.workerPool = [];
    this.workerMap = /* @__PURE__ */ new Map();
    this.requestMap = /* @__PURE__ */ new Map();
    this.currentMessage = {
      data: Buffer.from("")
    };
    this.workerPool.push(this.createWorker("production"));
    process.stdin.on("error", (error) => {
      throw new Error(`${error}`);
    });
    process.stdin.on("data", (buf) => this.handleRead(buf));
  }
  formatError(error) {
    return `${error.stack}`;
  }
  async writePacket(message) {
    const packet = Buffer.allocUnsafe(message.length + 4);
    packet.writeUint32BE(message.length, 0);
    message.copy(packet, 4, 0);
    process.stdout.write(packet);
  }
  respond(requestId, value) {
    this.writeMessage({ managerResponse: { requestId, value } });
  }
  writeMessage(message) {
    const buf = Buffer.from(IpcMessage.encode(message).finish());
    this.writePacket(buf);
  }
  respondError(requestId, error) {
    this.writeMessage({ managerResponse: { requestId, error } });
  }
  parseMessage(packet) {
    return IpcMessage.decode(packet);
  }
  acquireWorker(env) {
    if (env === 0 /* Development */) {
      return this.createWorker("development");
    }
    if (!this.workerPool.length) {
      console.error("no worker in pool!");
    }
    const acquired = this.workerPool.pop() ?? this.createWorker("production");
    this.workerPool.push(this.createWorker("production"));
    return acquired;
  }
  async handleManagerRequest(request) {
    if (request.payload?.load) {
      const load = request.payload.load;
      const sessionId = (0, import_node_crypto8.randomUUID)();
      const supportPath = path2.join(
        load.vicinaePath,
        "support",
        load.extensionId
      );
      const supportInternal = path2.join(supportPath, ".vicinae");
      const assetsPath = path2.join(
        load.vicinaePath,
        "extensions",
        load.extensionId,
        "assets"
      );
      await Promise.all([
        fsp.mkdir(assetsPath, { recursive: true }),
        fsp.mkdir(supportInternal, { recursive: true })
      ]);
      const stdoutLog = path2.join(supportInternal, "stdout.txt");
      const stderrLog = path2.join(supportInternal, "stderr.txt");
      const worker = this.acquireWorker(load.env);
      const workerInfo = { worker };
      this.workerMap.set(sessionId, workerInfo);
      worker.on("messageerror", (error) => {
        console.error(error);
      });
      const sendCrash = (text) => {
        this.writeMessage({
          extensionEvent: {
            sessionId,
            event: { id: (0, import_node_crypto8.randomUUID)(), crash: { text } }
          }
        });
      };
      worker.on("error", (error) => {
        sendCrash(this.formatError(error));
        console.error(`worker error`, error);
      });
      worker.on("online", () => {
      });
      worker.on("message", (buf) => {
        try {
          const { event, request: request2 } = ExtensionMessage2.decode(buf);
          if (request2) {
            this.requestMap.set(request2.requestId, worker);
            this.writeMessage({ extensionRequest: { sessionId, request: request2 } });
            return;
          }
          if (event) {
            if (event.crash) {
              this.workerMap.delete(sessionId);
              worker.terminate();
            }
            this.writeMessage({ extensionEvent: { sessionId, event } });
          }
        } catch (_) {
          sendCrash(
            `The extension manager process received a malformed request.
This most likely indicates a problem with Vicinae, not the extension.
Please file a bug report: https://github.com/vicinaehq/vicinae/issues/new`
          );
          worker.terminate();
        }
      });
      const stdoutStream = fs.createWriteStream(stdoutLog);
      const stderrStream = fs.createWriteStream(stderrLog);
      worker.stdout.on("data", async (buf) => {
        stdoutStream.write(buf);
      });
      worker.stderr.on("data", async (buf) => {
        stderrStream.write(buf);
      });
      worker.on("error", (error) => {
        console.error(`worker error: ${error.name}:${error.message}`);
      });
      worker.on("exit", (code) => {
        console.error(`Worker exited with code ${code}`);
        if (!workerInfo.pendingTermination) {
          sendCrash(`Extension exited prematurely with exit code ${code}`);
        } else {
          clearTimeout(workerInfo.pendingTermination);
        }
        stdoutStream.close();
        stderrStream.close();
        this.workerMap.delete(sessionId);
      });
      worker.postMessage(
        ExtensionMessage2.encode({
          event: {
            id: (0, import_node_crypto8.randomUUID)(),
            launch: {
              entrypoint: load.entrypoint,
              preferenceValues: load.preferenceValues,
              argumentValues: load.argumentValues,
              mode: load.mode,
              supportPath,
              assetPath: assetsPath,
              isRaycast: load.isRaycast,
              extensionName: load.extensionName,
              ownerOrAuthorName: load.ownerOrAuthorName,
              commandName: load.commandName
            }
          }
        }).finish()
      );
      return this.respond(request.requestId, { load: { sessionId } });
    }
    if (request.payload?.unload) {
      const { sessionId } = request.payload.unload;
      const workerInfo = this.workerMap.get(sessionId);
      if (!workerInfo) {
        return this.respondError(request.requestId, {
          errorText: `No running command with session ${sessionId}`
        });
      }
      workerInfo.worker.postMessage(
        ExtensionMessage2.encode({
          event: { id: "shutdown", generic: { json: "[]" } }
        }).finish()
      );
      workerInfo.pendingTermination = setTimeout(() => {
        workerInfo.worker.terminate();
      }, WORKER_GRACE_PERIOD_MS);
      return this.respond(request.requestId, { ack: {} });
    }
    return this.respondError(request.requestId, {
      errorText: "No handler configured for this command"
    });
  }
  createWorker(env) {
    return new import_node_worker_threads3.Worker(__filename, {
      stdout: true,
      stderr: true,
      resourceLimits: {
        maxOldGenerationSizeMb: WORKER_MAX_HEAP_SIZE_MB
      },
      env: {
        ...process.env,
        NODE_ENV: env
      }
    });
  }
  async routeMessage(message) {
    const { managerRequest, extensionEvent, extensionResponse } = message;
    if (managerRequest) {
      this.handleManagerRequest(managerRequest);
    }
    if (extensionEvent) {
      const worker = this.workerMap.get(extensionEvent.sessionId);
      if (worker) {
        worker.worker.postMessage(
          ExtensionMessage2.encode({ event: extensionEvent.event }).finish()
        );
      }
    }
    if (extensionResponse) {
      const worker = this.workerMap.get(extensionResponse.sessionId);
      if (worker) {
        worker.worker.postMessage(
          ExtensionMessage2.encode({
            response: extensionResponse.response
          }).finish()
        );
      }
    }
  }
  handleRead(data) {
    this.currentMessage.data = Buffer.concat([this.currentMessage.data, data]);
    while (this.currentMessage.data.length >= 4) {
      const length = this.currentMessage.data.readUInt32BE();
      const isComplete = this.currentMessage.data.length - 4 >= length;
      if (!isComplete) return;
      const packet = this.currentMessage.data.subarray(4, length + 4);
      const message = this.parseMessage(packet);
      this.routeMessage(message);
      this.currentMessage.data = this.currentMessage.data.subarray(length + 4);
    }
  }
};
var main2 = async () => {
  if (!import_node_worker_threads3.isMainThread) {
    main();
    return;
  }
  if ((0, import_node_tty.isatty)(process.stdout.fd)) {
    console.error("Running the extension manager from a TTY is not supported.");
    process.exit(1);
  }
  new Vicinae();
};
main2();
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler.production.js:
  (**
   * @license React
   * react-reconciler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler.development.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler-constants.production.js:
  (**
   * @license React
   * react-reconciler-constants.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler-constants.development.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
